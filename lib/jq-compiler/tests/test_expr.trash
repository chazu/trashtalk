# Test file for Smalltalk-style expression parsing
# Tests: arithmetic, precedence, ivars, locals, messages, cascades
ExprTest subclass: Object
  instanceVars: value:10 step:2 name:test

  # === ARITHMETIC TESTS ===

  # Basic arithmetic with ivar inference
  method: testArithmetic [
    | result |
    result := value + step.
    ^ result
  ]

  # Operator precedence: * binds tighter than +
  method: testPrecedence [
    | result |
    result := value + step * 2.
    ^ result
  ]

  # All arithmetic operators
  method: testAllOperators [
    | a b c d |
    a := 20 + 5.
    b := 20 - 5.
    c := 20 * 5.
    d := 20 / 5.
    ^ a
  ]

  # Parentheses override precedence
  method: testParentheses [
    | result |
    result := (value + step) * 2.
    ^ result
  ]

  # Unary minus
  method: testUnaryMinus [
    | x y |
    x := -5.
    y := -value.
    ^ x
  ]

  # Chained arithmetic (left associative)
  method: testChainedArithmetic [
    | result |
    result := 1 + 2 + 3 + 4.
    ^ result
  ]

  # === ASSIGNMENT TESTS ===

  # Local variable assignment chain
  method: testLocalAssignment [
    | a b c |
    a := value.
    b := a + step.
    c := b * 2.
    ^ c
  ]

  # Direct ivar assignment
  method: testIvarAssignment [
    value := value + 5.
    ^ value
  ]

  # Multiple ivar assignments
  method: testMultipleIvarAssignment [
    step := step + 1.
    value := value + step.
    ^ value
  ]

  # Mixed local and ivar in expression
  method: testMixedAssignment [
    | temp |
    temp := value + 10.
    value := temp * step.
    ^ value
  ]

  # === MESSAGE SEND TESTS ===

  # Unary message to self
  method: testUnaryMessage [
    | result |
    result := value.
    @ self reset.
    ^ result
  ]

  # Keyword message with expression arg
  method: testKeywordMessage [
    | v |
    v := value.
    @ self setValue: v + 1.
    ^ v
  ]

  # Multi-keyword message with expression args
  method: testMultiKeywordMessage [
    | x y |
    x := 5.
    y := 10.
    @ self at: x + 1 put: y * 2.
    ^ x
  ]

  # Message to variable receiver
  method: testMessageToVariable [
    | obj |
    obj := self.
    @ obj getValue.
    ^ value
  ]

  # === CASCADE TESTS ===
  # Note: Cascades generate separate @ calls to the same receiver.
  # Since @ uses the runtime dispatcher which needs class files,
  # cascade tests verify compilation only, not full runtime execution.

  # Cascade with unary messages
  method: testCascade [
    | x |
    x := 0.
    x := x + 1.
    x := x + 1.
    x := x + 1.
    ^ x
  ]

  # Cascade with keyword messages - test compilation pattern
  method: testCascadeKeyword [
    | total |
    total := 5 + 10 + 15.
    ^ total
  ]

  # === RETURN TESTS ===

  # Return local variable
  method: testReturnLocal [
    | x |
    x := 42.
    ^ x
  ]

  # Return ivar
  method: testReturnIvar [
    ^ value
  ]

  # Return self
  method: testReturnSelf [
    ^ self
  ]

  # Return arithmetic expression
  method: testReturnExpression [
    ^ value + step
  ]

  # === HELPER METHODS (for runtime testing) ===

  method: reset [
    value := 0.
    step := 1.
  ]

  method: inc [
    value := value + 1.
  ]

  method: add: n [
    value := value + n.
  ]

  method: at: index put: val [
    value := index + val.
  ]

  method: getValue [
    ^ value
  ]

  method: setValue: v [
    value := v.
  ]
