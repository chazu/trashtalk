# ==============================================================================
# Trashtalk Code Generator
# ==============================================================================
#
# Generates bash code from the parsed AST.
#
# Input: JSON AST from parser
# Output: Bash source code
#
# Transformations applied in method bodies:
#   | var1 var2 |     →  local var1 var2
#   ^ expression      →  echo expression
#   self              →  $_RECEIVER
#   @ self method     →  @ $_RECEIVER method
#   @ recv key: val   →  @ "$recv" key "val"
#   var := expr       →  var=expr
#
# ==============================================================================

# ------------------------------------------------------------------------------
# Helper Functions
# ------------------------------------------------------------------------------

# Get current timestamp in ISO format
def timestamp:
  now | strftime("%Y-%m-%dT%H:%M:%S");

# Convert instance var list to space-separated string for metadata
def varsToString:
  [.[] | .name + (if .default then ":\(.default.value)" else "" end)] | join(" ");

# ------------------------------------------------------------------------------
# Code Generation: Header
# ------------------------------------------------------------------------------

def generateHeader:
  "#!/bin/bash",
  "# Generated by Trashtalk Compiler (jq) - DO NOT EDIT",
  "# Source: \(.name).trash\(if .isTrait then " (trait)" else "" end)",
  "# Generated: \(timestamp)",
  "";

def generateMetadata:
  if .isTrait then
    "__\(.name)__is_trait=\"1\"",
    ""
  else
    "__\(.name)__superclass=\"\(.parent // "")\"",
    "__\(.name)__instanceVars=\"\(.instanceVars | varsToString)\"",
    "__\(.name)__traits=\"\(.traits | join(" "))\"",
    ""
  end;

def generateRequires:
  if (.requires | length) > 0 then
    "# Required dependencies",
    (.requires[] | "source \"\(.)\""),
    ""
  else
    empty
  end;

# ------------------------------------------------------------------------------
# Code Generation: Method Body
# ------------------------------------------------------------------------------

# Transform a sequence of tokens into bash code
# This processes the raw tokens from the method body
def transformMethodBody($className; $isRaw):
  # Transform a single @ message send (handles multi-keyword methods)
  # Input: string like "@ recv key1: arg1 key2: arg2"
  # Output: string like "@ recv key1_key2 arg1 arg2"
  def transformMessageSend:
    if test("^@ [^ ]+ [a-zA-Z_][a-zA-Z0-9_]*:") then
      # Multi-keyword method: @ recv key1: arg1 key2: arg2 → @ recv key1_key2 arg1 arg2
      capture("^(?<prefix>@ [^ ]+ )(?<rest>.*)") |
      .prefix as $prefix |
      .rest |
      {keywords: [], args: [], remaining: .} |
      until(
        (.remaining | test("^[a-zA-Z_][a-zA-Z0-9_]*:") | not);
        if (.remaining | test("^[a-zA-Z_][a-zA-Z0-9_]*: ")) then
          . as $state |
          ($state.remaining | capture("^(?<kw>[a-zA-Z_][a-zA-Z0-9_]*): (?<arg>[^ \"']+|\"[^\"]*\"|'[^']*') *(?<rest>.*)")) |
          {
            keywords: ($state.keywords + [.kw]),
            args: ($state.args + [.arg]),
            remaining: .rest
          }
        else
          .remaining = ""
        end
      ) |
      if (.keywords | length) > 0 then
        $prefix + (.keywords | join("_")) + " " + (.args | join(" ")) + (if .remaining != "" then " " + .remaining else "" end)
      else
        $prefix + .remaining
      end
    elif test("^@ [^ ]+ [a-zA-Z_][a-zA-Z0-9_]*$") then
      # Unary method - already correct
      .
    else
      .
    end;

  # Transform DSL constructs inside a subshell
  # Handles: self → $_RECEIVER, keyword methods (including multi-keyword)
  def transformSubshellContents:
    # Replace self with $_RECEIVER
    gsub("\\bself\\b"; "$_RECEIVER") |
    # Transform multi-keyword methods by finding patterns and merging selectors
    # Pattern: @ recv key1: arg1 key2: arg2 → @ recv key1_key2 arg1 arg2
    # First, handle 2-keyword methods with simple args
    gsub("(?<pre>@ [^ )\"']+ )(?<k1>[a-zA-Z_][a-zA-Z0-9_]*): (?<a1>[^ )\"':]+) (?<k2>[a-zA-Z_][a-zA-Z0-9_]*): (?<a2>[^ )\"':]+)(?<end>[)\"]|$)";
      "\(.pre)\(.k1)_\(.k2) \(.a1) \(.a2)\(.end)") |
    # Handle 2-keyword with quoted second arg
    gsub("(?<pre>@ [^ )\"']+ )(?<k1>[a-zA-Z_][a-zA-Z0-9_]*): (?<a1>[^ )\"':]+) (?<k2>[a-zA-Z_][a-zA-Z0-9_]*): (?<a2>\"[^\"]*\")";
      "\(.pre)\(.k1)_\(.k2) \(.a1) \(.a2)") |
    # Handle single keyword method: @ recv method: arg → @ recv method arg
    gsub("(?<pre>@ [^ )\"']+ )(?<m>[a-zA-Z_][a-zA-Z0-9_]*): (?<arg>[^ )\"':]+)(?<end>[) \"]|$)";
      "\(.pre)\(.m) \(.arg)\(.end)") |
    # Handle single keyword with quoted arg: @ recv method: "arg" → @ recv method "arg"
    gsub("(?<pre>@ [^ )\"']+ )(?<m>[a-zA-Z_][a-zA-Z0-9_]*): (?<arg>\"[^\"]*\")";
      "\(.pre)\(.m) \(.arg)");

  # Helper to convert token array to string, applying transformations
  def tokensToCode:
    # Group tokens by line for processing
    reduce .[] as $tok ("";
      . + (
        if $tok.type == "NEWLINE" then "\n"
        elif $tok.type == "PIPE" then "| "  # Pipe with trailing space only
        elif $tok.type == "CARET" then "^"
        elif $tok.type == "AT" then "@ "
        elif $tok.type == "ASSIGN" then " := "
        elif $tok.type == "LBRACKET" then "["
        elif $tok.type == "RBRACKET" then "]"
        elif $tok.type == "DLBRACKET" then "[[ "  # [[ with trailing space
        elif $tok.type == "DRBRACKET" then " ]]"  # ]] with leading space
        elif $tok.type == "LPAREN" then "("
        elif $tok.type == "RPAREN" then ")"
        elif $tok.type == "SUBSHELL" then
          # Transform DSL inside subshells recursively
          ($tok.value | transformSubshellContents)
        elif $tok.type == "VARIABLE" then $tok.value + " "  # Keep $var with space
        elif $tok.type == "ARITHMETIC" then $tok.value  # Keep $((...)) as-is
        elif $tok.type == "DSTRING" then $tok.value + " "  # Keep "string" with space
        elif $tok.type == "STRING" then $tok.value + " "  # Keep 'string' with space
        elif $tok.type == "NUMBER" then $tok.value + " "  # Number with space
        elif $tok.type == "KEYWORD" then $tok.value + " "
        # Bash operators and punctuation
        elif $tok.type == "SEMI" then "; "  # Semicolon with trailing space
        elif $tok.type == "AND" then " && "  # && with spaces
        elif $tok.type == "OR" then " || "  # || with spaces
        elif $tok.type == "REDIRECT" then $tok.value  # >&, >>, etc. as-is
        elif $tok.type == "GT" then " >"
        elif $tok.type == "LT" then " <"
        elif $tok.type == "HEREDOC" then "<<"
        elif $tok.type == "MATCH" then " =~ "  # =~ with spaces
        elif $tok.type == "EQ" then " == "  # == with spaces
        elif $tok.type == "NE" then " != "  # != with spaces
        elif $tok.type == "EQUALS" then "="  # Plain = no spaces (assignment)
        elif $tok.type == "BANG" then "! "  # Negation
        elif $tok.type == "AMP" then " &"  # Background
        elif $tok.type == "DOT" then "."
        # Additional punctuation and operators
        elif $tok.type == "SLASH" then "/"
        elif $tok.type == "QUESTION" then "?"
        elif $tok.type == "PLUS" then "+"
        elif $tok.type == "STAR" then "*"
        elif $tok.type == "COMMA" then ", "
        elif $tok.type == "TILDE" then "~"
        elif $tok.type == "PERCENT" then "%"
        elif $tok.type == "BACKSLASH" then "\\"
        elif $tok.type == "LITERAL" then $tok.value  # Pass through unknown chars
        elif $tok.type == "PATH" then $tok.value + " "  # File path with space
        elif $tok.type == "CARET" then "^"  # Caret (for regexes)
        else $tok.value + " "
        end
      )
    ) |
    # Normalize whitespace: collapse multiple spaces (but not newlines), fix spacing around punctuation
    gsub(" +"; " ") |                  # Collapse multiple spaces to one
    gsub(" ;"; ";") |                  # Remove space before semicolon
    gsub(" \\]\\]"; " ]]") |           # Keep space before ]]
    gsub("\\[\\[ "; "[[ ") |           # Keep space after [[
    gsub(" \\| "; " | ") |             # Normalize pipe spacing
    # Fix regex quantifiers: remove space before ?, +, * when preceded by regex atoms
    gsub("\\] \\?"; "]?") |            # ]? pattern
    gsub("\\] \\+"; "]+") |            # ]+ pattern
    gsub("\\] \\*"; "]*") |            # ]* pattern
    gsub("\\$ \\?"; "$?") |            # $? pattern (regex end anchor + quantifier)
    gsub("- \\?"; "-?") |              # -? pattern (optional minus in regex)
    gsub("\\) \\?"; ")?") |            # )? pattern (optional group)
    # Fix file paths: normalize spacing around slashes in path-like contexts
    gsub("(?<pre>[a-zA-Z0-9_]) /(?<post>[a-zA-Z])"; "\(.pre)/\(.post)") |  # word / word -> word/word
    gsub("> ?/"; ">/") |               # Redirect to path
    gsub("2> ?/"; "2>/") |             # Stderr redirect to path
    # Fix assignment spacing - only for var=value patterns, not jq expressions like = "
    gsub(" =(?<c>[a-zA-Z0-9_$])"; "=\(.c)") |  # Remove space before = when followed by word char
    # Fix char class ranges like [0-9]
    gsub("(?<a>[0-9]) -(?<b>[0-9])"; "\(.a)-\(.b)") |  # digit-space-dash-digit -> digit-dash-digit
    gsub("(?<a>[a-zA-Z0-9]) \\](?<b>[^\\]])"; "\(.a)]\(.b)") |  # Remove space before ] not followed by ]
    # Fix number before redirect: 2> not 2 >
    gsub("(?<n>[0-9]) >"; "\(.n)>")
    ;

  # Transform keyword method calls: @ recv key1: arg1 key2: arg2 → @ recv key1_key2 arg1 arg2
  def transformKeywordMethod:
    if test("^@ [^ ]+ [a-zA-Z_][a-zA-Z0-9_]*:") then
      # Extract prefix (@ receiver) and rest
      capture("^(?<prefix>@ [^ ]+ )(?<rest>.*)") |
      .prefix as $prefix |
      .rest |
      # Iteratively extract keyword:arg pairs
      {keywords: [], args: [], remaining: .} |
      until(
        (.remaining | test("^[a-zA-Z_][a-zA-Z0-9_]*:") | not);
        if (.remaining | test("^[a-zA-Z_][a-zA-Z0-9_]*: ")) then
          # Save current state before capture
          . as $state |
          ($state.remaining | capture("^(?<kw>[a-zA-Z_][a-zA-Z0-9_]*): (?<arg>[^ \"']+|\"[^\"]*\"|'[^']*') *(?<rest>.*)")) |
          {
            keywords: ($state.keywords + [.kw]),
            args: ($state.args + [.arg]),
            remaining: .rest
          }
        else
          # Keyword without space after colon or malformed - stop
          .remaining = ""
        end
      ) |
      if (.keywords | length) > 0 then
        $prefix + (.keywords | join("_")) + " " + (.args | join(" ")) + (if .remaining != "" then " " + .remaining else "" end)
      else
        $prefix + .remaining
      end
    else
      .
    end;

  # Apply DSL transformations to a line
  def transformLine:
    # Trim leading/trailing whitespace
    gsub("^\\s+|\\s+$"; "") |

    # Skip empty lines
    if . == "" then ""

    # Local variable declaration: | var1 var2 |
    elif test("^\\|.*\\|$") then
      gsub("^\\|\\s*|\\s*\\|$"; "") |
      "  local \(.)"

    # Return statement: ^ expression
    elif test("^\\^") then
      gsub("^\\^\\s*"; "") |
      # Replace self with $_RECEIVER
      gsub("\\bself\\b"; "$_RECEIVER") |
      "  echo \(.)"

    # Assignment: var := expression
    elif test(":=") then
      gsub("\\bself\\b"; "$_RECEIVER") |
      gsub("\\s*:=\\s*"; "=") |
      "  \(.)"

    # Message send starting with @
    elif test("^@") then
      # Replace self with $_RECEIVER
      gsub("\\bself\\b"; "$_RECEIVER") |
      # Transform keyword method calls (key1: arg1 key2: arg2 → key1_key2 arg1 arg2)
      transformKeywordMethod |
      # For simple method calls, just remove the trailing colon
      gsub("(?<m>[a-zA-Z_][a-zA-Z0-9_]*): "; "\(.m) ") |
      # Quote $_RECEIVER in @ message sends
      gsub("@ \\$_RECEIVER "; "@ \"$_RECEIVER\" ") |
      "  \(.)"

    # Other lines - pass through with self replacement
    else
      gsub("\\bself\\b"; "$_RECEIVER") |
      "  \(.)"
    end;

  # Helper to strip leading/trailing empty lines from array
  def stripEmptyLines:
    # Remove leading empty/whitespace-only lines
    until(length == 0 or (.[0] | test("^\\s*$") | not); .[1:]) |
    # Remove trailing empty/whitespace-only lines
    until(length == 0 or (.[-1] | test("^\\s*$") | not); .[:-1]);

  # Convert tokens to code for raw methods - minimal transformation
  def tokensToRawCode:
    reduce .[] as $tok ("";
      . + (
        if $tok.type == "NEWLINE" then "\n"
        elif $tok.type == "COMMENT" then $tok.value
        elif $tok.type == "PIPE" then "| "
        elif $tok.type == "LBRACKET" then "["
        elif $tok.type == "RBRACKET" then "]"
        elif $tok.type == "DLBRACKET" then "[[ "
        elif $tok.type == "DRBRACKET" then " ]]"
        elif $tok.type == "LPAREN" then "("
        elif $tok.type == "RPAREN" then ") "
        elif $tok.type == "SEMI" then "; "
        elif $tok.type == "AND" then " && "
        elif $tok.type == "OR" then " || "
        elif $tok.type == "GT" then " >"
        elif $tok.type == "LT" then " <"
        elif $tok.type == "REDIRECT" then $tok.value
        elif $tok.type == "MATCH" then " =~ "
        elif $tok.type == "EQ" then " == "
        elif $tok.type == "NE" then " != "
        elif $tok.type == "EQUALS" then "= "
        elif $tok.type == "BANG" then "! "
        elif $tok.type == "AMP" then " &"
        elif $tok.type == "SLASH" then "/"
        elif $tok.type == "QUESTION" then "?"
        elif $tok.type == "PLUS" then "+"
        elif $tok.type == "STAR" then "*"
        elif $tok.type == "CARET" then "^"
        elif $tok.type == "SUBSHELL" then $tok.value
        elif $tok.type == "VARIABLE" then $tok.value + " "
        elif $tok.type == "ARITHMETIC" then $tok.value
        elif $tok.type == "ARITH_CMD" then $tok.value
        elif $tok.type == "DSTRING" then $tok.value + " "
        elif $tok.type == "STRING" then $tok.value + " "
        elif $tok.type == "NUMBER" then $tok.value + " "
        elif $tok.type == "PATH" then $tok.value + " "
        else $tok.value + " "
        end
      )
    ) |
    # Minimal normalization for raw methods
    gsub(" +"; " ") |              # Collapse multiple spaces
    gsub(" ;"; ";") |              # Fix semicolon spacing
    gsub("; ;"; ";;") |            # Fix double semicolon
    gsub("(?<a>[0-9]) -(?<b>[0-9])"; "\(.a)-\(.b)") |  # Fix char class ranges like [0-9]
    gsub("(?<a>[a-zA-Z0-9]) \\](?<b>[+*?$])"; "\(.a)]\(.b)") |  # Remove space before ] when followed by quantifier
    gsub("(?<a>[a-zA-Z0-9]) \\](?<b> \\]\\])"; "\(.a)]\(.b)") |  # Remove space before ] when followed by ]]
    gsub(" \\)"; ")") |            # Remove space before )
    gsub("\\( "; "(") |            # Remove space after (
    gsub("(?<n>[0-9]) >"; "\(.n)>") |  # Remove space before > only after digits (for 2>)
    gsub("> /"; ">/") |            # Remove space after > before path
    gsub("< (?<c>[^<])"; "<\(.c)") |  # Remove space after < unless followed by < (process substitution)
    gsub("(?<a>[a-zA-Z0-9_]) = (?<c>[0-9\"'$])"; "\(.a)=\(.c)") |  # Fix assignments: remove spaces around = when followed by value
    gsub("(?<a>[a-zA-Z0-9_]) = (?<c>[a-zA-Z])"; "\(.a)= \(.c)")   # Keep space after = for env var assignments (IFS= read)
    ;

  # Smart indentation for raw methods - tracks nesting, continuation, and heredocs
  def smartIndent:
    reduce .[] as $line ({lines: [], depth: 0, continuation: false, heredoc: null};
      ($line | gsub("^\\s+|\\s+$"; "")) as $trimmed |
      # Check if we're ending a heredoc (terminator must be at start of line, unindented)
      (if .heredoc != null and $trimmed == .heredoc then
        # This is the heredoc terminator - output without indent and clear heredoc state
        {
          lines: (.lines + [$trimmed]),
          depth: .depth,
          continuation: false,
          heredoc: null
        }
      elif .heredoc != null then
        # Inside heredoc - output line as-is without any indentation
        {
          lines: (.lines + [$line]),
          depth: .depth,
          continuation: .continuation,
          heredoc: .heredoc
        }
      else
        # Normal processing
        # Calculate indent for this line
        (if .continuation then .depth + 1 else .depth end) as $effectiveDepth |
        ("    " + ("    " * $effectiveDepth)) as $indent |
        # Determine if this line adjusts depth BEFORE indenting
        (if ($trimmed | test("^(done|fi|esac|;;)")) then .depth - 1 else .depth end) as $preDepth |
        # Use adjusted depth for dedent lines
        (if $preDepth < .depth then
          "    " + ("    " * ([0, $preDepth] | max))
        else
          $indent
        end) as $finalIndent |
        # Build line with indent
        (if $trimmed == "" then ""
         else $finalIndent + $trimmed
         end) as $indentedLine |
        # Update depth based on keywords
        (if ($trimmed | test("\\b(do|then)$")) then .depth + 1
         elif ($trimmed | test("^case .* in$")) then .depth + 1
         elif ($trimmed | test("^(done|fi|esac)$")) then [0, .depth - 1] | max
         else .depth
         end) as $newDepth |
        # Check if line ends with continuation
        ($trimmed | test("\\\\$")) as $isContinuation |
        # Check if line starts a heredoc (<<EOF or <<'EOF' or <<"EOF")
        (if ($trimmed | test("<<-?'?\"?([A-Za-z_][A-Za-z0-9_]*)'?\"?\\s*$")) then
          $trimmed | capture("<<-?'?\"?(?<term>[A-Za-z_][A-Za-z0-9_]*)'?\"?\\s*$") | .term
        else
          null
        end) as $heredocStart |
        {
          lines: (.lines + [$indentedLine]),
          depth: $newDepth,
          continuation: $isContinuation,
          heredoc: $heredocStart
        }
      end)
    ) | .lines;

  # Process the tokens
  if $isRaw then
    # Raw method - minimal processing with raw-specific conversion
    .tokens | tokensToRawCode | split("\n") | map(gsub("\\s+$"; "")) | smartIndent |
    stripEmptyLines | join("\n")
  else
    # Normal method - apply transformations
    .tokens | tokensToCode | split("\n") | map(transformLine) |
    # Filter out null results and strip leading/trailing empty lines
    map(select(. != null)) | stripEmptyLines | join("\n")
  end;

# ------------------------------------------------------------------------------
# Code Generation: Method
# ------------------------------------------------------------------------------

def generateMethod($className):
  # Build function name
  (if .kind == "class" then
    "__\($className)__class__\(.selector)"
  else
    "__\($className)__\(.selector)"
  end) as $funcName |

  # Generate argument bindings for keyword methods
  (if (.args | length) > 0 then
    [.args | to_entries[] | "  local \(.value)=\"$\(.key + 1)\""] | join("\n")
  else
    ""
  end) as $argBindings |

  # Generate body
  .raw as $isRaw |
  (.body | transformMethodBody($className; $isRaw)) as $body |

  # Combine into function
  "\($funcName)() {",
  (if $argBindings != "" then $argBindings else empty end),
  $body,
  "}",
  "";

# ------------------------------------------------------------------------------
# Main Code Generator
# ------------------------------------------------------------------------------

def generate:
  . as $class |
  (
    generateHeader,
    generateMetadata,
    generateRequires,
    (.methods[] | generateMethod($class.name))
  );

# ==============================================================================
# Entry Point
# ==============================================================================

generate
