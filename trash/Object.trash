Object subclass: nil

  # Return a canonical string representation of this object
  # Format: <ClassName instanceId>
  rawMethod: printString [
    echo "<${_CLASS} ${_INSTANCE}>"
  ]

  # Return the class name of this object
  rawMethod: class [
    echo "$_CLASS"
  ]

  # Return the instance ID of this object
  rawMethod: id [
    echo "$_INSTANCE"
  ]

  # Check if this object is an instance of a given class
  rawMethod: isKindOf: className [
    local current="$_CLASS"
    while [[ -n "$current" ]]; do
      if [[ "$current" == "$className" ]]; then
        echo "true"
        return 0
      fi
      local super_var="__${current}__superclass"
      current="${!super_var:-}"
    done
    echo "false"
  ]

  # Check if this object conforms to a protocol
  rawMethod: conformsTo: protocolName [
    _conforms_to "$_CLASS" "$protocolName"
  ]

  # Delete this object from the database
  rawMethod: delete [
    _delete_instance "$_INSTANCE"
  ]

  # Return a detailed inspection of this object
  # Shows class name, instance ID, and all instance variables with values
  rawMethod: inspect [
    local data
    data=$(db_get "$_RECEIVER" 2>/dev/null)

    echo "a $_CLASS"
    echo "  id: $_INSTANCE"

    if [[ -n "$data" && "$data" != "{}" ]]; then
      echo "DATA FOUND"
      echo "$data" | jq -r 'to_entries | .[] | "  \(.key): \(.value)"'
    else
      @ Trash methodsFor $_RECEIVER
    fi
  ]

  # Write inspection output to a file
  # Usage: @ $obj inspectTo: "/tmp/inspect.txt"
  rawMethod: inspectTo: filepath [
    @ "$_RECEIVER" inspect > "$filepath"
    echo "$filepath"
  ]

  # Return all instance IDs for this class
  # Usage: @ Counter findAll
  rawClassMethod: findAll [
    db_find_by_class "$_CLASS"
  ]

  # Return count of instances for this class
  # Usage: @ Counter count
  rawClassMethod: count [
    db_count_by_class "$_CLASS"
  ]

  # Find instances matching a predicate
  # Usage: @ Counter find 'value > 5'
  # Supports: =, !=, >, <, >=, <=
  # Returns: newline-separated list of instance IDs
  rawClassMethod: find [
    local predicate="$1"

    if [[ -z "$predicate" ]]; then
      db_find_by_class "$_CLASS"
      return
    fi

    # Parse predicate using helper function from runtime
    _find_with_predicate "$_CLASS" "$predicate"
  ]

  # Return this object's data as JSON
  # Usage: @ $counter asJson
  rawMethod: asJson [
    db_get "$_RECEIVER"
  ]

  # Edit this class's source file and recompile if changed
  # Usage: @ Counter edit
  rawClassMethod: edit [
    local source_file="$TRASHDIR/${_CLASS}.trash"
    local trait_source="$TRASHDIR/traits/${_CLASS}.trash"
    local file_to_edit=""

    # Find source file
    if [[ -f "$source_file" ]]; then
      file_to_edit="$source_file"
    elif [[ -f "$trait_source" ]]; then
      file_to_edit="$trait_source"
    else
      echo "Error: No source file found for $_CLASS"
      return 1
    fi

    # Get modification time before editing
    local before_mtime after_mtime
    before_mtime=$(stat -f "%m" "$file_to_edit" 2>/dev/null || stat -c "%Y" "$file_to_edit" 2>/dev/null)

    # Open in editor
    ${EDITOR:-vi} "$file_to_edit" </dev/tty >/dev/tty

    # Check if modified and recompile
    after_mtime=$(stat -f "%m" "$file_to_edit" 2>/dev/null || stat -c "%Y" "$file_to_edit" 2>/dev/null)

    if [[ "$before_mtime" != "$after_mtime" ]]; then
      echo "File modified, compiling..."
      @ Trash compileAndReload "$_CLASS"
    else
      echo "No changes detected"
    fi
  ]
