# Object - Base class for all Trashtalk objects
Object subclass: nil
  pragma: primitiveClass

  # Create a new instance of this class
  # Subclasses inherit this - no need to define your own unless custom init needed
  classMethod: new [
    local id
    # Use $_CLASS directly - it's already set by dispatcher to the calling class
    # Don't use @ Runtime class - that makes a nested send which changes $_CLASS
    id=$(@ Runtime generateId: "$_CLASS")
    @ Runtime create: "$_CLASS" id: "$id"
    echo "$id"
  ]

  # Return a canonical string representation of this object
  # Format: <ClassName instanceId>
  method: printString [
    echo "<${_CLASS} ${_INSTANCE}>"
  ]

  # Return the class name of this object
  method: class [
    echo "$_CLASS"
  ]

  # Return the instance ID of this object
  method: id [
    echo "$_INSTANCE"
  ]

  # Check if this object is an instance of a given class
  method: isKindOf: className [
    local current="$1"
    local my_class="$_CLASS"
    current="$my_class"
    while [[ -n "$current" ]]; do
      if [[ "$current" == "$1" ]]; then
        echo "true"
        return 0
      fi
      current=$(@ Runtime superclassOf: "$current")
    done
    echo "false"
  ]

  # Check if this object conforms to a protocol
  method: conformsTo: protocolName [
    local class="$_CLASS"
    _conforms_to "$class" "$1"
  ]

  # Delete this object from memory
  method: delete [
    local instance
    instance=$(@ Runtime instance)
    @ Runtime delete: "$instance"
  ]

  # Return a detailed inspection of this object
  # Shows class name, instance ID, and all instance variables with values
  method: inspect [
    local data class instance
    class="$_CLASS"
    instance="$_INSTANCE"
    data=$(@ Runtime dataFor: "$_RECEIVER")

    echo "a $class"
    echo "  id: $instance"

    if [[ -n "$data" && "$data" != "{}" ]]; then
      echo "$data" | jq -r 'to_entries | .[] | "  \(.key): \(.value)"'
    else
      @ Trash methodsFor: "$_RECEIVER"
    fi
  ]

  # Write inspection output to a file
  method: inspectTo: filepath [
    local output filepath="$1"
    output=$(@ "$_RECEIVER" inspect)
    @ File write: "$output" to: "$filepath"
    echo "$filepath"
  ]

  # Return this object's data as JSON
  method: asJson [
    @ Runtime dataFor: "$_RECEIVER"
  ]

  # Edit this class's source file and recompile if changed
  classMethod: edit [
    local class source_file trait_source file_to_edit editor
    class="$_CLASS"
    source_file="$TRASHDIR/${class}.trash"
    trait_source="$TRASHDIR/traits/${class}.trash"
    file_to_edit=""

    # Find source file
    if [[ -f "$source_file" ]]; then
      file_to_edit="$source_file"
    elif [[ -f "$trait_source" ]]; then
      file_to_edit="$trait_source"
    else
      @ Console error: "Error: No source file found for $class"
      return 1
    fi

    # Get modification time before editing
    local before_mtime after_mtime
    before_mtime=$(@ File modificationTime: "$file_to_edit")

    # Open in editor
    editor=$(@ Env editor)
    "$editor" "$file_to_edit" </dev/tty >/dev/tty

    # Check if modified and recompile
    after_mtime=$(@ File modificationTime: "$file_to_edit")

    if [[ "$before_mtime" != "$after_mtime" ]]; then
      @ Console print: "File modified, compiling..."
      @ Trash compileAndReload: "$class"
    else
      @ Console print: "No changes detected"
    fi
  ]
