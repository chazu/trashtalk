# Coproc - Bidirectional subprocess communication
# Provides reliable async process interaction via FIFOs
Coproc subclass: Object
  pragma: primitiveClass
  instanceVars: command:'' pid:'' fifoIn:'' fifoOut:'' status:''

  # Create a coproc for a command (does not start it yet)
  classMethod: for: cmd [
    local id
    id=$(_generate_instance_id Coproc)
    _create_instance Coproc "$id"
    @ "$id" _setCommand: "$cmd"
    @ "$id" _setStatus: "created"
    echo "$id"
  ]

  # Start the coprocess in read-only mode (no stdin needed)
  # Better for commands that just produce output (like grpcurl subscribe)
  method: startReadOnly [
    local cmd bg_pid fifo_out pidfile
    cmd="$(_ivar command)"

    if [[ -z "$cmd" ]]; then
      echo "Error: No command set" >&2
      return 1
    fi

    fifo_out="/tmp/coproc_${_INSTANCE}_out"
    pidfile="/tmp/coproc_${_INSTANCE}_pid"
    rm -f "$fifo_out" "$pidfile"
    mkfifo "$fifo_out"

    # Spawn command in separate bash. The inner script:
    # 1. Opens FIFO read-write (fd 3) to prevent blocking
    # 2. Starts the command writing to the FIFO
    # 3. Closes fd 3 and writes PID
    /bin/bash -c '
      exec 3<>"$2"
      eval "$1" >"$2" 2>&1 &
      pid=$!
      exec 3<&-
      echo $pid > "$3"
    ' _ "$cmd" "$fifo_out" "$pidfile" </dev/null >/dev/null 2>&1

    # Small delay to ensure PID file is written
    sleep 0.1

    # Read the actual command PID
    bg_pid=$(cat "$pidfile" 2>/dev/null)
    rm -f "$pidfile"

    _ivar_set pid "$bg_pid"
    _ivar_set fifoOut "$fifo_out"
    _ivar_set status "running"
  ]

  # Start with bidirectional communication
  method: start [
    local cmd bg_pid fifo_in fifo_out pidfile
    cmd="$(_ivar command)"

    if [[ -z "$cmd" ]]; then
      echo "Error: No command set" >&2
      return 1
    fi

    fifo_in="/tmp/coproc_${_INSTANCE}_in"
    fifo_out="/tmp/coproc_${_INSTANCE}_out"
    pidfile="/tmp/coproc_${_INSTANCE}_pid"
    rm -f "$fifo_in" "$fifo_out" "$pidfile"
    mkfifo "$fifo_in" "$fifo_out"

    # Start command in separate bash to fully detach from parent shell.
    # This prevents $() from waiting for the background process.
    /bin/bash -c '
      eval "$1" < "$2" > "$3" 2>&1 &
      echo $! > "$4"
    ' _ "$cmd" "$fifo_in" "$fifo_out" "$pidfile" </dev/null >/dev/null 2>&1

    # Small delay to ensure PID file is written
    sleep 0.02

    # Read the actual command PID
    bg_pid=$(cat "$pidfile" 2>/dev/null)

    _ivar_set pid "$bg_pid"
    _ivar_set fifoIn "$fifo_in"
    _ivar_set fifoOut "$fifo_out"
    _ivar_set status "running"

    echo "$bg_pid"
  ]

  # Read a single line from the process output
  # NOTE: Opens/closes FIFO each time - use readLines for continuous reading
  method: readLine [
    local fifo_out line
    fifo_out="$(_ivar fifoOut)"

    if [[ -z "$fifo_out" ]] || [[ ! -p "$fifo_out" ]]; then
      echo "Error: Coproc not started or FIFO missing" >&2
      return 1
    fi

    if read -r line < "$fifo_out"; then
      echo "$line"
      return 0
    else
      return 1
    fi
  ]

  # Read lines continuously, calling a handler for each
  # Usage: @ $coproc readLinesDo: '@ $obj handleLine'
  # The handler can access the current line via $__COPROC_LINE
  # (Using a global avoids quote escaping issues with JSON content)
  method: readLinesDo: handler [
    local fifo_out handler="$1"
    fifo_out="$(_ivar fifoOut)"

    if [[ -z "$fifo_out" ]] || [[ ! -p "$fifo_out" ]]; then
      echo "Error: Coproc not started or FIFO missing" >&2
      return 1
    fi

    # Read lines - store in global to avoid eval quoting issues
    while IFS= read -r __COPROC_LINE; do
      eval "$handler"
    done < "$fifo_out"
  ]

  # Write a line to the process stdin
  method: writeLine: text [
    local fifo_in text="$1"
    fifo_in="$(_ivar fifoIn)"

    if [[ -z "$fifo_in" ]] || [[ ! -p "$fifo_in" ]]; then
      echo "Error: Coproc not started in bidirectional mode" >&2
      return 1
    fi

    echo "$text" > "$fifo_in"
  ]

  # Check if the coprocess is still running
  method: isRunning [
    local proc_pid
    proc_pid="$(_ivar pid)"

    if [[ -z "$proc_pid" ]]; then
      echo "false"
      return 1
    fi

    if kill -0 "$proc_pid" 2>/dev/null; then
      echo "true"
      return 0
    else
      _ivar_set status "exited"
      echo "false"
      return 1
    fi
  ]

  # Terminate the coprocess (SIGTERM)
  method: terminate [
    local proc_pid
    proc_pid="$(_ivar pid)"

    if [[ -n "$proc_pid" ]]; then
      kill -TERM "$proc_pid" 2>/dev/null
      _ivar_set status "terminated"
    fi

    @ "$_RECEIVER" _cleanup
  ]

  # Kill the coprocess (SIGKILL)
  method: kill [
    local proc_pid
    proc_pid="$(_ivar pid)"

    if [[ -n "$proc_pid" ]]; then
      kill -KILL "$proc_pid" 2>/dev/null
      _ivar_set status "killed"
    fi

    @ "$_RECEIVER" _cleanup
  ]

  # Clean up FIFOs
  method: _cleanup [
    local fifo_in fifo_out

    fifo_in="$(_ivar fifoIn)"
    fifo_out="$(_ivar fifoOut)"

    rm -f "$fifo_in" "$fifo_out" 2>/dev/null

    _ivar_set fifoIn ""
    _ivar_set fifoOut ""
  ]

  # Private setters
  method: _setCommand: cmd [
    _ivar_set command "$1"
  ]

  method: _setStatus: s [
    _ivar_set status "$1"
  ]

