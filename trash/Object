# Object - Base class for all Trashtalk objects
# This is the root class - no superclass
# Provides persistence methods inherited by all subclasses

# ============================================
# Class Methods (when receiver is a class name)
# ============================================

# Find all instances of this class
# Usage: @ Counter findAll
# Usage: @ $counter findAll  (uses instance's class)
findAll() {
    db_find_by_class "$_CLASS"
}

# Find instances matching a predicate
# Usage: @ Counter find 'value > 5'
# Usage: @ $counter find 'value > 5'  (uses instance's class)
# Predicate format: "field OP value" e.g. "value > 5", "count = 10"
find() {
    local predicate="$1"

    if [[ -z "$predicate" ]]; then
        # No predicate - return all
        db_find_by_class "$_CLASS"
        return 0
    fi

    # Parse predicate: "field OP number" format
    local escaped_class
    escaped_class=$(_db_escape "$_CLASS")

    if [[ "$predicate" =~ ^([a-zA-Z_][a-zA-Z0-9_]*)[[:space:]]*([<>=!]+)[[:space:]]*(.+)$ ]]; then
        local field="${BASH_REMATCH[1]}"
        local op="${BASH_REMATCH[2]}"
        local target="${BASH_REMATCH[3]}"

        # Normalize operator
        [[ "$op" == "==" ]] && op="="
        [[ "$op" == "!=" ]] && op="<>"

        # Build SQL WHERE clause
        local where_clause="class = '$escaped_class' AND json_extract(data, '\$.$field') $op $target"
        db_query "$where_clause"
    else
        echo "Error: Invalid predicate format: $predicate" >&2
        echo "Expected: field OP value (e.g. 'value > 5')" >&2
        return 1
    fi
}

# Count instances of this class
# Usage: @ Counter count
# Usage: @ $counter count  (uses instance's class)
count() {
    db_count_by_class "$_CLASS"
}

# ============================================
# Instance Methods (when receiver is an instance ID)
# ============================================

# Explicitly save instance to database
# Note: Setters auto-save, but this provides explicit control
# Usage: @ $counter save
save() {
    local data
    data=$(db_get "$_RECEIVER")
    if [[ -n "$data" ]]; then
        db_put "$_RECEIVER" "$data"
    else
        echo "Error: Instance $_RECEIVER not found" >&2
        return 1
    fi
}

# Delete this instance from database
# Usage: @ $counter delete
delete() {
    db_delete "$_RECEIVER"
}

# Get the class of this instance
# Usage: @ $counter class
class() {
    _get_instance_class "$_RECEIVER"
}

# Get instance ID
# Usage: @ $counter id
id() {
    echo "$_RECEIVER"
}

# Get all data as JSON
# Usage: @ $counter asJson
asJson() {
    db_get "$_RECEIVER"
}

# Check if instance exists in database
# Usage: @ $counter exists
exists() {
    local data
    data=$(db_get "$_RECEIVER" 2>/dev/null)
    [[ -n "$data" ]]
}

# ============================================
# Protocol Conformance
# ============================================

# Check if this object/class conforms to a protocol
# Usage: @ myArray conformsTo: #Enumerable
# Usage: @ Array conformsTo: #Enumerable
conformsTo() {
    local protocol_name="$1"

    # Get the class - either the receiver directly (for class messages)
    # or the class of the instance
    local class_name
    if _is_instance "$_RECEIVER"; then
        class_name=$(_get_instance_class "$_RECEIVER")
    else
        class_name="$_RECEIVER"
    fi

    # Use the _conforms_to helper from trash.bash
    _conforms_to "$class_name" "$protocol_name"
}

# ============================================
# Development Methods
# ============================================

# Open the class definition in $EDITOR
# Usage: @ Counter edit       (opens trash/Counter)
# Usage: @ $counter edit      (opens the class file for this instance)
edit() {
    local class_name
    local class_file

    # Check if receiver is an instance or a class name
    if _is_instance "$_RECEIVER"; then
        class_name=$(_get_instance_class "$_RECEIVER")
    else
        class_name="$_RECEIVER"
    fi

    class_file="$TRASHDIR/$class_name"

    if [[ ! -f "$class_file" ]]; then
        echo "Error: Class file not found: $class_file" >&2
        return 1
    fi

    # Use $EDITOR, fall back to vi
    local editor="${EDITOR:-vi}"
    "$editor" "$class_file"
}
