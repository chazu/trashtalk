# Trash - The system object representing the entire trash system
# Provides introspection, management, and system-wide operations
Trash subclass: Object
  include: Debuggable

  # Get system information
  rawMethod: info [
    echo "=== Trash System Information ==="
    echo "Version: 0.1.0"
    echo "Directory: $TRASHDIR"
    echo "Objects: $(@ self listObjects | wc -l)"
    echo "Traits: $(@ self listTraits | wc -l)"
    echo "Active Processes: $(@ Process listProcesses | wc -l)"
    echo "Database: $SQLITE_JSON_DB"
  ]

  # List all available objects (compiled classes)
  rawMethod: listObjects [
    find "$TRASHDIR/.compiled" -maxdepth 1 -type f 2>/dev/null | while read -r file; do
      basename "$file"
    done | sort
  ]

  # List all available traits (compiled traits)
  rawMethod: listTraits [
    if [[ -d "$TRASHDIR/.compiled/traits" ]]; then
      find "$TRASHDIR/.compiled/traits" -type f 2>/dev/null | while read -r file; do
        basename "$file"
      done | sort
    fi
  ]

  # Get methods available on a class
  rawMethod: methodsFor: class_name [
    local compiled_file="$TRASHDIR/.compiled/$class_name"
    local runtime_file="$TRASHDIR/$class_name"

    # Check for compiled or runtime class file
    if [[ -f "$compiled_file" ]]; then
      source "$compiled_file"
    elif [[ -f "$runtime_file" ]]; then
      source "$runtime_file"
    else
      echo "Class $class_name not found"
      return 1
    fi

    echo "Methods for $class_name:"
    # List functions defined for this class
    declare -F | awk '{print $3}' | grep "^__${class_name}__" | grep -v "__class__" | sed "s/__${class_name}__/  /"

    # Show class methods
    echo "Class methods:"
    declare -F | awk '{print $3}' | grep "^__${class_name}__class__" | sed "s/__${class_name}__class__/  /"

    # Show trait methods
    local traits_var="__${class_name}__traits"
    local traits="${!traits_var:-}"
    if [[ -n "$traits" ]]; then
      for trait in $traits; do
        local trait_file="$TRASHDIR/.compiled/traits/$trait"
        if [[ -f "$trait_file" ]]; then
          source "$trait_file"
          echo ""
          echo "From trait $trait:"
          declare -F | awk '{print $3}' | grep "^__${trait}__" | grep -v "__class__" | sed "s/__${trait}__/  /"
          # Trait class methods
          local trait_class_methods
          trait_class_methods=$(declare -F | awk '{print $3}' | grep "^__${trait}__class__" | sed "s/__${trait}__class__/  /")
          if [[ -n "$trait_class_methods" ]]; then
            echo "  (class methods):"
            echo "$trait_class_methods" | sed 's/^/  /'
          fi
        fi
      done
    fi

    # Show inherited methods
    local super_var="__${class_name}__superclass"
    local superclass="${!super_var:-}"
    if [[ -n "$superclass" && "$superclass" != "nil" && "$superclass" != "Object" ]]; then
      echo ""
      echo "(inherited from $superclass)"
      @ "$_RECEIVER" methodsFor: "$superclass" | sed 's/^/  /'
    fi
  ]

  # Get methods in a specific category for a class
  rawMethod: methodsIn: class_name category: cat_name [
    # Get compiled class metadata
    local compiled_file="$TRASHDIR/.compiled/$class_name"
    if [[ ! -f "$compiled_file" ]]; then
      echo "Error: Class $class_name not found"
      return 1
    fi

    # Source the class to get metadata
    source "$compiled_file"

    # Get method categories metadata
    local cats_var="__${class_name}__methodCategories"
    local cats="${!cats_var:-}"

    if [[ -z "$cats" ]]; then
      echo "No categorized methods for $class_name"
      return 0
    fi

    # Parse and filter by category
    echo "Methods in '$cat_name' for $class_name:"
    for entry in $cats; do
      local method="${entry%%:*}"
      local category="${entry#*:}"
      if [[ "$category" == "$cat_name" ]]; then
        echo "  $method"
      fi
    done
  ]

  # List all categories for a class
  rawMethod: categoriesFor: class_name [
    # Get compiled class metadata
    local compiled_file="$TRASHDIR/.compiled/$class_name"
    if [[ ! -f "$compiled_file" ]]; then
      echo "Error: Class $class_name not found"
      return 1
    fi

    # Source the class to get metadata
    source "$compiled_file"

    # Get method categories metadata
    local cats_var="__${class_name}__methodCategories"
    local cats="${!cats_var:-}"

    if [[ -z "$cats" ]]; then
      echo "No categories for $class_name"
      return 0
    fi

    # Extract unique categories
    echo "Categories for $class_name:"
    local seen=""
    for entry in $cats; do
      local category="${entry#*:}"
      if [[ ! " $seen " =~ " $category " ]]; then
        echo "  $category"
        seen="$seen $category"
      fi
    done
  ]

  # Show inheritance hierarchy for a class
  rawMethod: hierarchyFor: class_name [
    local compiled_file="$TRASHDIR/.compiled/$class_name"
    local runtime_file="$TRASHDIR/$class_name"

    if [[ -f "$compiled_file" || -f "$runtime_file" ]]; then
      echo "Inheritance hierarchy for $class_name:"
      @ "$_RECEIVER" _showHierarchy: "$class_name" depth: 0
    else
      echo "Class $class_name not found"
      return 1
    fi
  ]

  # Helper for showing hierarchy (uses compiled metadata)
  rawMethod: _showHierarchy: class_name depth: depth [
    local indent="" i superclass super_var
    local compiled_file="$TRASHDIR/.compiled/$class_name"
    local runtime_file="$TRASHDIR/$class_name"

    for ((i=0; i<depth; i++)); do
      indent="  $indent"
    done
    echo "$indent$class_name"

    # Source class to get metadata
    if [[ -f "$compiled_file" ]]; then
      source "$compiled_file"
    elif [[ -f "$runtime_file" ]]; then
      source "$runtime_file"
    else
      return 0
    fi

    # Get superclass from metadata
    super_var="__${class_name}__superclass"
    superclass="${!super_var:-}"
    if [[ -n "$superclass" && "$superclass" != "nil" ]]; then
      @ "$_RECEIVER" _showHierarchy: "$superclass" depth: $((depth + 1))
    fi
  ]

  # Create a new class file with modern .trash syntax
  rawMethod: createObject: object_name super: superclass [
    local trash_file="$TRASHDIR/${object_name}.trash"
    superclass="${superclass:-Object}"

    if [[ -f "$trash_file" ]]; then
      echo "Class $object_name already exists"
      return 1
    fi

    cat > "$trash_file" << EOF
# $object_name - Created by Trash system
$object_name subclass: $superclass

  rawMethod: example [
    echo "Hello from $object_name"
  ]

  rawClassMethod: new [
    local id=\$(_generate_instance_id "$object_name")
    _create_instance "$object_name" "\$id"
    echo "\$id"
  ]
EOF

    echo "Created $trash_file (inherits from $superclass)"
    echo "Compiling..."
    "$SCRIPT_DIR/jq-compiler/driver.bash" compile "$trash_file" > "$TRASHDIR/.compiled/$object_name" 2>/dev/null
    source "$TRASHDIR/.compiled/$object_name"
    echo "✓ $object_name ready to use"
  ]

  # Remove an object (with confirmation)
  rawMethod: removeObject: object_name [
    local object_file confirmation
    object_file="$TRASHDIR/$object_name"
    if [[ ! -f "$object_file" ]]; then
      echo "Object $object_name not found"
      return 1
    fi
    echo "Are you sure you want to remove object $object_name? (y/N)"
    read -r confirmation
    if [[ "$confirmation" =~ ^[Yy]$ ]]; then
      rm "$object_file"
      echo "Removed object $object_name"
    else
      echo "Cancelled"
    fi
  ]

  # Reload all object stubs
  rawMethod: reload [
    echo "Reloading all object stubs..."
    initialize_trash
    echo "Reload complete"
  ]

  # Reload a single class (hot reload for development)
  rawMethod: reloadClass: class_name [
    pragma: direct
    if [[ -z "$class_name" ]]; then
      echo "Usage: @ Trash reloadClass <ClassName>"
      return 1
    fi

    local compiled_file="$TRASHDIR/.compiled/$class_name"
    local class_file="$TRASHDIR/$class_name"
    local trait_file="$TRASHDIR/traits/$class_name"
    local compiled_trait="$TRASHDIR/.compiled/traits/$class_name"

    # Clear the sourcing cache so the class will be re-sourced
    _clear_class_cache "$class_name"

    # Check if it's a trait
    if [[ -f "$compiled_trait" ]]; then
      echo "Reloading trait $class_name..."
      # Unset old trait functions
      while IFS= read -r func; do
        unset -f "$func" 2>/dev/null
      done < <(declare -F | awk '{print $3}' | grep "^__${class_name}__")
      # Source the compiled trait
      source "$compiled_trait"
      _mark_class_sourced "$class_name"
      echo "✓ Trait $class_name reloaded"
      return 0
    fi

    # Check for compiled class
    if [[ -f "$compiled_file" ]]; then
      echo "Reloading class $class_name..."
      # Unset old class functions
      while IFS= read -r func; do
        unset -f "$func" 2>/dev/null
      done < <(declare -F | awk '{print $3}' | grep "^__${class_name}__")
      # Source the compiled class
      source "$compiled_file"
      _mark_class_sourced "$class_name"
      echo "✓ Class $class_name reloaded"
      return 0
    fi

    # Fall back to raw .trash source file (uncompiled)
    if [[ -f "$class_file" ]]; then
      echo "Warning: Loading uncompiled source for $class_name..."
      source "$class_file"
      _mark_class_sourced "$class_name"
      echo "✓ Class $class_name loaded from source"
      return 0
    fi

    echo "Error: Class $class_name not found"
    echo "Searched:"
    echo "  - $compiled_file"
    echo "  - $compiled_trait"
    echo "  - $class_file"
    return 1
  ]

  # Compile and reload a class from .trash source
  # Safe: compiles to temp file first, validates, only replaces on success
  rawMethod: compileAndReload: class_name [
    pragma: direct
    if [[ -z "$class_name" ]]; then
      echo "Usage: @ Trash compileAndReload <ClassName>"
      return 1
    fi

    local source_file="$TRASHDIR/${class_name}.trash"
    local user_source="$TRASHDIR/user/${class_name}.trash"
    local trait_source="$TRASHDIR/traits/${class_name}.trash"
    local target_file=""
    local file_to_compile=""
    local temp_file="/tmp/trash_compile_$$_${class_name}"

    # Find source file and determine target (check user dir before system dir)
    if [[ -f "$user_source" ]]; then
      file_to_compile="$user_source"
      target_file="$TRASHDIR/.compiled/$class_name"
      echo "Compiling user class $class_name..."
    elif [[ -f "$trait_source" ]]; then
      file_to_compile="$trait_source"
      target_file="$TRASHDIR/.compiled/traits/$class_name"
      echo "Compiling trait $class_name..."
    elif [[ -f "$source_file" ]]; then
      file_to_compile="$source_file"
      target_file="$TRASHDIR/.compiled/$class_name"
      echo "Compiling class $class_name..."
    else
      echo "Error: No source file found for $class_name"
      echo "Searched:"
      echo "  - $user_source"
      echo "  - $source_file"
      echo "  - $trait_source"
      return 1
    fi

    # Compile to temp file
    if ! "$SCRIPT_DIR/jq-compiler/driver.bash" compile "$file_to_compile" > "$temp_file" 2>&1; then
      echo "Compilation failed:"
      cat "$temp_file"
      rm -f "$temp_file"
      return 1
    fi

    # Validate bash syntax
    if ! bash -n "$temp_file" 2>&1; then
      echo "Syntax validation failed - class not updated"
      rm -f "$temp_file"
      return 1
    fi

    # Success - replace the compiled file
    mv "$temp_file" "$target_file"
    @ "$_RECEIVER" reloadClass: "$class_name"
    return $?
  ]

  # Show system statistics
  rawMethod: stats [
    echo "=== Trash System Statistics ==="
    echo "Objects: $(@ self listObjects | wc -l)"
    echo "Traits: $(@ self listTraits | wc -l)"
    echo "KV entries: $(kvlist 2>/dev/null | wc -l)"
    echo "Active processes: $(@ Process listProcesses 2>/dev/null | wc -l)"
    echo "Memory usage: $(du -sh "$TRASHDIR" | cut -f1)"
    echo "KV store size: $(du -sh "$KV_USER_DIR" 2>/dev/null | cut -f1 || echo "0B")"
  ]

  # Clean up system
  rawMethod: cleanup [
    echo "Cleaning up trash system..."
    @ Process listProcesses >/dev/null 2>&1
    echo "Cleanup complete"
  ]

  # Show help
  rawMethod: help [
    echo "=== Trash System Commands ==="
    echo "@ Trash info                        - Show system information"
    echo "@ Trash listObjects                 - List all objects"
    echo "@ Trash listTraits                  - List all traits"
    echo "@ Trash methodsFor: <class>         - Show methods for class"
    echo "@ Trash hierarchyFor: <class>       - Show inheritance hierarchy"
    echo "@ Trash new: <class>                - Create class skeleton and edit"
    echo "@ Trash edit: <class>               - Edit class and recompile on save"
    echo "@ Trash createObject: <name> super: <super> - Create new object (no edit)"
    echo "@ Trash removeObject: <name>        - Remove object"
    echo "@ Trash reload                      - Reload all object stubs"
    echo "@ Trash reloadClass: <class>        - Hot reload a single class"
    echo "@ Trash compileAndReload: <class>   - Compile and reload from .trash"
    echo "@ Trash stats                       - Show system statistics"
    echo "@ Trash cleanup                     - Clean up system"
    echo "@ Trash version                     - Show version information"
    echo "@ Trash inspect: <class>            - Detailed object inspection"
    echo "@ Trash repl                        - Launch interactive REPL"
    echo ""
    echo "=== Instance Queries (use class methods) ==="
    echo "@ <Class> findAll                   - Find all instances of class"
    echo "@ <Class> find: '<predicate>'       - Find with predicate"
    echo "@ <Class> count                     - Count instances of class"
    echo "@ Store listClasses                 - List classes with instances"
    echo ""
    echo "=== Debugging ==="
    echo "@ Trash showStack                   - Show current call stack"
    echo "@ Trash clearStack                  - Clear call stack"
    echo ""
    echo "=== Source Introspection ==="
    echo "@ Trash sourceFor: <class>          - Get source code from .trash file"
    echo "@ Trash hashFor: <class>            - Get source hash (SHA-256)"
    echo ""
    echo "=== Testing ==="
    echo "@ Trash runTestsFor: <class>        - Run testMethod: tests for class"
    echo "@ Trash hasTestsFor: <class>        - Check if class has tests"
  ]

  # Show version information
  rawMethod: version [
    echo "Trash System v$TRASH_VERSION"
    echo "Author: $TRASH_AUTHOR"
    echo "Description: $TRASH_DESCRIPTION"
    echo "Bash version: $BASH_VERSION"
    echo "System: $(uname -s) $(uname -r)"
  ]

  # Get the source code for a class from .trash file
  # Usage: @ Trash sourceFor: Counter
  rawMethod: sourceFor: class_name [
    local source_file="$TRASHDIR/${class_name}.trash"
    local user_file="$TRASHDIR/user/${class_name}.trash"
    local trait_file="$TRASHDIR/traits/${class_name}.trash"

    if [[ -f "$user_file" ]]; then
      cat "$user_file"
    elif [[ -f "$source_file" ]]; then
      cat "$source_file"
    elif [[ -f "$trait_file" ]]; then
      cat "$trait_file"
    else
      echo "Error: Source file for $class_name not found"
      return 1
    fi
  ]

  # Get the source hash for a class
  # Usage: @ Trash hashFor: Counter
  rawMethod: hashFor: class_name [
    local hash_var="__${class_name}__sourceHash"
    local compiled_file="$TRASHDIR/.compiled/$class_name"

    # Try to get from already-loaded class
    if [[ -n "${!hash_var:-}" ]]; then
      echo "${!hash_var}"
      return 0
    fi

    # Try loading the compiled class
    if [[ -f "$compiled_file" ]]; then
      source "$compiled_file"
      if [[ -n "${!hash_var:-}" ]]; then
        echo "${!hash_var}"
        return 0
      fi
    fi

    echo "Error: Could not get hash for $class_name"
    return 1
  ]

  # Run tests for a class
  # Usage: @ Trash runTestsFor: Counter
  # Returns: 0 if all tests pass, 1 if any fail
  rawMethod: runTestsFor: class_name [
    local tests_var="__${class_name}__tests"
    local tests="${!tests_var:-}"
    local compiled_file="$TRASHDIR/.compiled/$class_name"

    # Ensure class is loaded
    if [[ ! -f "$compiled_file" ]]; then
      echo "Error: Class $class_name not found"
      return 1
    fi
    source "$compiled_file"

    # Check if class has tests
    tests="${!tests_var:-}"
    if [[ -z "$tests" ]]; then
      echo "# No tests defined for $class_name"
      return 0
    fi

    echo "# Running tests for $class_name"
    _test_reset
    local test_selector func_name
    local failed=0

    for test_selector in $tests; do
      func_name="__${class_name}__test__${test_selector}"
      if declare -f "$func_name" >/dev/null 2>&1; then
        # Capture output to temp file to check type while preserving counters
        local tmpfile="/tmp/trash_test_$$"
        "$func_name" > "$tmpfile" 2>&1
        local test_exit_code=$?
        local test_result
        test_result=$(cat "$tmpfile")
        rm -f "$tmpfile"

        # Determine test type by output:
        # - "true"/"false" = DSL testMethod
        # - Other = rawTestMethod (output already includes TAP from _assert_*)
        if [[ "$test_result" == "false" ]]; then
          # DSL testMethod returned false
          ((_TEST_COUNT++))
          ((_TEST_FAILURES++))
          echo "not ok $_TEST_COUNT - $test_selector"
          failed=1
        elif [[ "$test_result" == "true" ]]; then
          # DSL testMethod returned true
          ((_TEST_COUNT++))
          echo "ok $_TEST_COUNT - $test_selector"
        else
          # rawTestMethod - output already formatted, counters already updated
          echo "$test_result"
          if [[ $test_exit_code -ne 0 ]]; then
            failed=1
          fi
        fi
      else
        ((_TEST_COUNT++))
        ((_TEST_FAILURES++))
        echo "not ok $_TEST_COUNT - test function $func_name not found"
        failed=1
      fi
    done

    _test_summary
    return $failed
  ]

  # Check if a class has tests defined
  # Usage: @ Trash hasTestsFor: Counter
  rawMethod: hasTestsFor: class_name [
    local tests_var="__${class_name}__tests"
    local compiled_file="$TRASHDIR/.compiled/$class_name"

    # Ensure class is loaded
    if [[ -f "$compiled_file" ]]; then
      source "$compiled_file"
    fi

    local tests="${!tests_var:-}"
    if [[ -n "$tests" ]]; then
      echo "true"
      return 0
    else
      echo "false"
      return 1
    fi
  ]

  # Launch interactive REPL
  # Note: For rlwrap support (history, completions), run bin/trash directly
  rawClassMethod: repl [
    pragma: direct
    local trashtalk_root
    trashtalk_root="$(dirname "$TRASHDIR")"
    "$trashtalk_root/bin/trash-repl"
  ]

  # Detailed object inspection
  rawMethod: inspect: object_name [
    local object_file traits state
    if [[ -z "$object_name" ]]; then
      echo "Usage: @ Trash inspect <object_name>"
      return 1
    fi
    echo "=== Detailed Inspection: $object_name ==="
    object_file="$TRASHDIR/$object_name"
    if [[ ! -f "$object_file" ]]; then
      echo "Object $object_name not found"
      return 1
    fi
    echo "File: $object_file"
    echo "Size: $(wc -l < "$object_file") lines"
    echo "Modified: $(stat -f "%Sm" "$object_file" 2>/dev/null || stat -c "%y" "$object_file" 2>/dev/null)"
    echo ""
    @ self hierarchyFor: "$object_name"
    echo ""
    @ self methodsFor: "$object_name"
    echo ""
    traits=$(grep "^include" "$object_file" | awk '{print $2}')
    if [[ -n "$traits" ]]; then
      echo "Traits:"
      echo "$traits" | sed 's/^/  /'
    else
      echo "Traits: none"
    fi
  ]

  # Create a new class with minimal skeleton and open in editor
  # New classes are created in the user directory (trash/user/)
  rawMethod: new: class_name [
    pragma: direct
    local user_file="$TRASHDIR/user/${class_name}.trash"
    local system_file="$TRASHDIR/${class_name}.trash"
    local trait_file="$TRASHDIR/traits/${class_name}.trash"

    # Check if class already exists anywhere
    if [[ -f "$user_file" ]]; then
      echo "Class $class_name already exists in user/. Use '@ Trash edit: $class_name' to edit."
      return 1
    fi
    if [[ -f "$system_file" ]]; then
      echo "Class $class_name already exists as a system class. Use '@ Trash edit: $class_name' to edit."
      return 1
    fi
    if [[ -f "$trait_file" ]]; then
      echo "A trait named $class_name already exists. Use '@ Trash edit: $class_name' to edit."
      return 1
    fi

    # Ensure user directory exists
    mkdir -p "$TRASHDIR/user"

    # Create minimal skeleton with heredoc
    cat > "$user_file" <<EOF
${class_name} subclass: Object
  instanceVars:

  classMethod: new [
    | id |
    id := @ Runtime generateId: '${class_name}'.
    @ Runtime create: '${class_name}' id: id.
    ^ id
  ]

  method: example [
    ^ 'Hello from ${class_name}'
  ]

  rawTestMethod: testExample [
    local instance result
    instance=\$(@ ${class_name} new)
    result=\$(@ "\$instance" example)
    _assert_eq "\$result" 'Hello from ${class_name}' 'example returns greeting'
  ]
EOF

    echo "Created $user_file"

    # Open in editor (edit: handles compile on save)
    @ "$_RECEIVER" edit: "$class_name"
  ]

  # Edit an existing class and recompile on save
  # Enhanced: loops on errors, prepends error info, jumps to error line
  rawMethod: edit: class_name [
    pragma: direct
    local trash_file="$TRASHDIR/${class_name}.trash"
    local user_file="$TRASHDIR/user/${class_name}.trash"
    local trait_file="$TRASHDIR/traits/${class_name}.trash"
    local file_to_edit=""

    # Find the source file (check user dir before system dir)
    if [[ -f "$user_file" ]]; then
      file_to_edit="$user_file"
    elif [[ -f "$trash_file" ]]; then
      file_to_edit="$trash_file"
    elif [[ -f "$trait_file" ]]; then
      file_to_edit="$trait_file"
    else
      echo "Error: No source file found for $class_name"
      echo "Searched:"
      echo "  - $user_file"
      echo "  - $trash_file"
      echo "  - $trait_file"
      echo ""
      echo "Use '@ Trash new $class_name' to create a new class."
      return 1
    fi

    local error_marker="# ══════════════════════════════════════════════════════════════════════"
    local error_start="# ══ COMPILE ERRORS (fix and save to retry) ══"
    local temp_compiled="/tmp/trash_edit_compile_$$"
    local error_line=1
    local compile_errors=""
    local had_errors=false

    # Edit-compile loop
    while true; do
      local before_mtime after_mtime has_error_block=false

      # Check if file has error block (user will see it in editor)
      if grep -q "^$error_start" "$file_to_edit" 2>/dev/null; then
        has_error_block=true
      fi

      before_mtime=$(stat -f "%m" "$file_to_edit" 2>/dev/null || stat -c "%Y" "$file_to_edit" 2>/dev/null)

      # Build editor command with optional line jump
      local editor_cmd="${EDITOR:-vi}"
      local editor_base="${editor_cmd%% *}"  # Get base command without args
      local editor_args=""

      # Support line jumping for common editors
      if [[ $error_line -gt 1 ]]; then
        case "$editor_base" in
          vi|vim|nvim)
            editor_args="+$error_line"
            ;;
          emacs|emacsclient)
            editor_args="+$error_line"
            ;;
          code)
            editor_args="--goto ${file_to_edit}:${error_line}"
            file_to_edit=""  # code uses --goto with full path
            ;;
          "code-insiders")
            editor_args="--goto ${file_to_edit}:${error_line}"
            file_to_edit=""
            ;;
          nano)
            editor_args="+$error_line"
            ;;
          subl|sublime)
            editor_args="${file_to_edit}:${error_line}"
            file_to_edit=""
            ;;
        esac
      fi

      # Open editor
      if [[ -n "$file_to_edit" ]]; then
        $editor_cmd $editor_args "$file_to_edit" </dev/tty >/dev/tty
      else
        $editor_cmd $editor_args </dev/tty >/dev/tty
        # Restore file_to_edit for next iteration
        if [[ -f "$user_file" ]]; then
          file_to_edit="$user_file"
        elif [[ -f "$trash_file" ]]; then
          file_to_edit="$trash_file"
        else
          file_to_edit="$trait_file"
        fi
      fi

      after_mtime=$(stat -f "%m" "$file_to_edit" 2>/dev/null || stat -c "%Y" "$file_to_edit" 2>/dev/null)

      # Check if user made no changes (didn't even save)
      if [[ "$before_mtime" == "$after_mtime" ]]; then
        # Strip error block before exiting (clean up the file)
        if [[ "$has_error_block" == true ]]; then
          sed -i.bak "/^# ══ COMPILE ERRORS/,/^# ══════════════════════════════════════════════════════════════════════$/d" "$file_to_edit"
          rm -f "${file_to_edit}.bak"
        fi
        if [[ "$had_errors" == true ]]; then
          echo "No changes - aborting edit"
          return 1
        else
          echo "No changes detected"
          return 0
        fi
      fi

      # Strip any error comments before compiling
      if grep -q "^$error_start" "$file_to_edit" 2>/dev/null; then
        sed -i.bak "/^# ══ COMPILE ERRORS/,/^# ══════════════════════════════════════════════════════════════════════$/d" "$file_to_edit"
        rm -f "${file_to_edit}.bak"
      fi

      echo "File modified, compiling..."

      # Try to compile
      compile_errors=$("$SCRIPT_DIR/jq-compiler/driver.bash" compile "$file_to_edit" 2>&1)
      local compile_exit=$?

      if [[ $compile_exit -eq 0 ]]; then
        # Compilation succeeded, check bash syntax
        echo "$compile_errors" > "$temp_compiled"
        local syntax_errors
        syntax_errors=$(bash -n "$temp_compiled" 2>&1)
        local syntax_exit=$?

        if [[ $syntax_exit -eq 0 ]]; then
          # Success! Save compiled output and reload
          local target_file
          if [[ "$file_to_edit" == *"/traits/"* ]]; then
            target_file="$TRASHDIR/.compiled/traits/$class_name"
          else
            target_file="$TRASHDIR/.compiled/$class_name"
          fi
          mv "$temp_compiled" "$target_file"
          @ "$_RECEIVER" reloadClass: "$class_name"
          echo "Compiled successfully"

          # Check for and run tests
          local tests_var="__${class_name}__tests"
          local tests="${!tests_var:-}"
          if [[ -n "$tests" ]]; then
            echo ""
            echo "Running tests..."
            local test_output test_exit
            test_output=$(@ "$_RECEIVER" runTestsFor: "$class_name" 2>&1)
            test_exit=$?
            echo "$test_output"

            if [[ $test_exit -ne 0 ]]; then
              # Tests failed - loop back to edit
              compile_errors="Tests failed:

$test_output

Fix the failing tests and save to retry."
              had_errors=true
              error_line=1

              # Prepend error block
              local error_block
              error_block=$(cat <<EOF
$error_start
#
$(echo "$compile_errors" | sed 's/^/# /')
#
$error_marker

EOF
)
              local original_content
              original_content=$(cat "$file_to_edit")
              printf '%s\n%s' "$error_block" "$original_content" > "$file_to_edit"

              local block_lines
              block_lines=$(echo "$error_block" | wc -l | tr -d ' ')
              error_line=$((error_line + block_lines))

              echo ""
              echo "Tests failed - re-opening editor..."
              continue
            fi
          fi

          return 0
        else
          # Bash syntax error
          compile_errors="Bash syntax error in compiled output:
$syntax_errors

This usually indicates a DSL construct that compiled to invalid bash.
Check for unbalanced quotes, brackets, or unsupported syntax."

          # Try to extract line number from bash error (refers to compiled line)
          error_line=$(echo "$syntax_errors" | grep -oE 'line [0-9]+' | head -1 | grep -oE '[0-9]+' || echo "1")
          # Bash errors refer to compiled output, not source - reset to 1
          error_line=1
        fi
      else
        # Compilation failed - try to extract error line
        error_line=$(echo "$compile_errors" | grep -oE '^\s*[0-9]+:[0-9]+:' | head -1 | cut -d: -f1 | tr -d ' ' || echo "1")
        [[ -z "$error_line" ]] && error_line=1
      fi

      # Prepend errors to file for next edit iteration
      had_errors=true
      local error_block
      error_block=$(cat <<EOF
$error_start
#
$(echo "$compile_errors" | sed 's/^/# /')
#
$error_marker

EOF
)
      # Prepend error block
      local original_content
      original_content=$(cat "$file_to_edit")
      printf '%s\n%s' "$error_block" "$original_content" > "$file_to_edit"

      # Adjust error_line to account for prepended block
      local block_lines
      block_lines=$(echo "$error_block" | wc -l | tr -d ' ')
      error_line=$((error_line + block_lines))

      rm -f "$temp_compiled"
      echo "Compilation failed - re-opening editor with error details..."
    done
  ]

  # Evaluate a string of Trashtalk code
  # Usage: @ Trash eval: 'counter := @ Counter new. @ counter increment. @ counter getValue'
  # Returns the result of the last expression
  rawClassMethod: eval: code [
    local temp_class="_TempEval_$$_$RANDOM"
    local temp_file="/tmp/${temp_class}.trash"
    local compiled_file="/tmp/${temp_class}.compiled"
    local result

    # Wrap code in a temporary class with a run method
    cat > "$temp_file" << EVALEOF
${temp_class} subclass: Object
  rawClassMethod: run [
    $1
  ]
EVALEOF

    # Compile the temporary class
    if ! "$SCRIPT_DIR/jq-compiler/driver.bash" compile "$temp_file" > "$compiled_file" 2>&1; then
      echo "Eval compile error:" >&2
      cat "$compiled_file" >&2
      rm -f "$temp_file" "$compiled_file"
      return 1
    fi

    # Validate bash syntax
    if ! bash -n "$compiled_file" 2>&1; then
      echo "Eval syntax error" >&2
      rm -f "$temp_file" "$compiled_file"
      return 1
    fi

    # Source and execute
    source "$compiled_file"
    result=$("__${temp_class}__class__run")
    local exit_code=$?

    # Clean up
    rm -f "$temp_file" "$compiled_file"
    # Unset the temporary functions
    unset -f "__${temp_class}__class__run" 2>/dev/null
    unset "__${temp_class}__superclass" 2>/dev/null
    unset "__${temp_class}__is_a" 2>/dev/null

    echo "$result"
    return $exit_code
  ]

  # Evaluate code from a file
  # Usage: @ Trash evalFile: '/path/to/script.trash'
  rawClassMethod: evalFile: filepath [
    if [[ ! -f "$1" ]]; then
      echo "Error: File not found: $1" >&2
      return 1
    fi
    local code
    code=$(cat "$1")
    @ Trash eval: "$code"
  ]

  # Quick class creation with template
  rawMethod: quickCreate: class_name template: template [
    template="${template:-basic}"
    local trash_file="$TRASHDIR/${class_name}.trash"

    if [[ -f "$trash_file" ]]; then
      echo "Class $class_name already exists"
      return 1
    fi

    case "$template" in
      "service")
        cat > "$trash_file" << EOF
# $class_name - Service template
$class_name subclass: Object
  include: Debuggable

  rawMethod: start [
    @ self debug: "Starting service..."
    echo "Service started"
  ]

  rawMethod: stop [
    @ self debug: "Stopping service..."
    echo "Service stopped"
  ]

  rawMethod: status [
    echo "Service is running"
  ]

  rawMethod: restart [
    @ "\$_RECEIVER" stop
    @ "\$_RECEIVER" start
  ]

  rawClassMethod: new [
    local id=\$(_generate_instance_id "$class_name")
    _create_instance "$class_name" "\$id"
    echo "\$id"
  ]
EOF
        ;;
      "actor")
        cat > "$trash_file" << EOF
# $class_name - Actor template (for use with Process)
$class_name subclass: Object
  include: Debuggable
  instanceVars: status:active

  rawMethod: receive: message [
    @ self debug: "Received message: \$message"
    case "\$message" in
      "ping") echo "pong" ;;
      "status") echo "active" ;;
      *) echo "Unknown message: \$message" ;;
    esac
  ]

  rawMethod: initialize [
    @ self debug: "Actor initialized"
  ]

  rawClassMethod: new [
    local id=\$(_generate_instance_id "$class_name")
    _create_instance "$class_name" "\$id"
    echo "\$id"
  ]
EOF
        ;;
      *)
        # Basic template
        cat > "$trash_file" << EOF
# $class_name - Created by Trash system
$class_name subclass: Object

  rawMethod: example [
    echo "Hello from $class_name"
  ]

  rawClassMethod: new [
    local id=\$(_generate_instance_id "$class_name")
    _create_instance "$class_name" "\$id"
    echo "\$id"
  ]
EOF
        ;;
    esac

    echo "Created $trash_file using $template template"
    echo "Compiling..."
    mkdir -p "$TRASHDIR/.compiled"
    "$SCRIPT_DIR/jq-compiler/driver.bash" compile "$trash_file" > "$TRASHDIR/.compiled/$class_name" 2>/dev/null
    source "$TRASHDIR/.compiled/$class_name"
    echo "✓ $class_name ready to use"
  ]
