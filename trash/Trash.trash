# Trash - The system object representing the entire trash system
# Provides introspection, management, and system-wide operations
Trash subclass: Object
  include: Debuggable

  # Get system information
  method: info [
    echo "=== Trash System Information ==="
    echo "Version: 0.1.0"
    echo "Directory: $TRASHDIR"
    echo "Objects: $(@ self listObjects | wc -l)"
    echo "Traits: $(@ self listTraits | wc -l)"
    echo "Active Processes: $(@ Process listProcesses | wc -l)"
    echo "KV Store: $KV_USER_DIR"
  ]

  # List all available objects
  method: listObjects [
    find "$TRASHDIR" -maxdepth 1 -type f ! -path "*/traits/*" | while read -r file; do
      basename "$file"
    done | grep -v '\.trash$' | grep -v '\.legacy$' | sort
  ]

  # List all available traits
  method: listTraits [
    if [[ -d "$TRASHDIR/traits" ]]; then
      find "$TRASHDIR/traits" -type f | while read -r file; do
        basename "$file"
      done | sort
    fi
  ]

  # Get methods available on a class
  rawMethod: methodsFor: class_name [
    local compiled_file="$TRASHDIR/.compiled/$class_name"
    local runtime_file="$TRASHDIR/$class_name"

    # Check for compiled or runtime class file
    if [[ -f "$compiled_file" ]]; then
      source "$compiled_file"
    elif [[ -f "$runtime_file" ]]; then
      source "$runtime_file"
    else
      echo "Class $class_name not found"
      return 1
    fi

    echo "Methods for $class_name:"
    # List functions defined for this class
    declare -F | awk '{print $3}' | grep "^__${class_name}__" | grep -v "__class__" | sed "s/__${class_name}__/  /"

    # Show class methods
    echo "Class methods:"
    declare -F | awk '{print $3}' | grep "^__${class_name}__class__" | sed "s/__${class_name}__class__/  /"

    # Show inherited methods
    local super_var="__${class_name}__superclass"
    local superclass="${!super_var:-}"
    if [[ -n "$superclass" && "$superclass" != "nil" && "$superclass" != "Object" ]]; then
      echo ""
      echo "(inherited from $superclass)"
      @ "$_RECEIVER" methodsFor: "$superclass" | sed 's/^/  /'
    fi
  ]

  # Get methods in a specific category for a class
  rawMethod: methodsIn: class_name category: cat_name [
    # Get compiled class metadata
    local compiled_file="$TRASHDIR/.compiled/$class_name"
    if [[ ! -f "$compiled_file" ]]; then
      echo "Error: Class $class_name not found"
      return 1
    fi

    # Source the class to get metadata
    source "$compiled_file"

    # Get method categories metadata
    local cats_var="__${class_name}__methodCategories"
    local cats="${!cats_var:-}"

    if [[ -z "$cats" ]]; then
      echo "No categorized methods for $class_name"
      return 0
    fi

    # Parse and filter by category
    echo "Methods in '$cat_name' for $class_name:"
    for entry in $cats; do
      local method="${entry%%:*}"
      local category="${entry#*:}"
      if [[ "$category" == "$cat_name" ]]; then
        echo "  $method"
      fi
    done
  ]

  # List all categories for a class
  rawMethod: categoriesFor: class_name [
    # Get compiled class metadata
    local compiled_file="$TRASHDIR/.compiled/$class_name"
    if [[ ! -f "$compiled_file" ]]; then
      echo "Error: Class $class_name not found"
      return 1
    fi

    # Source the class to get metadata
    source "$compiled_file"

    # Get method categories metadata
    local cats_var="__${class_name}__methodCategories"
    local cats="${!cats_var:-}"

    if [[ -z "$cats" ]]; then
      echo "No categories for $class_name"
      return 0
    fi

    # Extract unique categories
    echo "Categories for $class_name:"
    local seen=""
    for entry in $cats; do
      local category="${entry#*:}"
      if [[ ! " $seen " =~ " $category " ]]; then
        echo "  $category"
        seen="$seen $category"
      fi
    done
  ]

  # Show inheritance hierarchy for a class
  rawMethod: hierarchyFor: class_name [
    local compiled_file="$TRASHDIR/.compiled/$class_name"
    local runtime_file="$TRASHDIR/$class_name"

    if [[ -f "$compiled_file" || -f "$runtime_file" ]]; then
      echo "Inheritance hierarchy for $class_name:"
      @ "$_RECEIVER" _showHierarchy: "$class_name" depth: 0
    else
      echo "Class $class_name not found"
      return 1
    fi
  ]

  # Helper for showing hierarchy (uses compiled metadata)
  rawMethod: _showHierarchy: class_name depth: depth [
    local indent="" i superclass super_var
    local compiled_file="$TRASHDIR/.compiled/$class_name"
    local runtime_file="$TRASHDIR/$class_name"

    for ((i=0; i<depth; i++)); do
      indent="  $indent"
    done
    echo "$indent$class_name"

    # Source class to get metadata
    if [[ -f "$compiled_file" ]]; then
      source "$compiled_file"
    elif [[ -f "$runtime_file" ]]; then
      source "$runtime_file"
    else
      return 0
    fi

    # Get superclass from metadata
    super_var="__${class_name}__superclass"
    superclass="${!super_var:-}"
    if [[ -n "$superclass" && "$superclass" != "nil" ]]; then
      @ "$_RECEIVER" _showHierarchy: "$superclass" depth: $((depth + 1))
    fi
  ]

  # Create a new class file with modern .trash syntax
  rawMethod: createObject: object_name super: superclass [
    local trash_file="$TRASHDIR/${object_name}.trash"
    superclass="${superclass:-Object}"

    if [[ -f "$trash_file" ]]; then
      echo "Class $object_name already exists"
      return 1
    fi

    cat > "$trash_file" << EOF
# $object_name - Created by Trash system
$object_name subclass: $superclass

  rawMethod: example [
    echo "Hello from $object_name"
  ]

  rawClassMethod: new [
    local id=\$(_generate_instance_id "$object_name")
    _create_instance "$object_name" "\$id"
    echo "\$id"
  ]
EOF

    echo "Created $trash_file (inherits from $superclass)"
    echo "Compiling..."
    "$SCRIPT_DIR/lib/jq-compiler/driver.bash" compile "$trash_file" > "$TRASHDIR/.compiled/$object_name" 2>/dev/null
    cp "$TRASHDIR/.compiled/$object_name" "$TRASHDIR/$object_name"
    source "$TRASHDIR/.compiled/$object_name"
    echo "✓ $object_name ready to use"
  ]

  # Remove an object (with confirmation)
  method: removeObject: object_name [
    | object_file confirmation |
    object_file := "$TRASHDIR/$object_name"
    if [[ ! -f "$object_file" ]]; then
      echo "Object $object_name not found"
      return 1
    fi
    echo "Are you sure you want to remove object $object_name? (y/N)"
    read -r confirmation
    if [[ "$confirmation" =~ ^[Yy]$ ]]; then
      rm "$object_file"
      echo "Removed object $object_name"
      kvdel "$object_name" 2>/dev/null || true
    else
      echo "Cancelled"
    fi
  ]

  # Reload all object stubs
  method: reload [
    echo "Reloading all object stubs..."
    initialize_trash
    echo "Reload complete"
  ]

  # Reload a single class (hot reload for development)
  rawMethod: reloadClass: class_name [
    if [[ -z "$class_name" ]]; then
      echo "Usage: @ Trash reloadClass <ClassName>"
      return 1
    fi

    local compiled_file="$TRASHDIR/.compiled/$class_name"
    local class_file="$TRASHDIR/$class_name"
    local trait_file="$TRASHDIR/traits/$class_name"
    local compiled_trait="$TRASHDIR/.compiled/traits/$class_name"

    # Check if it's a trait
    if [[ -f "$compiled_trait" ]]; then
      echo "Reloading trait $class_name..."
      # Unset old trait functions
      while IFS= read -r func; do
        unset -f "$func" 2>/dev/null
      done < <(declare -F | awk '{print $3}' | grep "^__${class_name}__")
      # Source the compiled trait
      source "$compiled_trait"
      cp "$compiled_trait" "$trait_file"
      echo "✓ Trait $class_name reloaded"
      return 0
    fi

    # Check for compiled class
    if [[ -f "$compiled_file" ]]; then
      echo "Reloading class $class_name..."
      # Unset old class functions
      while IFS= read -r func; do
        unset -f "$func" 2>/dev/null
      done < <(declare -F | awk '{print $3}' | grep "^__${class_name}__")
      # Source the compiled class
      source "$compiled_file"
      cp "$compiled_file" "$class_file"
      echo "✓ Class $class_name reloaded"
      return 0
    fi

    # Fall back to legacy class file
    if [[ -f "$class_file" ]]; then
      echo "Reloading legacy class $class_name..."
      source "$class_file"
      echo "✓ Legacy class $class_name reloaded"
      return 0
    fi

    echo "Error: Class $class_name not found"
    echo "Searched:"
    echo "  - $compiled_file"
    echo "  - $compiled_trait"
    echo "  - $class_file"
    return 1
  ]

  # Compile and reload a class from .trash source
  # Safe: compiles to temp file first, validates, only replaces on success
  rawMethod: compileAndReload: class_name [
    if [[ -z "$class_name" ]]; then
      echo "Usage: @ Trash compileAndReload <ClassName>"
      return 1
    fi

    local source_file="$TRASHDIR/${class_name}.trash"
    local trait_source="$TRASHDIR/traits/${class_name}.trash"
    local target_file=""
    local file_to_compile=""
    local temp_file="/tmp/trash_compile_$$_${class_name}"

    # Find source file and determine target
    if [[ -f "$trait_source" ]]; then
      file_to_compile="$trait_source"
      target_file="$TRASHDIR/.compiled/traits/$class_name"
      echo "Compiling trait $class_name..."
    elif [[ -f "$source_file" ]]; then
      file_to_compile="$source_file"
      target_file="$TRASHDIR/.compiled/$class_name"
      echo "Compiling class $class_name..."
    else
      echo "Error: No source file found for $class_name"
      echo "Searched:"
      echo "  - $source_file"
      echo "  - $trait_source"
      return 1
    fi

    # Compile to temp file
    if ! "$SCRIPT_DIR/lib/jq-compiler/driver.bash" compile "$file_to_compile" > "$temp_file" 2>&1; then
      echo "Compilation failed:"
      cat "$temp_file"
      rm -f "$temp_file"
      return 1
    fi

    # Validate bash syntax
    if ! bash -n "$temp_file" 2>&1; then
      echo "Syntax validation failed - class not updated"
      rm -f "$temp_file"
      return 1
    fi

    # Success - replace the compiled file
    mv "$temp_file" "$target_file"
    @ "$_RECEIVER" reloadClass "$class_name"
    return $?
  ]

  # Show system statistics
  method: stats [
    echo "=== Trash System Statistics ==="
    echo "Objects: $(@ self listObjects | wc -l)"
    echo "Traits: $(@ self listTraits | wc -l)"
    echo "KV entries: $(kvlist 2>/dev/null | wc -l)"
    echo "Active processes: $(@ Process listProcesses 2>/dev/null | wc -l)"
    echo "Memory usage: $(du -sh "$TRASHDIR" | cut -f1)"
    echo "KV store size: $(du -sh "$KV_USER_DIR" 2>/dev/null | cut -f1 || echo "0B")"
  ]

  # Clean up system
  method: cleanup [
    echo "Cleaning up trash system..."
    @ Process listProcesses >/dev/null 2>&1
    echo "Cleanup complete"
  ]

  # Find all instances of a class (delegates to Object)
  method: findAll: class_name [
    if [[ -z "$class_name" ]]; then
      echo "Usage: @ Trash findAll <ClassName>"
      return 1
    fi
    @ "$class_name" findAll
  ]

  # Find instances matching a predicate (delegates to Object)
  # Keyword syntax: @ Trash find: Counter where: 'value > 5'
  method: find: class_name where: predicate [
    if [[ -z "$class_name" ]]; then
      echo "Usage: @ Trash find <ClassName> [predicate]"
      return 1
    fi
    @ "$class_name" find "$predicate"
  ]

  # Simple syntax wrapper: @ Trash find Counter 'value > 5'
  rawClassMethod: find [
    local class_name="$1"
    local predicate="$2"
    if [[ -z "$class_name" ]]; then
      echo "Usage: @ Trash find <ClassName> [predicate]"
      return 1
    fi
    @ "$class_name" find "$predicate"
  ]

  # Count instances of a class
  method: countInstances: class_name [
    if [[ -z "$class_name" ]]; then
      echo "Usage: @ Trash countInstances <ClassName>"
      return 1
    fi
    @ "$class_name" count
  ]

  # List all classes that have instances
  method: listInstanceTypes [
    db_list_classes
  ]

  # Show current call stack
  method: showStack [
    | stack count i frame_id frame_data receiver selector args |
    _ensure_stack
    stack := $(kvget _stack 2>/dev/null)
    if [[ -z "$stack" || "$stack" == "[]" ]]; then
      echo "Call stack is empty"
      return 0
    fi
    count := $(echo "$stack" | jq 'length')
    echo "=== Call Stack ($count frames) ==="
    for ((i=count-1; i>=0; i--)); do
      frame_id := $(echo "$stack" | jq -r ".[$i]")
      frame_data := $(kvget "$frame_id" 2>/dev/null)
      if [[ -n "$frame_data" ]]; then
        receiver := $(echo "$frame_data" | jq -r '.args.receiver // "?"')
        selector := $(echo "$frame_data" | jq -r '.args.selector // "?"')
        args := $(echo "$frame_data" | jq -r '.args.args // ""')
        echo "  [$i] $receiver >> $selector $args"
      else
        echo "  [$i] $frame_id (frame data missing)"
      fi
    done
    echo ""
    echo "Enable stack frames with: export TRASH_STACK_FRAMES=1"
  ]

  # Clear the call stack
  method: clearStack [
    | stack frame_id |
    _ensure_stack
    stack := $(kvget _stack 2>/dev/null)
    if [[ -z "$stack" || "$stack" == "[]" ]]; then
      echo "Stack already empty"
      return 0
    fi
    echo "$stack" | jq -r '.[]' 2>/dev/null | while read -r frame_id; do
      if [[ -n "$frame_id" ]]; then
        kvdel "$frame_id" 2>/dev/null
      fi
    done
    kvset _stack "[]"
    echo "Stack cleared"
  ]

  # Get stack depth
  method: stackDepth [
    | stack |
    _ensure_stack
    stack := $(kvget _stack 2>/dev/null)
    if [[ -z "$stack" ]]; then
      echo "0"
    else
      echo "$stack" | jq 'length'
    fi
  ]

  # Show help
  method: help [
    echo "=== Trash System Commands ==="
    echo "@ Trash info                    - Show system information"
    echo "@ Trash listObjects             - List all objects"
    echo "@ Trash listTraits              - List all traits"
    echo "@ Trash methodsFor <object>     - Show methods for object"
    echo "@ Trash hierarchyFor <object>   - Show inheritance hierarchy"
    echo "@ Trash createObject <name> [super] - Create new object"
    echo "@ Trash removeObject <name>     - Remove object"
    echo "@ Trash reload                  - Reload all object stubs"
    echo "@ Trash reloadClass <class>     - Hot reload a single class"
    echo "@ Trash compileAndReload <class> - Compile and reload from .trash"
    echo "@ Trash edit <class>            - Edit class source in \$EDITOR"
    echo "@ Trash stats                   - Show system statistics"
    echo "@ Trash cleanup                 - Clean up system"
    echo "@ Trash version                 - Show version information"
    echo "@ Trash inspect <object>        - Detailed object inspection"
    echo ""
    echo "=== Instance Query Commands ==="
    echo "@ Trash findAll <Class>         - Find all instances"
    echo "@ Trash find <Class> [pred]     - Find with predicate"
    echo "@ Trash countInstances <Class>  - Count instances"
    echo "@ Trash listInstanceTypes       - List classes with instances"
    echo "@ Trash showStack               - Show current call stack"
    echo "@ Trash clearStack              - Clear call stack"
  ]

  # Show version information
  method: version [
    echo "Trash System v$TRASH_VERSION"
    echo "Author: $TRASH_AUTHOR"
    echo "Description: $TRASH_DESCRIPTION"
    echo "Bash version: $BASH_VERSION"
    echo "System: $(uname -s) $(uname -r)"
  ]

  # Detailed object inspection
  method: inspect: object_name [
    | object_file traits state |
    if [[ -z "$object_name" ]]; then
      echo "Usage: @ Trash inspect <object_name>"
      return 1
    fi
    echo "=== Detailed Inspection: $object_name ==="
    object_file := "$TRASHDIR/$object_name"
    if [[ ! -f "$object_file" ]]; then
      echo "Object $object_name not found"
      return 1
    fi
    echo "File: $object_file"
    echo "Size: $(wc -l < "$object_file") lines"
    echo "Modified: $(stat -f "%Sm" "$object_file" 2>/dev/null || stat -c "%y" "$object_file" 2>/dev/null)"
    echo ""
    @ self hierarchyFor: "$object_name"
    echo ""
    @ self methodsFor: "$object_name"
    echo ""
    traits := $(grep "^include" "$object_file" | awk '{print $2}')
    if [[ -n "$traits" ]]; then
      echo "Traits:"
      echo "$traits" | sed 's/^/  /'
    else
      echo "Traits: none"
    fi
    echo ""
    state := $(kvget "$object_name" 2>/dev/null)
    if [[ -n "$state" ]]; then
      echo "Persistent state:"
      echo "$state" | jq . 2>/dev/null || echo "$state"
    else
      echo "Persistent state: none"
    fi
  ]

  # Edit a class source file and recompile if changed
  rawMethod: edit: class_name [
    local source_file="$TRASHDIR/${class_name}.trash"
    local trait_source="$TRASHDIR/traits/${class_name}.trash"
    local file_to_edit=""
    local before_mtime

    # Find source file
    if [[ -f "$source_file" ]]; then
      file_to_edit="$source_file"
    elif [[ -f "$trait_source" ]]; then
      file_to_edit="$trait_source"
    else
      echo "Error: No source file found for $class_name"
      echo "Searched:"
      echo "  - $source_file"
      echo "  - $trait_source"
      return 1
    fi

    # Get modification time before editing
    before_mtime=$(stat -f "%m" "$file_to_edit" 2>/dev/null || stat -c "%Y" "$file_to_edit" 2>/dev/null)

    # Open in editor
    ${EDITOR:-vi} "$file_to_edit"

    # Get modification time after editing
    local after_mtime
    after_mtime=$(stat -f "%m" "$file_to_edit" 2>/dev/null || stat -c "%Y" "$file_to_edit" 2>/dev/null)

    # If file was modified, recompile
    if [[ "$before_mtime" != "$after_mtime" ]]; then
      echo "File modified, recompiling..."
      @ "$_RECEIVER" compileAndReload "$class_name"
    else
      echo "No changes detected"
    fi
  ]

  # Quick class creation with template
  rawMethod: quickCreate: class_name template: template [
    template="${template:-basic}"
    local trash_file="$TRASHDIR/${class_name}.trash"

    if [[ -f "$trash_file" ]]; then
      echo "Class $class_name already exists"
      return 1
    fi

    case "$template" in
      "service")
        cat > "$trash_file" << EOF
# $class_name - Service template
$class_name subclass: Object
  include: Debuggable

  rawMethod: start [
    @ self debug: "Starting service..."
    echo "Service started"
  ]

  rawMethod: stop [
    @ self debug: "Stopping service..."
    echo "Service stopped"
  ]

  rawMethod: status [
    echo "Service is running"
  ]

  rawMethod: restart [
    @ "\$_RECEIVER" stop
    @ "\$_RECEIVER" start
  ]

  rawClassMethod: new [
    local id=\$(_generate_instance_id "$class_name")
    _create_instance "$class_name" "\$id"
    echo "\$id"
  ]
EOF
        ;;
      "actor")
        cat > "$trash_file" << EOF
# $class_name - Actor template (for use with Process)
$class_name subclass: Object
  include: Debuggable
  instanceVars: status:active

  rawMethod: receive: message [
    @ self debug: "Received message: \$message"
    case "\$message" in
      "ping") echo "pong" ;;
      "status") echo "active" ;;
      *) echo "Unknown message: \$message" ;;
    esac
  ]

  rawMethod: initialize [
    @ self debug: "Actor initialized"
  ]

  rawClassMethod: new [
    local id=\$(_generate_instance_id "$class_name")
    _create_instance "$class_name" "\$id"
    echo "\$id"
  ]
EOF
        ;;
      *)
        # Basic template
        cat > "$trash_file" << EOF
# $class_name - Created by Trash system
$class_name subclass: Object

  rawMethod: example [
    echo "Hello from $class_name"
  ]

  rawClassMethod: new [
    local id=\$(_generate_instance_id "$class_name")
    _create_instance "$class_name" "\$id"
    echo "\$id"
  ]
EOF
        ;;
    esac

    echo "Created $trash_file using $template template"
    echo "Compiling..."
    mkdir -p "$TRASHDIR/.compiled"
    "$SCRIPT_DIR/lib/jq-compiler/driver.bash" compile "$trash_file" > "$TRASHDIR/.compiled/$class_name" 2>/dev/null
    cp "$TRASHDIR/.compiled/$class_name" "$TRASHDIR/$class_name"
    source "$TRASHDIR/.compiled/$class_name"
    echo "✓ $class_name ready to use"
  ]
