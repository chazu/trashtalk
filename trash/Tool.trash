# Tool - Abstract base class for wrapping external command-line tools
# Provides detection, installation, and execution of external programs
# Built on Shell primitives - no raw bash required.
#
# Tool subclasses are singletons - use class methods directly:
#   @ JqTool ensure
#   @ JqTool run: '.foo'
#
# Subclass example:
#   JqTool subclass: Tool
#     classMethod: name [ ^ "jq" ]
#     classMethod: installCommand [ ^ "brew install jq" ]
#
Tool subclass: Object
  pragma: primitiveClass

  # Override in subclasses to return the command name
  rawClassMethod: name [
    echo ""
  ]

  # Override in subclasses to return the install command
  # e.g., "brew install jq" or "apt-get install -y jq"
  rawClassMethod: installCommand [
    echo ""
  ]

  # Check if the tool is installed and on PATH
  rawClassMethod: isInstalled [
    local toolName checkCmd
    toolName=$(@ "$_RECEIVER" name)
    checkCmd="command -v ${toolName}"
    @ Shell succeeds: "$checkCmd"
  ]

  # Get the path to the tool executable
  rawClassMethod: path [
    local toolName checkCmd
    toolName=$(@ "$_RECEIVER" name)
    checkCmd="command -v ${toolName}"
    @ Shell exec: "$checkCmd"
  ]

  # Get the version of the tool (override for tool-specific parsing)
  rawClassMethod: version [
    local toolName toolPath versionCmd result
    toolName=$(@ "$_RECEIVER" name)
    toolPath=$(@ "$_RECEIVER" path)

    if [[ -z "$toolPath" ]]; then
      echo "not installed"
      return
    fi

    # Try --version first
    versionCmd="${toolPath} --version 2>/dev/null | head -1"
    result=$(@ Shell exec: "$versionCmd")
    if [[ -n "$result" ]]; then echo "$result"; return; fi

    # Try -version
    versionCmd="${toolPath} -version 2>/dev/null | head -1"
    result=$(@ Shell exec: "$versionCmd")
    if [[ -n "$result" ]]; then echo "$result"; return; fi

    # Try -V
    versionCmd="${toolPath} -V 2>/dev/null | head -1"
    result=$(@ Shell exec: "$versionCmd")
    if [[ -n "$result" ]]; then echo "$result"; return; fi

    echo "unknown"
  ]

  # Install the tool - override in subclasses for custom behavior
  rawClassMethod: install [
    local installCmd toolName
    installCmd=$(@ "$_RECEIVER" installCommand)
    toolName=$(@ "$_RECEIVER" name)

    if [[ -z "$installCmd" ]]; then
      _throw "InstallError" "No install command defined for $toolName"
      echo ""
      return
    fi

    @ Console print: "Installing $toolName..."

    if @ Shell succeeds: "$installCmd"; then
      @ Console print: "Successfully installed $toolName"
      echo "true"
    else
      _throw "InstallError" "Failed to install $toolName"
      echo ""
    fi
  ]

  # Ensure the tool is installed and available
  # - Checks if installed
  # - Installs if not
  # - Verifies it's on PATH after install
  # Returns: "true" on success, throws error on failure
  rawClassMethod: ensure [
    local toolName isInstalledVal
    toolName=$(@ "$_RECEIVER" name)

    if [[ -z "$toolName" ]]; then
      _throw "ToolError" "Tool name not set"
      echo ""
      return
    fi

    # Check if already installed
    isInstalledVal=$(@ "$_RECEIVER" isInstalled)
    if [[ "$isInstalledVal" == "true" ]]; then
      echo "true"
      return
    fi

    # Try to install
    @ Console error: "$toolName not found, attempting install..."
    @ "$_RECEIVER" install

    # Refresh command hash table
    @ Shell silent: "hash -r"

    # Verify installation succeeded
    isInstalledVal=$(@ "$_RECEIVER" isInstalled)
    if [[ "$isInstalledVal" == "true" ]]; then
      echo "true"
    else
      _throw "PathError" "$toolName installed but not found on PATH"
      echo ""
    fi
  ]

  # Run the tool with arguments (synchronous)
  rawClassMethod: run: args [
    local args="$1" toolName toolPath runCmd
    toolName=$(@ "$_RECEIVER" name)
    toolPath=$(@ "$_RECEIVER" path)

    if [[ -z "$toolPath" ]]; then
      _throw "ToolError" "$toolName is not installed"
      echo ""
      return
    fi

    runCmd="${toolPath} ${args}"
    @ Shell exec: "$runCmd"
  ]

  # Run the tool with arguments, capturing stdout and stderr
  rawClassMethod: runCapture: args [
    local args="$1" toolName toolPath runCmd
    toolName=$(@ "$_RECEIVER" name)
    toolPath=$(@ "$_RECEIVER" path)

    if [[ -z "$toolPath" ]]; then
      _throw "ToolError" "$toolName is not installed"
      echo ""
      return
    fi

    runCmd="${toolPath} ${args}"
    @ Shell execAll: "$runCmd"
  ]

  # Run the tool asynchronously, returning a Future
  rawClassMethod: runAsync: args [
    local args="$1" toolName toolPath futureCmd
    toolName=$(@ "$_RECEIVER" name)
    toolPath=$(@ "$_RECEIVER" path)

    if [[ -z "$toolPath" ]]; then
      _throw "ToolError" "$toolName is not installed"
      echo ""
      return
    fi

    futureCmd="${toolPath} ${args}"
    @ Future value: "$futureCmd"
  ]

  # Check if a command exists on the system (utility method)
  rawClassMethod: commandExists: commandName [
    local commandName="$1" checkCmd
    checkCmd="command -v ${commandName}"
    @ Shell succeeds: "$checkCmd"
  ]
