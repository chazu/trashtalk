# GrpcClient - Native gRPC client for Trashtalk
#
# This class provides gRPC support through the native Procyon plugin.
# Streaming methods (serverStream, clientStream, bidiStream) require the native plugin.
# Unary calls and configuration work in both Bash and native modes.
#
# Features:
#   - Unary RPC calls with JSON payloads
#   - Server streaming with block callbacks (native only)
#   - Client streaming with block producers (native only)
#   - Bidirectional streaming (native only)
#   - Server reflection for dynamic method discovery
#   - Proto file support for offline schemas
#
# Usage:
#   client := @ GrpcClient connectTo: 'localhost:50051'.
#   response := @ $client call: 'myservice.Echo/Say' with: '{"message":"hello"}'.
#
# With proto file (no reflection needed):
#   client := @ GrpcClient connectTo: 'localhost:50051' withProto: 'service.proto'.
#
# Server streaming (native only):
#   @ $client serverStream: 'myservice.Stream/Watch' with: '{}' handler: [:msg |
#     @ Console print: msg
#   ].
#
# To install the native plugin:
#   cd ~/.trashtalk && make plugins

GrpcClient subclass: Object
  instanceVars: address:'' useReflection:'yes' protoFile:'' poolConnections:'no' usePlaintext:'yes'

  # ==========================================================================
  # Class methods - Factory constructors
  # ==========================================================================

  rawClassMethod: connectTo: addr [
    local client
    client=$(@ GrpcClient new)
    @ "$client" _setAddress: "$1"
    echo "$client"
  ]

  rawClassMethod: connectTo: addr withProto: proto [
    local client
    client=$(@ GrpcClient connectTo: "$1")
    @ "$client" _setProtoFile: "$2"
    @ "$client" _setUseReflection: 'no'
    echo "$client"
  ]

  # ==========================================================================
  # Unary RPC - Works in both Bash (via grpcurl) and native
  # ==========================================================================

  # Make unary gRPC call with JSON payload
  # Bash: uses grpcurl subprocess
  # Native: uses direct gRPC client
  rawMethod: call: method with: jsonPayload [
    local addr method_name json result plaintext_flag
    method_name="$1"
    json="$2"
    addr="$(_ivar address)"
    # Build plaintext flag
    if [[ "$(_ivar usePlaintext)" == "yes" ]]; then
      plaintext_flag="-plaintext"
    else
      plaintext_flag=""
    fi
    # Use grpcurl for bash fallback
    result=$(grpcurl $plaintext_flag -d "$json" "$addr" "$method_name" 2>&1)
    echo "$result"
  ]

  # Make unary gRPC call without payload (empty JSON)
  rawMethod: call: method [
    @ "$_RECEIVER" call: "$1" with: '{}'
  ]

  # ==========================================================================
  # Server Streaming RPC - Native only (requires fast callbacks)
  # Bash fallback: no-op (streaming requires native support)
  # ==========================================================================

  rawMethod: serverStream: method with: payload handler: block [
    # Streaming not supported in bash mode - requires native plugin
    @ Console error: 'GrpcClient: serverStream requires native plugin'
  ]

  # ==========================================================================
  # Client Streaming RPC - Native only
  # ==========================================================================

  rawMethod: clientStream: method handler: block [
    # Streaming not supported in bash mode - requires native plugin
    @ Console error: 'GrpcClient: clientStream requires native plugin'
  ]

  # ==========================================================================
  # Bidirectional Streaming RPC - Native only
  # ==========================================================================

  rawMethod: bidiStream: method handler: block [
    # Streaming not supported in bash mode - requires native plugin
    @ Console error: 'GrpcClient: bidiStream requires native plugin'
  ]

  # ==========================================================================
  # Service Discovery (reflection mode)
  # ==========================================================================

  rawMethod: listServices [
    local addr plaintext_flag
    addr="$(_ivar address)"
    if [[ "$(_ivar usePlaintext)" == "yes" ]]; then
      plaintext_flag="-plaintext"
    else
      plaintext_flag=""
    fi
    grpcurl $plaintext_flag "$addr" list 2>&1
  ]

  rawMethod: listMethods: service [
    local addr plaintext_flag
    addr="$(_ivar address)"
    if [[ "$(_ivar usePlaintext)" == "yes" ]]; then
      plaintext_flag="-plaintext"
    else
      plaintext_flag=""
    fi
    grpcurl $plaintext_flag "$addr" list "$1" 2>&1
  ]

  rawMethod: describe: target [
    local addr plaintext_flag
    addr="$(_ivar address)"
    if [[ "$(_ivar usePlaintext)" == "yes" ]]; then
      plaintext_flag="-plaintext"
    else
      plaintext_flag=""
    fi
    grpcurl $plaintext_flag "$addr" describe "$1" 2>&1
  ]

  # ==========================================================================
  # Configuration methods
  # ==========================================================================

  rawMethod: enablePooling [
    _ivar_set poolConnections 'yes'
  ]

  rawMethod: disablePooling [
    _ivar_set poolConnections 'no'
  ]

  rawMethod: enableTLS [
    _ivar_set usePlaintext 'no'
  ]

  rawMethod: enablePlaintext [
    _ivar_set usePlaintext 'yes'
  ]

  rawMethod: address [
    echo "$(_ivar address)"
  ]

  rawMethod: isUsingReflection [
    echo "$(_ivar useReflection)"
  ]

  rawMethod: isPoolingEnabled [
    echo "$(_ivar poolConnections)"
  ]

  # ==========================================================================
  # Private setters (used by factory constructors)
  # ==========================================================================

  rawMethod: _setAddress: a [
    _ivar_set address "$1"
  ]

  rawMethod: _setProtoFile: p [
    _ivar_set protoFile "$1"
  ]

  rawMethod: _setUseReflection: r [
    _ivar_set useReflection "$1"
  ]

