# GrpcClient - gRPC client with dual Bash/Procyon implementation
#
# Bash implementation uses grpcurl for unary calls.
# Streaming methods are marked procyonOnly and require native Procyon runtime.
#
# Usage:
#   client := @ GrpcClient connectTo: 'localhost:50051'.
#   response := @ $client call: 'myservice.Echo' with: '{"message":"hello"}'.
#
# With proto file:
#   client := @ GrpcClient connectTo: 'localhost:50051' withProto: 'service.proto'.

# Note: Using string 'yes'/'no' instead of boolean true/false because
# the _ivar function uses jq's // operator which treats false as empty.
GrpcClient subclass: Object
  instanceVars: address:'' useReflection:'yes' protoFile:'' poolConnections:'no' usePlaintext:'yes'

  # ==========================================================================
  # Class methods - Factory constructors
  # ==========================================================================

  classMethod: connectTo: addr [
    | client |
    client := $(@ GrpcClient new).
    @ client _setAddress: addr.
    ^ client
  ]

  classMethod: connectTo: addr withProto: proto [
    | client |
    client := $(@ GrpcClient connectTo: addr).
    @ client _setProtoFile: proto.
    @ client _setUseReflection: 'no'.
    ^ client
  ]

  # ==========================================================================
  # Unary RPC - Works in both Bash and Procyon
  # procyonNative: Bash uses grpcurl, Procyon uses native gRPC
  # ==========================================================================

  method: call: method with: jsonPayload [
    pragma: primitive
    pragma: direct
    pragma: procyonNative
    local addr proto result plaintext_flag
    addr="$(_ivar address)"
    proto="$(_ivar protoFile)"

    # Build plaintext flag
    if [[ "$(_ivar usePlaintext)" == "yes" ]]; then
      plaintext_flag="-plaintext"
    else
      plaintext_flag=""
    fi

    # Call grpcurl
    if [[ -n "$proto" ]]; then
      result=$(grpcurl $plaintext_flag -d "$2" -proto "$proto" "$addr" "$1" 2>&1)
    else
      # Reflection mode (server must have reflection enabled)
      result=$(grpcurl $plaintext_flag -d "$2" "$addr" "$1" 2>&1)
    fi

    if [[ $? -eq 0 ]]; then
      echo "$result"
    else
      _throw "GrpcError" "$result"
      return 1
    fi
  ]

  # Unary call with empty payload
  method: call: method [
    pragma: primitive
    pragma: direct
    local addr proto result plaintext_flag
    addr="$(_ivar address)"
    proto="$(_ivar protoFile)"

    if [[ "$(_ivar usePlaintext)" == "yes" ]]; then
      plaintext_flag="-plaintext"
    else
      plaintext_flag=""
    fi

    if [[ -n "$proto" ]]; then
      result=$(grpcurl $plaintext_flag -d '{}' -proto "$proto" "$addr" "$1" 2>&1)
    else
      result=$(grpcurl $plaintext_flag -d '{}' "$addr" "$1" 2>&1)
    fi

    if [[ $? -eq 0 ]]; then
      echo "$result"
    else
      _throw "GrpcError" "$result"
      return 1
    fi
  ]

  # ==========================================================================
  # Server Streaming RPC - Procyon only
  # ==========================================================================

  method: serverStream: method with: payload handler: block [
    pragma: primitive
    pragma: procyonOnly
    echo "Server streaming requires native Procyon runtime"
  ]

  # ==========================================================================
  # Client Streaming RPC - Procyon only
  # ==========================================================================

  method: clientStream: method handler: block [
    pragma: primitive
    pragma: procyonOnly
    echo "Client streaming requires native Procyon runtime"
  ]

  # ==========================================================================
  # Bidirectional Streaming RPC - Procyon only
  # ==========================================================================

  method: bidiStream: method handler: block [
    pragma: primitive
    pragma: procyonOnly
    echo "Bidirectional streaming requires native Procyon runtime"
  ]

  # ==========================================================================
  # List available services (reflection mode)
  # ==========================================================================

  method: listServices [
    pragma: primitive
    pragma: direct
    pragma: procyonNative
    local addr result plaintext_flag
    addr="$(_ivar address)"

    if [[ "$(_ivar usePlaintext)" == "yes" ]]; then
      plaintext_flag="-plaintext"
    else
      plaintext_flag=""
    fi

    result=$(grpcurl $plaintext_flag "$addr" list 2>&1)
    if [[ $? -eq 0 ]]; then
      echo "$result"
    else
      _throw "GrpcError" "$result"
      return 1
    fi
  ]

  # List methods for a service
  method: listMethods: service [
    pragma: primitive
    pragma: direct
    local addr result plaintext_flag
    addr="$(_ivar address)"

    if [[ "$(_ivar usePlaintext)" == "yes" ]]; then
      plaintext_flag="-plaintext"
    else
      plaintext_flag=""
    fi

    result=$(grpcurl $plaintext_flag "$addr" list "$1" 2>&1)
    if [[ $? -eq 0 ]]; then
      echo "$result"
    else
      _throw "GrpcError" "$result"
      return 1
    fi
  ]

  # Describe a service or method
  method: describe: target [
    pragma: primitive
    pragma: direct
    local addr result plaintext_flag
    addr="$(_ivar address)"

    if [[ "$(_ivar usePlaintext)" == "yes" ]]; then
      plaintext_flag="-plaintext"
    else
      plaintext_flag=""
    fi

    result=$(grpcurl $plaintext_flag "$addr" describe "$1" 2>&1)
    if [[ $? -eq 0 ]]; then
      echo "$result"
    else
      _throw "GrpcError" "$result"
      return 1
    fi
  ]

  # ==========================================================================
  # Configuration methods
  # ==========================================================================

  method: enablePooling [
    poolConnections := 'yes'
  ]

  method: disablePooling [
    poolConnections := 'no'
  ]

  method: enableTLS [
    usePlaintext := 'no'
  ]

  method: enablePlaintext [
    usePlaintext := 'yes'
  ]

  method: address [
    ^ address
  ]

  method: isUsingReflection [
    ^ useReflection
  ]

  method: isPoolingEnabled [
    ^ poolConnections
  ]

  # ==========================================================================
  # Private setters
  # ==========================================================================

  method: _setAddress: a [
    address := a
  ]

  method: _setProtoFile: p [
    protoFile := p
  ]

  method: _setUseReflection: r [
    useReflection := r
  ]
