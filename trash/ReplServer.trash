# ReplServer - Socket-based REPL server for Emacs integration
# Provides SLIME-like interactive development for Trashtalk
#
# Usage:
#   server=$(@ ReplServer new)
#   @ $server socketPath: '/tmp/trashtalk-repl.sock'
#   @ $server start
#
# Protocol (line-based):
#   Request:  COMMAND:payload
#   Response: STATUS:result
#
# Commands:
#   EVAL:code        -> OK:result or ERROR:message
#   COMPLETE:prefix  -> COMPLETIONS:word1 word2 ...
#   INFO:target      -> INFO:details
#   METHODS:class    -> Methods listing
#   RELOAD:class     -> OK:Reloaded or ERROR:message
#   QUIT             -> OK:Goodbye

ReplServer subclass: Object
  include: Debuggable
  instanceVars: socketPath history serverPid

  rawClassMethod: new [
    local id
    id=$(_generate_instance_id ReplServer)
    _create_instance ReplServer "$id"
    # Set default values using the instance id
    local _RECEIVER="$id"
    _ivar_set socketPath "/tmp/trashtalk-repl.sock"
    _ivar_set history "[]"
    echo "$id"
  ]

  # Set the socket path
  method: socketPath: path [
    socketPath := path
  ]

  # Get the socket path
  method: socketPath [
    ^ socketPath
  ]

  # ========================================
  # Request Handling
  # ========================================

  # Main request dispatcher - called by the connection handler
  rawMethod: handleRequest: request [
    local command payload

    # Parse request: COMMAND:payload
    command="${request%%:*}"
    payload="${request#*:}"

    # Handle case where there's no colon (command only)
    if [[ "$command" == "$request" ]]; then
      payload=""
    fi

    @ "$_RECEIVER" debug: "Command: $command, Payload: $payload"

    case "$command" in
      EVAL)
        @ "$_RECEIVER" handleEval: "$payload"
        ;;
      COMPLETE)
        @ "$_RECEIVER" handleComplete: "$payload"
        ;;
      INFO)
        @ "$_RECEIVER" handleInfo: "$payload"
        ;;
      METHODS)
        @ "$_RECEIVER" handleMethods: "$payload"
        ;;
      RELOAD)
        @ "$_RECEIVER" handleReload: "$payload"
        ;;
      PING)
        echo "OK:PONG"
        ;;
      QUIT)
        echo "OK:Goodbye"
        ;;
      "")
        # Empty request, ignore
        ;;
      *)
        echo "ERROR:Unknown command: $command"
        ;;
    esac
  ]

  # ========================================
  # EVAL - Evaluate Trashtalk code
  # ========================================

  rawMethod: handleEval: code [
    local result exitCode decoded_code

    # Handle base64-encoded multiline code
    if [[ "${code:0:7}" == "BASE64:" ]]; then
      decoded_code=$(echo "${code:7}" | base64 -d 2>/dev/null)
      if [[ $? -ne 0 ]]; then
        echo "ERROR:Invalid base64 encoding"
        return
      fi
      code="$decoded_code"
    fi

    # Skip empty code
    if [[ -z "$code" ]]; then
      echo "OK:"
      return
    fi

    # Record in history
    @ "$_RECEIVER" addToHistory: "$code"

    # Evaluate the code
    result=$(@ Trash eval: "$code" 2>&1)
    exitCode=$?

    if [[ $exitCode -eq 0 ]]; then
      # Escape newlines in result for line-based protocol
      result=$(echo "$result" | tr '\n' '\x1f' | sed 's/\x1f$//')
      echo "OK:$result"
    else
      result=$(echo "$result" | tr '\n' '\x1f' | sed 's/\x1f$//')
      echo "ERROR:$result"
    fi
  ]

  # ========================================
  # COMPLETE - Tab completion
  # ========================================

  rawMethod: handleComplete: prefix [
    local completions=""

    # Get class names from compiled directory
    if [[ -d "$TRASHDIR/.compiled" ]]; then
      local classes
      classes=$(ls "$TRASHDIR/.compiled/" 2>/dev/null | grep -i "^$prefix" | head -20 | tr '\n' ' ')
      completions="$classes"
    fi

    # Add common method names if prefix looks like a method call
    if echo "$prefix" | grep -q '\.' || [[ "$prefix" =~ ^\$ ]]; then
      completions="$completions new findAll count getValue setValue delete save"
    fi

    # Add keywords
    if [[ -z "$prefix" ]] || [[ "method" =~ ^"$prefix" ]]; then
      completions="$completions method: classMethod: rawMethod:"
    fi

    echo "COMPLETIONS:$completions"
  ]

  # ========================================
  # INFO - Class/instance introspection
  # ========================================

  rawMethod: handleInfo: target [
    local result

    if [[ -z "$target" ]]; then
      echo "ERROR:No target specified"
      return
    fi

    # Check if it's an instance (lowercase with underscore)
    # Check if target looks like an instance ID (lowercase_uuid)
    if echo "$target" | grep -qE '^[a-z]+_[a-f0-9-]+$'; then
      result=$(@ "$_RECEIVER" _instanceInfo: "$target")
    else
      # It's a class name
      result=$(@ Trash methodsFor: "$target" 2>&1)
    fi

    # Escape newlines
    result=$(echo "$result" | tr '\n' '\x1f')
    echo "INFO:$result"
  ]

  rawMethod: _instanceInfo: instanceId [
    local data class

    # Try ephemeral storage first
    data=$(_env_get "$instanceId" 2>/dev/null)

    # Fall back to database
    if [[ -z "$data" ]]; then
      data=$(db_get "$instanceId" 2>/dev/null)
    fi

    if [[ -n "$data" ]]; then
      class=$(echo "$data" | jq -r '.class // "Unknown"')
      echo "Instance: $instanceId"
      echo "Class: $class"
      echo "Data:"
      echo "$data" | jq .
    else
      echo "Instance not found: $instanceId"
    fi
  ]

  # ========================================
  # METHODS - List methods for a class
  # ========================================

  rawMethod: handleMethods: className [
    local result

    if [[ -z "$className" ]]; then
      echo "ERROR:No class specified"
      return
    fi

    result=$(@ Trash methodsFor: "$className" 2>&1)
    result=$(echo "$result" | tr '\n' '\x1f')
    echo "METHODS:$result"
  ]

  # ========================================
  # RELOAD - Hot reload a class
  # ========================================

  rawMethod: handleReload: className [
    local result exitCode

    if [[ -z "$className" ]]; then
      echo "ERROR:No class specified"
      return
    fi

    result=$(@ Trash compileAndReload: "$className" 2>&1)
    exitCode=$?

    if [[ $exitCode -eq 0 ]]; then
      echo "OK:Reloaded $className"
    else
      result=$(echo "$result" | tr '\n' ' ')
      echo "ERROR:$result"
    fi
  ]

  # ========================================
  # History
  # ========================================

  rawMethod: addToHistory: code [
    # Simple history tracking (could be enhanced with jq)
    local current
    current=$(_ivar history)
    if [[ "$current" == "[]" ]] || [[ -z "$current" ]]; then
      _ivar_set history "[\"$code\"]"
    else
      # Append to history (limit to last 100)
      _ivar_set history "$(echo "$current" | jq --arg c "$code" '(. + [$c])[-100:]')"
    fi
  ]

  method: history [
    ^ history
  ]

  method: clearHistory [
    _ivar_set history "[]"
  ]

  # ========================================
  # Server Lifecycle
  # ========================================

  # Class method to create and start a server in one call
  rawClassMethod: start [
    local server
    server=$(@ ReplServer new)
    @ "$server" start
  ]

  # Start the REPL server - blocks and handles requests
  rawMethod: start [
    local socketPath cmd response
    socketPath=$(_ivar socketPath)

    # Clean up old socket
    rm -f "$socketPath"

    @ "$_RECEIVER" debug: "Starting REPL server on $socketPath"

    # Start nc listening on unix socket as a coprocess
    coproc NC { nc -lkU "$socketPath"; }

    # Save PID for stop method
    _ivar_set serverPid "$NC_PID"

    @ "$_RECEIVER" debug: "Server listening (PID: $NC_PID)"

    # Main loop: read from nc's stdout, dispatch, write to nc's stdin
    while read -r cmd <&${NC[0]}; do
      # Strip carriage return if present
      cmd="${cmd%$'\r'}"

      [[ -z "$cmd" ]] && continue

      @ "$_RECEIVER" debug: "Received: $cmd"

      # Dispatch and capture response
      response=$(@ "$_RECEIVER" handleRequest: "$cmd")

      # Send response back through nc
      echo "$response" >&${NC[1]}

      # Check for quit
      [[ "$cmd" == "QUIT" ]] && break
    done

    @ "$_RECEIVER" stop
  ]

  # Stop the server
  rawMethod: stop [
    local pid socketPath
    pid=$(_ivar serverPid)
    socketPath=$(_ivar socketPath)

    if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
      kill "$pid" 2>/dev/null
      @ "$_RECEIVER" debug: "Server stopped (PID: $pid)"
    fi

    rm -f "$socketPath"
    _ivar_set serverPid ""
  ]

  # Check if server is running
  rawMethod: isRunning [
    local pid
    pid=$(_ivar serverPid)
    [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null
  ]
