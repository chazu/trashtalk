# Process - External OS process management
# Provides an interface to spawn and manage POSIX processes
# Pure Trashtalk wrapper around Shell primitives
Process subclass: Object
  include: Debuggable
  instanceVars: command pid status exitCode stdout stderr startTime endTime

  # Create a new process wrapper for a command
  # Usage: proc=$(@ Process for: "curl -s https://example.com")
  classMethod: for: command [
    | id |
    id := @ Runtime generateId: "Process"
    @ Runtime create: "Process" id: id
    @ $id setCommand: command
    @ $id setStatus: "created"
    ^ id
  ]

  # Run the command in the foreground (blocking)
  # Captures stdout/stderr and exit code
  method: run [
    | cmd result exitCodeVal stdoutVal stderrVal |
    cmd := $(_ivar command)

    @ self debug: "Running command: $cmd"
    status := "running"
    startTime := $(@ Time now)

    # Use Shell execFull to capture stdout, stderr, and exit code
    result := $(@ Shell execFull: "$cmd")

    # Parse JSON result using jq
    stdoutVal := $(@ Tools::Jq get: "stdout" from: "$result")
    stderrVal := $(@ Tools::Jq get: "stderr" from: "$result")
    exitCodeVal := $(@ Tools::Jq get: "exitCode" from: "$result")

    exitCode := "$exitCodeVal"
    stdout := "$stdoutVal"
    stderr := "$stderrVal"
    endTime := $(@ Time now)
    status := "completed"

    ^ exitCodeVal
  ]

  # Start the command in the background (non-blocking)
  # Returns immediately, use wait or poll to check completion
  method: start [
    | cmd instance tmpStdout tmpStderr bgPid |
    cmd := $(_ivar command)
    instance := $(@ Runtime instance)

    tmpStdout := "/tmp/proc_${instance}_stdout"
    tmpStderr := "/tmp/proc_${instance}_stderr"

    @ self debug: "Starting background command: $cmd"
    status := "running"
    startTime := $(@ Time now)

    # Use Shell spawn with separate stdout/stderr files
    bgPid := $(@ Shell spawn: "$cmd" stdoutTo: "$tmpStdout" stderrTo: "$tmpStderr")
    pid := "$bgPid"

    ^ bgPid
  ]

  # Wait for a background process to complete
  method: wait [
    | instance tmpStdout tmpStderr stdoutVal stderrVal |

    (status ~= 'running') ifTrue: [
      @ self debug: "Process not running (status: $status)".
      ^ exitCode
    ].

    pid isEmpty ifTrue: [
      @ Console error: "Error: No PID - process was not started in background".
      ^ '1'
    ].

    @ self debug: "Waiting for PID $pid".

    # Poll until process completes
    [(@ Shell isAlive: pid) = 'true'] whileTrue: [
      @ Time sleep: '0.1'
    ].

    # Process completed - read captured output
    instance := @ Runtime instance.
    tmpStdout := "/tmp/proc_${instance}_stdout".
    tmpStderr := "/tmp/proc_${instance}_stderr".

    @ Time sleep: '0.05'.

    stdoutVal := @ File read: tmpStdout.
    stderrVal := @ File read: tmpStderr.
    @ File delete: tmpStdout.
    @ File delete: tmpStderr.

    stdout := stdoutVal.
    stderr := stderrVal.
    exitCode := '0'.
    endTime := @ Time now.
    status := 'completed'.

    ^ exitCode
  ]

  # Check if the process is still running
  method: isRunning [
    | alive |
    (status ~= 'running') ifTrue: [^ 'false'].
    alive := @ Shell isAlive: pid.
    (alive = 'true') ifTrue: [^ 'true'].
    # Process finished, update status
    @ self wait.
    ^ 'false'
  ]

  # Send a signal to the process
  method: signal: sig [
    pid isEmpty ifTrue: [
      @ Console error: "Error: No PID".
      ^ ''
    ].
    @ self debug: "Sending signal $sig to PID $pid".
    ^ @ Shell signal: sig to: pid
  ]

  # Terminate the process (SIGTERM)
  method: terminate [
    | procPid |
    procPid := $(_ivar pid)
    @ Shell terminate: "$procPid"
    status := "terminated"
  ]

  # Kill the process (SIGKILL)
  method: kill [
    | procPid |
    procPid := $(_ivar pid)
    @ Shell kill: "$procPid"
    status := "killed"
  ]

  # Get stdout from the process
  method: output [
    ^ $(_ivar stdout)
  ]

  # Get stderr from the process
  method: errors [
    ^ $(_ivar stderr)
  ]

  # Get exit code
  method: exitCode [
    ^ $(_ivar exitCode)
  ]

  # Check if process succeeded (exit code 0)
  method: succeeded [
    ^ exitCode = '0'
  ]

  # Get process info
  method: info [
    | duration |
    @ Console print: "Command: $command".
    @ Console print: "PID: $pid".
    @ Console print: "Status: $status".
    @ Console print: "Exit Code: $exitCode".
    @ Console print: "Started: $(@ Time formatISO: startTime)".
    endTime notEmpty ifTrue: [
      @ Console print: "Ended: $(@ Time formatISO: endTime)".
      duration := @ Time from: startTime to: endTime.
      @ Console print: "Duration: ${duration}s"
    ]
  ]

  # === Class methods for quick execution ===

  # Run a command and return stdout (blocking, simple)
  # Usage: output=$(@ Process exec: "ls -la")
  classMethod: exec: command [
    ^ @ Shell execAll: command
  ]

  # Run a command and return exit code only
  # Usage: @ Process run: "make test"
  classMethod: run: command [
    ^ @ Shell run: command
  ]

  # Run a command in background, return PID
  # Usage: pid=$(@ Process spawn: "long-running-task")
  classMethod: spawn: command [
    ^ @ Shell spawn: command
  ]

  # Wait for a PID to complete
  # Usage: @ Process waitPid: $pid
  classMethod: waitPid: pid [
    ^ @ Shell wait: pid
  ]

  # Check if a PID is running
  # Usage: @ Process isRunningPid: $pid
  classMethod: isRunningPid: pid [
    ^ @ Shell isAlive: pid
  ]

  # Kill a PID
  # Usage: @ Process killPid: $pid
  classMethod: killPid: pid [
    ^ @ Shell terminate: pid
  ]

  # Show help
  method: help [
    @ Console print: "=== Process Management ==="
    @ Console print: ""
    @ Console print: "Instance Methods (for managed processes):"
    @ Console print: "  proc=\$(@ Process for: \"command\")   - Create process wrapper"
    @ Console print: "  @ \$proc run                          - Run blocking, capture output"
    @ Console print: "  @ \$proc start                        - Run in background"
    @ Console print: "  @ \$proc wait                         - Wait for background completion"
    @ Console print: "  @ \$proc isRunning                    - Check if still running"
    @ Console print: "  @ \$proc terminate                    - Send SIGTERM"
    @ Console print: "  @ \$proc kill                         - Send SIGKILL"
    @ Console print: "  @ \$proc output                       - Get stdout"
    @ Console print: "  @ \$proc errors                       - Get stderr"
    @ Console print: "  @ \$proc exitCode                     - Get exit code"
    @ Console print: "  @ \$proc succeeded                    - Check if exit code is 0"
    @ Console print: "  @ \$proc info                         - Show process info"
  ]
