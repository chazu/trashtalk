# Process - External OS process management
# Provides an interface to spawn and manage POSIX processes
# Built on Shell primitives - no raw bash required.
Process subclass: Object
  include: Debuggable
  instanceVars: command pid status exitCode stdout stderr startTime endTime

  # Create a new process wrapper for a command
  # Usage: proc=$(@ Process for: "curl -s https://example.com")
  classMethod: for: command [
    | id |
    id := @ Runtime generateId: "Process"
    @ Runtime create: "Process" id: id
    @ $id setCommand: command
    @ $id setStatus: "created"
    ^ id
  ]

  # Run the command in the foreground (blocking)
  # Captures stdout/stderr and exit code
  method: run [
    | cmd result exitCodeVal stdoutVal stderrVal |
    cmd := $(_ivar command)

    @ self debug: "Running command: $cmd"
    status := "running"
    startTime := $(@ Time now)

    # Use Shell execFull to capture stdout, stderr, and exit code
    result := $(@ Shell execFull: "$cmd")

    # Parse JSON result using jq
    stdoutVal := $(@ Tools::Jq get: "stdout" from: "$result")
    stderrVal := $(@ Tools::Jq get: "stderr" from: "$result")
    exitCodeVal := $(@ Tools::Jq get: "exitCode" from: "$result")

    exitCode := "$exitCodeVal"
    stdout := "$stdoutVal"
    stderr := "$stderrVal"
    endTime := $(@ Time now)
    status := "completed"

    ^ exitCodeVal
  ]

  # Start the command in the background (non-blocking)
  # Returns immediately, use wait or poll to check completion
  method: start [
    | cmd instance tmpStdout tmpStderr bgPid |
    cmd := $(_ivar command)
    instance := $(@ Runtime instance)

    tmpStdout := "/tmp/proc_${instance}_stdout"
    tmpStderr := "/tmp/proc_${instance}_stderr"

    @ self debug: "Starting background command: $cmd"
    status := "running"
    startTime := $(@ Time now)

    # Use Shell spawn with separate stdout/stderr files
    bgPid := $(@ Shell spawn: "$cmd" stdoutTo: "$tmpStdout" stderrTo: "$tmpStderr")
    pid := "$bgPid"

    ^ bgPid
  ]

  # Wait for a background process to complete
  primitiveMethod: wait [
    local procPid procStatus instance tmpStdout tmpStderr exitCodeVal stdoutVal stderrVal
    procPid=$(_ivar pid)
    procStatus=$(_ivar status)

    if [[ "$procStatus" != "running" ]]; then
      @ "$_RECEIVER" debug: "Process not running (status: $procStatus)"
      echo "$(_ivar exitCode)"
      return
    fi

    if [[ -z "$procPid" ]]; then
      @ Console error: "Error: No PID - process was not started in background"
      echo "1"
      return
    fi

    @ "$_RECEIVER" debug: "Waiting for PID $procPid"

    # Poll until process completes
    while @ Shell isAlive: "$procPid" | grep -q "true"; do
      @ Time sleep: "0.1"
    done

    # Process completed - read captured output
    instance=$(@ Runtime instance)
    tmpStdout="/tmp/proc_${instance}_stdout"
    tmpStderr="/tmp/proc_${instance}_stderr"

    # Wait a moment for files to be flushed
    @ Time sleep: "0.05"

    stdoutVal=$(@ File read: "$tmpStdout")
    stderrVal=$(@ File read: "$tmpStderr")
    @ File delete: "$tmpStdout"
    @ File delete: "$tmpStderr"

    _ivar_set stdout "$stdoutVal"
    _ivar_set stderr "$stderrVal"

    # Without wait syscall, we can't get exact exit code
    exitCodeVal="0"
    _ivar_set exitCode "$exitCodeVal"
    _ivar_set endTime "$(@ Time now)"
    _ivar_set status "completed"

    echo "$exitCodeVal"
  ]

  # Check if the process is still running
  primitiveMethod: isRunning [
    local procPid procStatus isAlive
    procPid=$(_ivar pid)
    procStatus=$(_ivar status)

    if [[ "$procStatus" != "running" ]]; then
      echo "false"
      return
    fi

    isAlive=$(@ Shell isAlive: "$procPid")
    if [[ "$isAlive" == "true" ]]; then
      echo "true"
      return
    fi

    # Process finished, update status
    @ "$_RECEIVER" wait
    echo "false"
  ]

  # Send a signal to the process
  primitiveMethod: signal: sig [
    local procPid="$1"
    procPid=$(_ivar pid)

    if [[ -z "$procPid" ]]; then
      @ Console error: "Error: No PID"
      echo ""
      return
    fi

    @ "$_RECEIVER" debug: "Sending signal $1 to PID $procPid"
    @ Shell signal: "$1" to: "$procPid"
  ]

  # Terminate the process (SIGTERM)
  method: terminate [
    | procPid |
    procPid := $(_ivar pid)
    @ Shell terminate: "$procPid"
    status := "terminated"
  ]

  # Kill the process (SIGKILL)
  method: kill [
    | procPid |
    procPid := $(_ivar pid)
    @ Shell kill: "$procPid"
    status := "killed"
  ]

  # Get stdout from the process
  method: output [
    ^ $(_ivar stdout)
  ]

  # Get stderr from the process
  method: errors [
    ^ $(_ivar stderr)
  ]

  # Get exit code
  method: exitCode [
    ^ $(_ivar exitCode)
  ]

  # Check if process succeeded (exit code 0)
  primitiveMethod: succeeded [
    local code
    code=$(_ivar exitCode)
    if [[ "$code" == "0" ]]; then
      echo "true"
    else
      echo "false"
    fi
  ]

  # Get process info
  primitiveMethod: info [
    local start endTimeVal duration
    @ Console print: "Command: $(_ivar command)"
    @ Console print: "PID: $(_ivar pid)"
    @ Console print: "Status: $(_ivar status)"
    @ Console print: "Exit Code: $(_ivar exitCode)"
    start=$(_ivar startTime)
    @ Console print: "Started: $(@ Time formatISO: "$start")"
    endTimeVal=$(_ivar endTime)
    if [[ -n "$endTimeVal" ]]; then
      @ Console print: "Ended: $(@ Time formatISO: "$endTimeVal")"
      duration=$(@ Time from: "$start" to: "$endTimeVal")
      @ Console print: "Duration: ${duration}s"
    fi
  ]

  # === Class methods for quick execution ===

  # Run a command and return stdout (blocking, simple)
  # Usage: output=$(@ Process exec: "ls -la")
  classMethod: exec: command [
    ^ @ Shell execAll: command
  ]

  # Run a command and return exit code only
  # Usage: @ Process run: "make test"
  classMethod: run: command [
    ^ @ Shell run: command
  ]

  # Run a command in background, return PID
  # Usage: pid=$(@ Process spawn: "long-running-task")
  classMethod: spawn: command [
    ^ @ Shell spawn: command
  ]

  # Wait for a PID to complete
  # Usage: @ Process waitPid: $pid
  classMethod: waitPid: pid [
    ^ @ Shell wait: pid
  ]

  # Check if a PID is running
  # Usage: @ Process isRunningPid: $pid
  classMethod: isRunningPid: pid [
    ^ @ Shell isAlive: pid
  ]

  # Kill a PID
  # Usage: @ Process killPid: $pid
  classMethod: killPid: pid [
    ^ @ Shell terminate: pid
  ]

  # Show help
  method: help [
    @ Console print: "=== Process Management ==="
    @ Console print: ""
    @ Console print: "Instance Methods (for managed processes):"
    @ Console print: "  proc=\$(@ Process for: \"command\")   - Create process wrapper"
    @ Console print: "  @ \$proc run                          - Run blocking, capture output"
    @ Console print: "  @ \$proc start                        - Run in background"
    @ Console print: "  @ \$proc wait                         - Wait for background completion"
    @ Console print: "  @ \$proc isRunning                    - Check if still running"
    @ Console print: "  @ \$proc terminate                    - Send SIGTERM"
    @ Console print: "  @ \$proc kill                         - Send SIGKILL"
    @ Console print: "  @ \$proc output                       - Get stdout"
    @ Console print: "  @ \$proc errors                       - Get stderr"
    @ Console print: "  @ \$proc exitCode                     - Get exit code"
    @ Console print: "  @ \$proc succeeded                    - Check if exit code is 0"
    @ Console print: "  @ \$proc info                         - Show process info"
  ]
