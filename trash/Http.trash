# Http - HTTP client primitive class
# Provides HTTP operations using curl
#
# Usage:
#   response := @ Http get: 'https://api.example.com/data'
#   response := @ Http post: '{"name":"test"}' to: 'https://api.example.com/data'
#   status := @ Http status: 'https://example.com'
#
Http subclass: Object
  pragma: primitiveClass

  # ==========================================
  # Basic Methods
  # ==========================================

  # Simple GET request
  # Usage: response := @ Http get: 'https://api.example.com/data'
  classMethod: get: url [
    curl -s "$1"
  ]

  # Simple POST request with JSON body
  # Usage: response := @ Http post: '{"name":"test"}' to: 'https://api.example.com'
  classMethod: post: data to: url [
    curl -s -X POST -H "Content-Type: application/json" -d "$1" "$2"
  ]

  # Simple PUT request with JSON body
  # Usage: response := @ Http put: '{"name":"updated"}' to: 'https://api.example.com/1'
  classMethod: put: data to: url [
    curl -s -X PUT -H "Content-Type: application/json" -d "$1" "$2"
  ]

  # Simple PATCH request with JSON body
  # Usage: response := @ Http patch: '{"name":"patched"}' to: 'https://api.example.com/1'
  classMethod: patch: data to: url [
    curl -s -X PATCH -H "Content-Type: application/json" -d "$1" "$2"
  ]

  # Simple DELETE request
  # Usage: response := @ Http delete: 'https://api.example.com/1'
  classMethod: delete: url [
    curl -s -X DELETE "$1"
  ]

  # HEAD request (headers only)
  # Usage: headers := @ Http head: 'https://example.com'
  classMethod: head: url [
    curl -sI "$1"
  ]

  # ==========================================
  # Status and Metadata
  # ==========================================

  # Get HTTP status code only
  # Usage: status := @ Http status: 'https://example.com'
  classMethod: status: url [
    curl -s -o /dev/null -w "%{http_code}" "$1"
  ]

  # Check if URL is reachable (returns true/false)
  # Usage: ok := @ Http ping: 'https://example.com'
  classMethod: ping: url [
    local status
    status=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 5 "$1")
    if [[ "$status" -ge 200 && "$status" -lt 400 ]]; then
      echo "true"
    else
      echo "false"
    fi
  ]

  # Get response with headers
  # Usage: response := @ Http getWithHeaders: 'https://api.example.com'
  classMethod: getWithHeaders: url [
    curl -si "$1"
  ]

  # ==========================================
  # With Headers
  # ==========================================

  # GET with custom header
  # Usage: response := @ Http get: url header: 'X-Custom: value'
  classMethod: get: url header: header [
    curl -s -H "$2" "$1"
  ]

  # GET with multiple headers (as JSON object)
  # Usage: response := @ Http get: url headers: '{"X-Api-Key":"abc","Accept":"application/json"}'
  classMethod: get: url headers: headersJson [
    local args="-s"
    while IFS= read -r header; do
      args="$args -H \"$header\""
    done < <(echo "$2" | jq -r 'to_entries | .[] | "\(.key): \(.value)"')
    eval "curl $args \"$1\""
  ]

  # POST with custom headers
  # Usage: response := @ Http post: data to: url headers: '{"Authorization":"Bearer token"}'
  classMethod: post: data to: url headers: headersJson [
    local args="-s -X POST -H \"Content-Type: application/json\""
    while IFS= read -r header; do
      args="$args -H \"$header\""
    done < <(echo "$3" | jq -r 'to_entries | .[] | "\(.key): \(.value)"')
    eval "curl $args -d '$1' \"$2\""
  ]

  # ==========================================
  # Authentication
  # ==========================================

  # GET with Bearer token
  # Usage: response := @ Http get: url token: 'abc123'
  classMethod: get: url token: token [
    curl -s -H "Authorization: Bearer $2" "$1"
  ]

  # POST with Bearer token
  # Usage: response := @ Http post: data to: url token: 'abc123'
  classMethod: post: data to: url token: token [
    curl -s -X POST -H "Content-Type: application/json" -H "Authorization: Bearer $3" -d "$1" "$2"
  ]

  # GET with Basic auth
  # Usage: response := @ Http get: url user: 'admin' password: 'secret'
  classMethod: get: url user: username password: password [
    curl -s -u "$2:$3" "$1"
  ]

  # ==========================================
  # File Operations
  # ==========================================

  # Download file to path
  # Usage: filepath := @ Http download: url to: '/tmp/file.zip'
  classMethod: download: url to: filepath [
    if curl -s -o "$2" "$1"; then
      echo "$2"
    else
      echo ""
    fi
  ]

  # Upload file
  # Usage: response := @ Http upload: '/tmp/file.txt' to: url
  classMethod: upload: filepath to: url [
    curl -s -X POST -F "file=@$1" "$2"
  ]

  # Upload file with field name
  # Usage: response := @ Http upload: '/tmp/file.txt' as: 'document' to: url
  classMethod: upload: filepath as: fieldName to: url [
    curl -s -X POST -F "$2=@$1" "$3"
  ]

  # ==========================================
  # Form Data
  # ==========================================

  # POST form data (application/x-www-form-urlencoded)
  # Usage: response := @ Http postForm: 'name=test&value=123' to: url
  classMethod: postForm: data to: url [
    curl -s -X POST -d "$1" "$2"
  ]

  # POST multipart form data
  # Usage: response := @ Http postMultipart: '{"field1":"value1","field2":"value2"}' to: url
  classMethod: postMultipart: fieldsJson to: url [
    local args="-s -X POST"
    while IFS= read -r field; do
      args="$args -F \"$field\""
    done < <(echo "$1" | jq -r 'to_entries | .[] | "\(.key)=\(.value)"')
    eval "curl $args \"$2\""
  ]

  # ==========================================
  # Advanced Options
  # ==========================================

  # GET with timeout
  # Usage: response := @ Http get: url timeout: 10
  classMethod: get: url timeout: seconds [
    curl -s --connect-timeout "$2" --max-time "$2" "$1"
  ]

  # GET following redirects
  # Usage: response := @ Http getFollowRedirects: url
  classMethod: getFollowRedirects: url [
    curl -sL "$1"
  ]

  # GET with retry
  # Usage: response := @ Http get: url retries: 3
  classMethod: get: url retries: count [
    curl -s --retry "$2" "$1"
  ]

  # ==========================================
  # Full Response
  # ==========================================

  # GET with full response info as JSON
  # Usage: info := @ Http getFull: url
  classMethod: getFull: url [
    local body status time_total
    local tmp="/tmp/http_$$_body"

    status=$(curl -s -o "$tmp" -w "%{http_code}" "$1")
    body=$(cat "$tmp" 2>/dev/null)
    rm -f "$tmp"

    jo body="$body" status="$status"
  ]

  # GET with timing info as JSON
  # Usage: timing := @ Http getTiming: url
  classMethod: getTiming: url [
    curl -s -o /dev/null -w '{
      "status": %{http_code},
      "time_namelookup": %{time_namelookup},
      "time_connect": %{time_connect},
      "time_appconnect": %{time_appconnect},
      "time_pretransfer": %{time_pretransfer},
      "time_starttransfer": %{time_starttransfer},
      "time_total": %{time_total},
      "size_download": %{size_download}
    }' "$1"
  ]

