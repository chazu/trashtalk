# Array - Collection object for managing lists
Array subclass: Object
  include: Debuggable
  include: Persistable
  instanceVars: items:'[]'

  # Create a new array
  method: new [
    | array_id |
    array_id := $(_generate_instance_id "Array")
    _create_instance "Array" "$array_id"
    ^ $array_id
  ]

  # Accessor for items ivar
  method: getItems [
    ^ items
  ]

  # Setter for items ivar
  method: setItems: newItems [
    items := newItems
  ]

  # Private helper - get the raw items JSON array
  method: _getItemsArray [
    ^ items
  ]

  # Get element at index
  method: at: index [
    ^ items arrayAt: index
  ]

  # Set element at index
  method: at: index put: value [
    items := items arrayAt: index put: value
    ^ value
  ]

  # Add element to end
  method: push: value [
    items := items arrayPush: value
    ^ value
  ]

  # Remove and return last element
  method: pop [
    | last |
    last := items arrayLast
    items := items arrayRemoveAt: -1
    ^ last
  ]

  # Get array length
  method: size [
    ^ items arrayLength
  ]

  # Check if array is empty
  method: isEmpty [
    ^ items arrayIsEmpty
  ]

  # Get first element
  method: first [
    ^ items arrayFirst
  ]

  # Get last element
  method: last [
    ^ items arrayLast
  ]

  # Print array contents
  rawMethod: show [
    local items len
    items="$(_ivar items)"
    len=$(echo "$items" | jq 'length')
    if [[ "$len" -eq 0 ]]; then
      echo "(empty array)"
    else
      echo "$items" | jq -r '.[]' | nl -v0 | sed 's/^[ \t]*//'
    fi
  ]

  # Initialize with values
  rawMethod: withValues: values [
    local items value
    items="[]"
    for value in $1; do
      items=$(echo "$items" | jq -c --arg v "$value" '. + [$v]')
    done
    _ivar_set items "$items"
    echo "$_RECEIVER"
  ]

  # Iterate over each element, calling block with each value
  # Usage: @ myArray do: [:each | @ Console print: each]
  rawMethod: do: block [
    pragma: direct
    local items len i element block_id="$1"
    items=$(@ "$_RECEIVER" _getItemsArray)
    len=$(echo "$items" | jq 'length')

    for ((i=0; i<len; i++)); do
      element=$(echo "$items" | jq -r ".[$i]")
      @ "$block_id" valueWith: "$element"
    done
  ]

  # Map each element through a block, returning new array
  # Usage: doubled := @ myArray collect: [:x | x * 2]
  rawMethod: collect: block [
    local items len i element result new_items block_id="$1"
    items=$(@ "$_RECEIVER" _getItemsArray)
    len=$(echo "$items" | jq 'length')
    new_items="[]"

    for ((i=0; i<len; i++)); do
      element=$(echo "$items" | jq -r ".[$i]")
      result=$(@ "$block_id" valueWith "$element")
      new_items=$(echo "$new_items" | jq -c --arg v "$result" '. + [$v]')
    done

    # Create new Array with results
    local new_array
    new_array=$(@ Array new)
    @ "$new_array" setItems: "$new_items"
    echo "$new_array"
  ]

  # Select elements where block returns true (non-empty string)
  rawMethod: select: block [
    local items len i element result new_items block_id="$1"
    items=$(@ "$_RECEIVER" _getItemsArray)
    len=$(echo "$items" | jq 'length')
    new_items="[]"

    for ((i=0; i<len; i++)); do
      element=$(echo "$items" | jq -r ".[$i]")
      result=$(@ "$block_id" valueWith "$element")
      # Non-empty result means true
      if [[ -n "$result" ]]; then
        new_items=$(echo "$new_items" | jq -c --arg v "$element" '. + [$v]')
      fi
    done

    # Create new Array with selected elements
    local new_array
    new_array=$(@ Array new)
    @ "$new_array" setItems: "$new_items"
    echo "$new_array"
  ]

  # Reduce array to single value using block
  # Usage: sum := @ myArray inject: 0 into: [:acc :each | acc + each]
  rawMethod: inject: initial into: block [
    local items len i element acc block_id="$2"
    items=$(@ "$_RECEIVER" _getItemsArray)
    len=$(echo "$items" | jq 'length')
    acc="$1"

    for ((i=0; i<len; i++)); do
      element=$(echo "$items" | jq -r ".[$i]")
      acc=$(@ "$block_id" valueWith: "$acc" and: "$element")
    done

    echo "$acc"
  ]
