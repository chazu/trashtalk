Transcript subclass: Object
  instanceVars: session:'' outputView:'' inputField:'' layout:'' running:'' transcriptHistory:''

  rawClassMethod: open [
    local transcript session
    transcript=$(@ Transcript new)
    session=$(@ YutaniSession connect 2>&1 | grep -v "^\[INFO\]" | tail -1)

    if [[ -z "$session" ]] || echo "$session" | grep -qi error; then
      echo "Error: Could not connect to Yutani server" >&2
      return 1
    fi

    @ "$transcript" setSession: "$session"
    @ "$transcript" setup
    @ "$transcript" run
  ]

  rawClassMethod: openOn: host [
    local transcript session host="$1"
    transcript=$(@ Transcript new)
    session=$(@ YutaniSession connectTo: "$host" 2>&1 | grep -v "^\[INFO\]" | tail -1)

    if [[ -z "$session" ]] || echo "$session" | grep -qi error; then
      echo "Error: Could not connect to Yutani server at $host" >&2
      return 1
    fi

    @ "$transcript" setSession: "$session"
    @ "$transcript" setup
    @ "$transcript" run
  ]

  method: setSession: s [
    _ivar_set session "$s"
  ]

  method: session [
    _ivar session
  ]

  rawMethod: setup [
    local session output_view input_field layout initial_text
    session="$(_ivar session)"

    # Create vertical layout
    layout=$(@ "$session" createVerticalLayout)
    _ivar_set layout "$layout"

    # Create the output text view
    initial_text="Trashtalk Transcript
Type code and press Enter to evaluate. Ctrl+C to exit.
"
    output_view=$(@ "$session" createTextView: 'Output')
    _ivar_set outputView "$output_view"
    _ivar_set transcriptHistory "$initial_text"
    @ "$session" setText: "$initial_text" on: "$output_view"

    # Create input field
    input_field=$(@ "$session" createInputFieldWithPlaceholder: '>' placeholder: 'Enter Trashtalk code...')
    _ivar_set inputField "$input_field"

    # Add widgets to layout - output view takes most space, input field is fixed with focus
    @ "$session" addChild: "$output_view" to: "$layout"
    @ "$session" addChild: "$input_field" to: "$layout" fixedSize: 3 focus: true

    # Set layout as root
    @ "$session" setRoot: "$layout"

    _ivar_set running "true"
  ]

  rawMethod: run [
    local session event sid fifo
    session="$(_ivar session)"

    # Get session ID and build FIFO path
    sid=$(@ "$session" sessionId)
    fifo="/tmp/yutani-events-${sid}"

    # Start event stream
    @ "$session" startEventStream

    # Open FIFO once and keep it open (crucial for continuous reading)
    exec 3< "$fifo"

    while [[ "$(_ivar running)" == "true" ]]; do
      # Read next event from file descriptor 3
      if ! read -r event <&3; then
        break
      fi

      if [[ -z "$event" ]]; then
        continue
      fi

      # Skip non-JSON lines (errors, etc)
      if ! echo "$event" | jq -e . >/dev/null 2>&1; then
        continue
      fi

      # Parse event type - check for widget events first
      if echo "$event" | jq -e '.widget' >/dev/null 2>&1; then
        @ "$_RECEIVER" handleWidgetEvent: "$event"
      elif echo "$event" | jq -e '.key' >/dev/null 2>&1; then
        @ "$_RECEIVER" handleKeyEvent: "$event"
      fi
    done

    # Close file descriptor
    exec 3<&-

    # Cleanup
    @ "$session" disconnect
  ]

  rawMethod: handleWidgetEvent: event [
    local widget_id event_type text input_field
    input_field="$(_ivar inputField)"

    # Extract widget event fields
    widget_id=$(echo "$event" | jq -r '.widget.widgetId.id // ""')
    event_type=$(echo "$event" | jq -r '.widget.type // ""')
    # Text is in the data map for input fields
    text=$(echo "$event" | jq -r '.widget.data.text // ""')

    # Check for submission from our input field
    if [[ "$widget_id" == "$input_field" ]]; then
      case "$event_type" in
        WIDGET_SUBMITTED)
          @ "$_RECEIVER" evaluateInput: "$text"
          ;;
      esac
    fi
  ]

  rawMethod: handleKeyEvent: event [
    local key_name session input_field text
    session="$(_ivar session)"
    input_field="$(_ivar inputField)"

    # Extract key info
    key_name=$(echo "$event" | jq -r '.key.key // ""')

    case "$key_name" in
      KEY_CTRL_C)
        # Exit
        _ivar_set running "false"
        ;;
      KEY_CTRL_D)
        # Also exit
        _ivar_set running "false"
        ;;
      KEY_CTRL_L)
        # Clear transcript
        @ "$_RECEIVER" clear
        ;;
      KEY_ENTER)
        # Get text from input field and evaluate
        text=$(@ "$session" getInputText: "$input_field")
        if [[ -n "$text" ]]; then
          @ "$_RECEIVER" evaluateInput: "$text"
        fi
        ;;
      KEY_TAB)
        # Refocus input field
        @ "$session" focusWidget: "$input_field"
        ;;
      KEY_ESC)
        # Clear input and refocus
        @ "$session" setInputText: '' on: "$input_field"
        @ "$session" focusWidget: "$input_field"
        ;;
    esac
  ]

  rawMethod: evaluateInput: text [
    local result session output_view input_field new_text
    session="$(_ivar session)"
    output_view="$(_ivar outputView)"
    input_field="$(_ivar inputField)"

    if [[ -z "$text" ]]; then
      return
    fi

    # Evaluate the code
    result=$(@ Trash eval: "$text" 2>&1)

    # Build new output
    new_text="> ${text}
${result}

"

    # Append to transcript
    @ "$_RECEIVER" appendText: "$new_text"

    # Clear input field
    @ "$session" setInputText: '' on: "$input_field"

    # Re-focus input field
    @ "$session" focusWidget: "$input_field"
  ]

  rawMethod: appendText: text [
    local session output_view history
    session="$(_ivar session)"
    output_view="$(_ivar outputView)"

    history="$(_ivar transcriptHistory)"
    history="${history}${text}"
    _ivar_set transcriptHistory "$history"

    @ "$session" setText: "$history" on: "$output_view"
  ]

  rawMethod: clear [
    local session output_view
    session="$(_ivar session)"
    output_view="$(_ivar outputView)"

    _ivar_set transcriptHistory ""
    @ "$session" setText: "" on: "$output_view"
  ]

  method: close [
    _ivar_set running "false"
  ]

