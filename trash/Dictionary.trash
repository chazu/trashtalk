# Dictionary - Collection object for key-value pairs
Dictionary subclass: Object
  include: Debuggable
  instanceVars: items:'{}'

  # Create a new dictionary
  classMethod: new [
    | id |
    id := @ Runtime generateId: "Dictionary"
    @ Runtime create: "Dictionary" id: id
    ^ id
  ]

  # Accessor for items ivar (raw JSON)
  method: getItems [
    ^ items
  ]

  # Setter for items ivar
  method: setItems: newItems [
    items := newItems
  ]

  # Private helper - get the raw items JSON object
  method: _getItemsObject [
    ^ items
  ]

  # Get value at key
  # Usage: @ dict at: 'name'
  method: at: key [
    ^ items objectAt: key
  ]

  # Set value at key
  # Usage: @ dict at: 'name' put: 'Alice'
  method: at: key put: value [
    items := items objectAt: key put: value
    ^ value
  ]

  # Check if key exists
  # Usage: @ dict includesKey: 'name'
  method: includesKey: key [
    ^ items objectHasKey: key
  ]

  # Remove key-value pair and return old value
  # Usage: @ dict removeAt: 'name'
  method: removeAt: key [
    | oldValue |
    oldValue := items objectAt: key
    items := items objectRemoveKey: key
    ^ oldValue
  ]

  # Get all keys, one per line
  # Usage: keys := @ dict keys  # Returns newline-separated keys
  primitiveMethod: keys [
    echo "$(_ivar items)" | jq -r 'keys[]'
  ]

  # Get all values, one per line
  # Usage: values := @ dict values  # Returns newline-separated values
  primitiveMethod: values [
    echo "$(_ivar items)" | jq -r '.[]'
  ]

  # Get dictionary size (number of keys)
  method: size [
    ^ items objectLength
  ]

  # Check if dictionary is empty
  method: isEmpty [
    ^ items objectIsEmpty
  ]

  # Print dictionary contents
  method: show [
    (items objectIsEmpty) ifTrue: [^ '(empty dictionary)'] ifFalse: [^ items]
  ]

  # Create dictionary from pairs
  # Usage: @ dict withPairs: 'name:Alice age:30'
  primitiveMethod: withPairs: pairs [
    local pairs="$1"
    local items pair key value
    items="{}"
    for pair in $pairs; do
      key="${pair%%:*}"
      value="${pair#*:}"
      items=$(echo "$items" | jq -c --arg k "$key" --arg v "$value" '.[$k] = $v')
    done
    _ivar_set items "$items"
    echo "$_RECEIVER"
  ]

  # Iterate over each key-value pair, calling block with key and value
  # Usage: @ dict do: [:key :value | echo "$key = $value"]
  primitiveMethod: do: block [
    local items keys_json key value block_id="$1"
    items="$(_ivar items)"

    # Iterate over keys
    while IFS= read -r key; do
      value=$(echo "$items" | jq -r --arg k "$key" '.[$k]')
      @ "$block_id" valueWith: "$key" and: "$value"
    done < <(echo "$items" | jq -r 'keys[]')
  ]

  # Iterate over keys only
  # Usage: @ dict keysDo: [:key | echo "Key: $key"]
  primitiveMethod: keysDo: block [
    local items key block_id="$1"
    items="$(_ivar items)"

    while IFS= read -r key; do
      @ "$block_id" valueWith: "$key"
    done < <(echo "$items" | jq -r 'keys[]')
  ]

  # Iterate over values only
  # Usage: @ dict valuesDo: [:value | echo "Value: $value"]
  primitiveMethod: valuesDo: block [
    local items value block_id="$1"
    items="$(_ivar items)"

    while IFS= read -r value; do
      @ "$block_id" valueWith: "$value"
    done < <(echo "$items" | jq -r '.[]')
  ]

  # Map values through a block, returning new dictionary with same keys
  # Usage: doubled := @ dict collect: [:v | v * 2]
  primitiveMethod: collect: block [
    local items key value result new_items block_id="$1"
    items="$(_ivar items)"
    new_items="{}"

    while IFS= read -r key; do
      value=$(echo "$items" | jq -r --arg k "$key" '.[$k]')
      result=$(@ "$block_id" valueWith: "$value")
      new_items=$(echo "$new_items" | jq -c --arg k "$key" --arg v "$result" '.[$k] = $v')
    done < <(echo "$items" | jq -r 'keys[]')

    # Create new Dictionary with results
    local new_dict
    new_dict=$(@ Dictionary new)
    @ "$new_dict" setItems: "$new_items"
    echo "$new_dict"
  ]

  # Select key-value pairs where block returns true
  # Usage: evens := @ dict select: [:k :v | (v % 2) == 0]
  primitiveMethod: select: block [
    local items key value result new_items block_id="$1"
    items="$(_ivar items)"
    new_items="{}"

    while IFS= read -r key; do
      value=$(echo "$items" | jq -r --arg k "$key" '.[$k]')
      result=$(@ "$block_id" valueWith: "$key" and: "$value")
      # Non-empty result means true
      if [[ -n "$result" ]]; then
        new_items=$(echo "$new_items" | jq -c --arg k "$key" --arg v "$value" '.[$k] = $v')
      fi
    done < <(echo "$items" | jq -r 'keys[]')

    # Create new Dictionary with selected pairs
    local new_dict
    new_dict=$(@ Dictionary new)
    @ "$new_dict" setItems: "$new_items"
    echo "$new_dict"
  ]

  # Merge another dictionary into this one (modifies self)
  # Usage: @ dict merge: otherDict
  primitiveMethod: merge: other [
    local other="$1"
    local items other_items merged
    items=$(_ivar items)
    other_items=$(@ "$other" asJson)
    merged=$(echo "$items" "$other_items" | jq -sc '.[0] * .[1]')
    _ivar_set items "$merged"
    echo "$_RECEIVER"
  ]

  # Get value at key, or default if missing
  # Usage: @ dict at: 'missing' ifAbsent: 'default'
  # pragma: bashOnly (Go codegen bug with boolean conditionals)
  method: at: key ifAbsent: default [
    pragma: bashOnly
    (items objectHasKey: key) ifTrue: [^ items objectAt: key] ifFalse: [^ default]
  ]

  # Clear all entries
  method: clear [
    @ self setItems: '{}'
    ^ self
  ]

  # Return as JSON string (compact format)
  primitiveMethod: asJson [
    echo "$(_ivar items)" | jq -c '.'
  ]

  # Create dictionary from JSON string
  # pragma: bashOnly (Go codegen issue with class methods returning objects)
  classMethod: fromJson: json [
    pragma: bashOnly
    | dict |
    dict := (@ Dictionary new)
    @ dict setItems: json
    ^ dict
  ]
