#!/usr/bin/env bash
# Generated by Trashtalk Compiler (jq) - DO NOT EDIT
# Source: Coproc.trash
# Generated: 2026-01-04T02:40:08

__Coproc__superclass="Object"
__Coproc__instanceVars="command: pid: fifoIn: fifoOut: status:"
__Coproc__classInstanceVars=""
__Coproc__traits=""
__Coproc__sourceHash="204e1f88f893eef28ac82a2d1f685e851508d69bfe9cd41e37255e5f56e80d97"

__Coproc__source() {
  cat <<'__TRASHTALK_SOURCE_EOF__'
# Coproc - Bidirectional subprocess communication
# Provides reliable async process interaction via FIFOs
Coproc subclass: Object
  instanceVars: command:'' pid:'' fifoIn:'' fifoOut:'' status:''

  # Create a coproc for a command (does not start it yet)
  rawClassMethod: for: cmd [
    local id
    id=$(_generate_instance_id Coproc)
    _create_instance Coproc "$id"
    @ "$id" _setCommand: "$cmd"
    @ "$id" _setStatus: "created"
    echo "$id"
  ]

  # Start the coprocess in read-only mode (no stdin needed)
  # Better for commands that just produce output (like grpcurl subscribe)
  rawMethod: startReadOnly [
    local cmd bg_pid fifo_out pidfile
    cmd="$(_ivar command)"

    if [[ -z "$cmd" ]]; then
      echo "Error: No command set" >&2
      return 1
    fi

    fifo_out="/tmp/coproc_${_INSTANCE}_out"
    pidfile="/tmp/coproc_${_INSTANCE}_pid"
    rm -f "$fifo_out" "$pidfile"
    mkfifo "$fifo_out"

    # Spawn command in separate bash. The inner script:
    # 1. Opens FIFO read-write (fd 3) to prevent blocking
    # 2. Starts the command writing to the FIFO
    # 3. Closes fd 3 and writes PID
    /bin/bash -c '
      exec 3<>"$2"
      eval "$1" >"$2" 2>&1 &
      pid=$!
      exec 3<&-
      echo $pid > "$3"
    ' _ "$cmd" "$fifo_out" "$pidfile" </dev/null >/dev/null 2>&1

    # Small delay to ensure PID file is written
    sleep 0.1

    # Read the actual command PID
    bg_pid=$(cat "$pidfile" 2>/dev/null)
    rm -f "$pidfile"

    _ivar_set pid "$bg_pid"
    _ivar_set fifoOut "$fifo_out"
    _ivar_set status "running"
  ]

  # Start with bidirectional communication
  rawMethod: start [
    local cmd bg_pid fifo_in fifo_out
    cmd="$(_ivar command)"

    if [[ -z "$cmd" ]]; then
      echo "Error: No command set" >&2
      return 1
    fi

    fifo_in="/tmp/coproc_${_INSTANCE}_in"
    fifo_out="/tmp/coproc_${_INSTANCE}_out"
    rm -f "$fifo_in" "$fifo_out"
    mkfifo "$fifo_in" "$fifo_out"

    # Start command: reads from fifo_in, writes to fifo_out
    # Close inherited stdout/stderr to prevent $() from waiting
    ( eval "$cmd" < "$fifo_in" > "$fifo_out" 2>&1 ) >&- 2>&- &
    bg_pid=$!

    _ivar_set pid "$bg_pid"
    _ivar_set fifoIn "$fifo_in"
    _ivar_set fifoOut "$fifo_out"
    _ivar_set status "running"

    echo "$bg_pid"
  ]

  # Get the output FIFO path (for use with tail -f or direct reading)
  method: fifoOut [
    _ivar fifoOut
  ]

  # Get the input FIFO path (for writing to the process)
  method: fifoIn [
    _ivar fifoIn
  ]

  # Read a single line from the process output
  # NOTE: Opens/closes FIFO each time - use readLines for continuous reading
  rawMethod: readLine [
    local fifo_out line
    fifo_out="$(_ivar fifoOut)"

    if [[ -z "$fifo_out" ]] || [[ ! -p "$fifo_out" ]]; then
      echo "Error: Coproc not started or FIFO missing" >&2
      return 1
    fi

    if read -r line < "$fifo_out"; then
      echo "$line"
      return 0
    else
      return 1
    fi
  ]

  # Read lines continuously, calling a handler for each
  # Usage: @ $coproc readLinesDo: '@ $obj handleLine'
  # The handler can access the current line via $__COPROC_LINE
  # (Using a global avoids quote escaping issues with JSON content)
  rawMethod: readLinesDo: handler [
    local fifo_out handler="$1"
    fifo_out="$(_ivar fifoOut)"

    if [[ -z "$fifo_out" ]] || [[ ! -p "$fifo_out" ]]; then
      echo "Error: Coproc not started or FIFO missing" >&2
      return 1
    fi

    # Read lines - store in global to avoid eval quoting issues
    while IFS= read -r __COPROC_LINE; do
      eval "$handler"
    done < "$fifo_out"
  ]

  # Write a line to the process stdin
  rawMethod: writeLine: text [
    local fifo_in text="$1"
    fifo_in="$(_ivar fifoIn)"

    if [[ -z "$fifo_in" ]] || [[ ! -p "$fifo_in" ]]; then
      echo "Error: Coproc not started in bidirectional mode" >&2
      return 1
    fi

    echo "$text" > "$fifo_in"
  ]

  # Check if the coprocess is still running
  rawMethod: isRunning [
    local proc_pid
    proc_pid="$(_ivar pid)"

    if [[ -z "$proc_pid" ]]; then
      echo "false"
      return 1
    fi

    if kill -0 "$proc_pid" 2>/dev/null; then
      echo "true"
      return 0
    else
      _ivar_set status "exited"
      echo "false"
      return 1
    fi
  ]

  # Terminate the coprocess (SIGTERM)
  rawMethod: terminate [
    local proc_pid
    proc_pid="$(_ivar pid)"

    if [[ -n "$proc_pid" ]]; then
      kill -TERM "$proc_pid" 2>/dev/null
      _ivar_set status "terminated"
    fi

    @ "$_RECEIVER" _cleanup
  ]

  # Kill the coprocess (SIGKILL)
  rawMethod: kill [
    local proc_pid
    proc_pid="$(_ivar pid)"

    if [[ -n "$proc_pid" ]]; then
      kill -KILL "$proc_pid" 2>/dev/null
      _ivar_set status "killed"
    fi

    @ "$_RECEIVER" _cleanup
  ]

  # Get the PID
  method: pid [
    _ivar pid
  ]

  # Get status
  method: status [
    _ivar status
  ]

  # Clean up FIFOs
  rawMethod: _cleanup [
    local fifo_in fifo_out

    fifo_in="$(_ivar fifoIn)"
    fifo_out="$(_ivar fifoOut)"

    rm -f "$fifo_in" "$fifo_out" 2>/dev/null

    _ivar_set fifoIn ""
    _ivar_set fifoOut ""
  ]

  # Private setters
  rawMethod: _setCommand: cmd [
    _ivar_set command "$cmd"
  ]

  rawMethod: _setStatus: s [
    _ivar_set status "$s"
  ]
__TRASHTALK_SOURCE_EOF__
}

__Coproc__command() {
  echo "$(_ivar command)"; return
}

__Coproc__command_() {
  _ivar_set command "$1"
}

__Coproc__getCommand() {
  echo "$(_ivar command)"; return
}

__Coproc__setCommand_() {
  _ivar_set command "$1"
}
__Coproc__pid() {
  echo "$(_ivar pid)"; return
}

__Coproc__pid_() {
  _ivar_set pid "$1"
}

__Coproc__getPid() {
  echo "$(_ivar pid)"; return
}

__Coproc__setPid_() {
  _ivar_set pid "$1"
}
__Coproc__fifoIn() {
  echo "$(_ivar fifoIn)"; return
}

__Coproc__fifoIn_() {
  _ivar_set fifoIn "$1"
}

__Coproc__getFifoIn() {
  echo "$(_ivar fifoIn)"; return
}

__Coproc__setFifoIn_() {
  _ivar_set fifoIn "$1"
}
__Coproc__fifoOut() {
  echo "$(_ivar fifoOut)"; return
}

__Coproc__fifoOut_() {
  _ivar_set fifoOut "$1"
}

__Coproc__getFifoOut() {
  echo "$(_ivar fifoOut)"; return
}

__Coproc__setFifoOut_() {
  _ivar_set fifoOut "$1"
}
__Coproc__status() {
  echo "$(_ivar status)"; return
}

__Coproc__status_() {
  _ivar_set status "$1"
}

__Coproc__getStatus() {
  echo "$(_ivar status)"; return
}

__Coproc__setStatus_() {
  _ivar_set status "$1"
}

__Coproc__class__for_() {
  local cmd="$1"
    local id
    id=$(_generate_instance_id Coproc)
    _create_instance Coproc "$id"
    @ "$id" _setCommand: "$cmd"
    @ "$id" _setStatus: "created"
    echo "$id"
}

__Coproc__startReadOnly() {
    local cmd bg_pid fifo_out pidfile
    cmd="$(_ivar command)"

    if [[ -z "$cmd" ]]; then
        echo "Error: No command set" >&2
        return 1
    fi

    fifo_out="/tmp/coproc_${_INSTANCE}_out"
    pidfile="/tmp/coproc_${_INSTANCE}_pid"
    rm -f "$fifo_out" "$pidfile"
    mkfifo "$fifo_out"

    # Spawn command in separate bash. The inner script:
    # 1. Opens FIFO read-write (fd 3) to prevent blocking
    # 2. Starts the command writing to the FIFO
    # 3. Closes fd 3 and writes PID
    /bin/bash -c '
    exec 3<>"$2"
    eval "$1" >"$2" 2>&1 &
    pid=$!
    exec 3<&-
    echo $pid > "$3"
    ' _ "$cmd" "$fifo_out" "$pidfile" </dev/null >/dev/null 2>&1

    # Small delay to ensure PID file is written
    sleep 0.1

    # Read the actual command PID
    bg_pid=$(cat "$pidfile" 2>/dev/null)
    rm -f "$pidfile"

    _ivar_set pid "$bg_pid"
    _ivar_set fifoOut "$fifo_out"
    _ivar_set status "running"
}

__Coproc__start() {
    local cmd bg_pid fifo_in fifo_out
    cmd="$(_ivar command)"

    if [[ -z "$cmd" ]]; then
        echo "Error: No command set" >&2
        return 1
    fi

    fifo_in="/tmp/coproc_${_INSTANCE}_in"
    fifo_out="/tmp/coproc_${_INSTANCE}_out"
    rm -f "$fifo_in" "$fifo_out"
    mkfifo "$fifo_in" "$fifo_out"

    # Start command: reads from fifo_in, writes to fifo_out
    # Close inherited stdout/stderr to prevent $() from waiting
    (eval "$cmd" <"$fifo_in" >"$fifo_out" 2>&1) >&-2>&- &
    bg_pid=$!

    _ivar_set pid "$bg_pid"
    _ivar_set fifoIn "$fifo_in"
    _ivar_set fifoOut "$fifo_out"
    _ivar_set status "running"

    echo "$bg_pid"
}

__Coproc__fifoOut() {
  _ivar fifoOut
}

__Coproc__fifoIn() {
  _ivar fifoIn
}

__Coproc__readLine() {
    local fifo_out line
    fifo_out="$(_ivar fifoOut)"

    if [[ -z "$fifo_out" ]] || [[ ! -p "$fifo_out" ]]; then
        echo "Error: Coproc not started or FIFO missing" >&2
        return 1
    fi

    if read -r line <"$fifo_out"; then
        echo "$line"
        return 0
        else
        return 1
    fi
}

__Coproc__readLinesDo_() {
  local handler="$1"
    local fifo_out handler="$1"
    fifo_out="$(_ivar fifoOut)"

    if [[ -z "$fifo_out" ]] || [[ ! -p "$fifo_out" ]]; then
        echo "Error: Coproc not started or FIFO missing" >&2
        return 1
    fi

    # Read lines - store in global to avoid eval quoting issues
    while IFS= read -r __COPROC_LINE; do
        eval "$handler"
    done <"$fifo_out"
}

__Coproc__writeLine_() {
  local text="$1"
    local fifo_in text="$1"
    fifo_in="$(_ivar fifoIn)"

    if [[ -z "$fifo_in" ]] || [[ ! -p "$fifo_in" ]]; then
        echo "Error: Coproc not started in bidirectional mode" >&2
        return 1
    fi

    echo "$text" >"$fifo_in"
}

__Coproc__isRunning() {
    local proc_pid
    proc_pid="$(_ivar pid)"

    if [[ -z "$proc_pid" ]]; then
        echo "false"
        return 1
    fi

    if kill -0 "$proc_pid" 2>/dev/null; then
        echo "true"
        return 0
        else
        _ivar_set status "exited"
        echo "false"
        return 1
    fi
}

__Coproc__terminate() {
    local proc_pid
    proc_pid="$(_ivar pid)"

    if [[ -n "$proc_pid" ]]; then
        kill -TERM "$proc_pid" 2>/dev/null
        _ivar_set status "terminated"
    fi

    @ "$_RECEIVER" _cleanup
}

__Coproc__kill() {
    local proc_pid
    proc_pid="$(_ivar pid)"

    if [[ -n "$proc_pid" ]]; then
        kill -KILL "$proc_pid" 2>/dev/null
        _ivar_set status "killed"
    fi

    @ "$_RECEIVER" _cleanup
}

__Coproc__pid() {
  _ivar pid
}

__Coproc__status() {
  _ivar status
}

__Coproc___cleanup() {
    local fifo_in fifo_out

    fifo_in="$(_ivar fifoIn)"
    fifo_out="$(_ivar fifoOut)"

    rm -f "$fifo_in" "$fifo_out" 2>/dev/null

    _ivar_set fifoIn ""
    _ivar_set fifoOut ""
}

__Coproc___setCommand_() {
  local cmd="$1"
    _ivar_set command "$cmd"
}

__Coproc___setStatus_() {
  local s="$1"
    _ivar_set status "$s"
}
