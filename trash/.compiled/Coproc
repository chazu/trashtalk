#!/usr/bin/env bash
# Generated by Trashtalk Compiler (procyon) - DO NOT EDIT
# Source: Coproc.trash
# Generated: 2026-01-09T20:29:53

__Coproc__superclass="Object"
__Coproc__instanceVars="command: pid: fifoIn: fifoOut: status:"
__Coproc__classInstanceVars=""
__Coproc__traits=""
__Coproc__sourceHash="e8a65e730fa1986de8b274d9c3331a888f548f4be7688203858c079b1c22351b"

__Coproc__source() {
  cat <<'__TRASHTALK_SOURCE_EOF__'
# Coproc - Bidirectional subprocess communication
# Provides reliable async process interaction via FIFOs
Coproc subclass: Object
  instanceVars: command:'' pid:'' fifoIn:'' fifoOut:'' status:''

  # Create a coproc for a command (does not start it yet)
  rawClassMethod: for: cmd [
    local id
    id=$(_generate_instance_id Coproc)
    _create_instance Coproc "$id"
    @ "$id" _setCommand: "$cmd"
    @ "$id" _setStatus: "created"
    echo "$id"
  ]

  # Start the coprocess in read-only mode (no stdin needed)
  # Better for commands that just produce output (like grpcurl subscribe)
  rawMethod: startReadOnly [
    local cmd bg_pid fifo_out pidfile
    cmd="$(_ivar command)"

    if [[ -z "$cmd" ]]; then
      echo "Error: No command set" >&2
      return 1
    fi

    fifo_out="/tmp/coproc_${_INSTANCE}_out"
    pidfile="/tmp/coproc_${_INSTANCE}_pid"
    rm -f "$fifo_out" "$pidfile"
    mkfifo "$fifo_out"

    # Spawn command in separate bash. The inner script:
    # 1. Opens FIFO read-write (fd 3) to prevent blocking
    # 2. Starts the command writing to the FIFO
    # 3. Closes fd 3 and writes PID
    /bin/bash -c '
      exec 3<>"$2"
      eval "$1" >"$2" 2>&1 &
      pid=$!
      exec 3<&-
      echo $pid > "$3"
    ' _ "$cmd" "$fifo_out" "$pidfile" </dev/null >/dev/null 2>&1

    # Small delay to ensure PID file is written
    sleep 0.1

    # Read the actual command PID
    bg_pid=$(cat "$pidfile" 2>/dev/null)
    rm -f "$pidfile"

    _ivar_set pid "$bg_pid"
    _ivar_set fifoOut "$fifo_out"
    _ivar_set status "running"
  ]

  # Start with bidirectional communication
  rawMethod: start [
    local cmd bg_pid fifo_in fifo_out pidfile
    cmd="$(_ivar command)"

    if [[ -z "$cmd" ]]; then
      echo "Error: No command set" >&2
      return 1
    fi

    fifo_in="/tmp/coproc_${_INSTANCE}_in"
    fifo_out="/tmp/coproc_${_INSTANCE}_out"
    pidfile="/tmp/coproc_${_INSTANCE}_pid"
    rm -f "$fifo_in" "$fifo_out" "$pidfile"
    mkfifo "$fifo_in" "$fifo_out"

    # Start command in separate bash to fully detach from parent shell.
    # This prevents $() from waiting for the background process.
    /bin/bash -c '
      eval "$1" < "$2" > "$3" 2>&1 &
      echo $! > "$4"
    ' _ "$cmd" "$fifo_in" "$fifo_out" "$pidfile" </dev/null >/dev/null 2>&1

    # Small delay to ensure PID file is written
    sleep 0.02

    # Read the actual command PID
    bg_pid=$(cat "$pidfile" 2>/dev/null)

    _ivar_set pid "$bg_pid"
    _ivar_set fifoIn "$fifo_in"
    _ivar_set fifoOut "$fifo_out"
    _ivar_set status "running"

    echo "$bg_pid"
  ]

  # Read a single line from the process output
  # NOTE: Opens/closes FIFO each time - use readLines for continuous reading
  rawMethod: readLine [
    local fifo_out line
    fifo_out="$(_ivar fifoOut)"

    if [[ -z "$fifo_out" ]] || [[ ! -p "$fifo_out" ]]; then
      echo "Error: Coproc not started or FIFO missing" >&2
      return 1
    fi

    if read -r line < "$fifo_out"; then
      echo "$line"
      return 0
    else
      return 1
    fi
  ]

  # Read lines continuously, calling a handler for each
  # Usage: @ $coproc readLinesDo: '@ $obj handleLine'
  # The handler can access the current line via $__COPROC_LINE
  # (Using a global avoids quote escaping issues with JSON content)
  rawMethod: readLinesDo: handler [
    local fifo_out handler="$1"
    fifo_out="$(_ivar fifoOut)"

    if [[ -z "$fifo_out" ]] || [[ ! -p "$fifo_out" ]]; then
      echo "Error: Coproc not started or FIFO missing" >&2
      return 1
    fi

    # Read lines - store in global to avoid eval quoting issues
    while IFS= read -r __COPROC_LINE; do
      eval "$handler"
    done < "$fifo_out"
  ]

  # Write a line to the process stdin
  rawMethod: writeLine: text [
    local fifo_in text="$1"
    fifo_in="$(_ivar fifoIn)"

    if [[ -z "$fifo_in" ]] || [[ ! -p "$fifo_in" ]]; then
      echo "Error: Coproc not started in bidirectional mode" >&2
      return 1
    fi

    echo "$text" > "$fifo_in"
  ]

  # Check if the coprocess is still running
  rawMethod: isRunning [
    local proc_pid
    proc_pid="$(_ivar pid)"

    if [[ -z "$proc_pid" ]]; then
      echo "false"
      return 1
    fi

    if kill -0 "$proc_pid" 2>/dev/null; then
      echo "true"
      return 0
    else
      _ivar_set status "exited"
      echo "false"
      return 1
    fi
  ]

  # Terminate the coprocess (SIGTERM)
  rawMethod: terminate [
    local proc_pid
    proc_pid="$(_ivar pid)"

    if [[ -n "$proc_pid" ]]; then
      kill -TERM "$proc_pid" 2>/dev/null
      _ivar_set status "terminated"
    fi

    @ "$_RECEIVER" _cleanup
  ]

  # Kill the coprocess (SIGKILL)
  rawMethod: kill [
    local proc_pid
    proc_pid="$(_ivar pid)"

    if [[ -n "$proc_pid" ]]; then
      kill -KILL "$proc_pid" 2>/dev/null
      _ivar_set status "killed"
    fi

    @ "$_RECEIVER" _cleanup
  ]

  # Clean up FIFOs
  rawMethod: _cleanup [
    local fifo_in fifo_out

    fifo_in="$(_ivar fifoIn)"
    fifo_out="$(_ivar fifoOut)"

    rm -f "$fifo_in" "$fifo_out" 2>/dev/null

    _ivar_set fifoIn ""
    _ivar_set fifoOut ""
  ]

  # Private setters
  method: _setCommand: cmd [
    command := cmd
  ]

  method: _setStatus: s [
    status := s
  ]

__TRASHTALK_SOURCE_EOF__
}

__Coproc__command() {
  echo "$(_ivar command)"; return
}

__Coproc__command_() {
  _ivar_set command "$1"
}

__Coproc__pid() {
  echo "$(_ivar pid)"; return
}

__Coproc__pid_() {
  _ivar_set pid "$1"
}

__Coproc__fifoIn() {
  echo "$(_ivar fifoIn)"; return
}

__Coproc__fifoIn_() {
  _ivar_set fifoIn "$1"
}

__Coproc__fifoOut() {
  echo "$(_ivar fifoOut)"; return
}

__Coproc__fifoOut_() {
  _ivar_set fifoOut "$1"
}

__Coproc__status() {
  echo "$(_ivar status)"; return
}

__Coproc__status_() {
  _ivar_set status "$1"
}

__Coproc__class__for_() {
  local cmd="$1"
  local id
  id=$(_generate_instance_id Coproc)
  _create_instance Coproc "$id"
  @ "$id" _setCommand: "$cmd"
  @ "$id" _setStatus: "created"
  echo "$id"
}

__Coproc__startReadOnly() {
  local cmd bg_pid fifo_out pidfile
  cmd="$(_ivar command)"
  if [[ -z "$cmd" ]] ; then
  echo "Error: No command set" >& 2
  return 1
  fi
  fifo_out="/tmp/coproc_${_INSTANCE}_out"
  pidfile="/tmp/coproc_${_INSTANCE}_pid"
  rm -f "$fifo_out" "$pidfile"
  mkfifo "$fifo_out"
  # Spawn command in separate bash. The inner script:
  # 1. Opens FIFO read-write (fd 3) to prevent blocking
  # 2. Starts the command writing to the FIFO
  # 3. Closes fd 3 and writes PID
  /bin/bash -c
  '
  exec 3<>"$2"
  eval "$1" >"$2" 2>&1 &
  pid=$!
  exec 3<&-
  echo $pid > "$3"
  ' _ "$cmd" "$fifo_out" "$pidfile" </dev/null > /dev/null 2 >& 1
  # Small delay to ensure PID file is written
  sleep 0.1
  # Read the actual command PID
  bg_pid=$(cat "$pidfile" 2>/dev/null)
  rm -f "$pidfile"
  _ivar_set pid "$bg_pid"
  _ivar_set fifoOut "$fifo_out"
  _ivar_set status "running"
}

__Coproc__start() {
  local cmd bg_pid fifo_in fifo_out pidfile
  cmd="$(_ivar command)"
  if [[ -z "$cmd" ]] ; then
  echo "Error: No command set" >& 2
  return 1
  fi
  fifo_in="/tmp/coproc_${_INSTANCE}_in"
  fifo_out="/tmp/coproc_${_INSTANCE}_out"
  pidfile="/tmp/coproc_${_INSTANCE}_pid"
  rm -f "$fifo_in" "$fifo_out" "$pidfile"
  mkfifo "$fifo_in" "$fifo_out"
  # Start command in separate bash to fully detach from parent shell.
  # This prevents $() from waiting for the background process.
  /bin/bash -c
  '
  eval "$1" < "$2" > "$3" 2>&1 &
  echo $! > "$4"
  ' _ "$cmd" "$fifo_in" "$fifo_out" "$pidfile" </dev/null > /dev/null 2 >& 1
  # Small delay to ensure PID file is written
  sleep 0.02
  # Read the actual command PID
  bg_pid=$(cat "$pidfile" 2>/dev/null)
  _ivar_set pid "$bg_pid"
  _ivar_set fifoIn "$fifo_in"
  _ivar_set fifoOut "$fifo_out"
  _ivar_set status "running"
  echo "$bg_pid"
}

__Coproc__readLine() {
  local fifo_out line
  fifo_out="$(_ivar fifoOut)"
  if [[ -z "$fifo_out" ]] || [[ ! -p "$fifo_out" ]] ; then
  echo "Error: Coproc not started or FIFO missing" >& 2
  return 1
  fi
  if read -r line < "$fifo_out" ; then
  echo "$line"
  return 0
  else
  return 1
  fi
}

__Coproc__readLinesDo_() {
  local handler="$1"
  local fifo_out handler="$1"
  fifo_out="$(_ivar fifoOut)"
  if [[ -z "$fifo_out" ]] || [[ ! -p "$fifo_out" ]] ; then
  echo "Error: Coproc not started or FIFO missing" >& 2
  return 1
  fi
  # Read lines - store in global to avoid eval quoting issues
  while IFS=read -r __COPROC_LINE ; do
  eval "$handler"
  done < "$fifo_out"
}

__Coproc__writeLine_() {
  local text="$1"
  local fifo_in text="$1"
  fifo_in="$(_ivar fifoIn)"
  if [[ -z "$fifo_in" ]] || [[ ! -p "$fifo_in" ]] ; then
  echo "Error: Coproc not started in bidirectional mode" >& 2
  return 1
  fi
  echo "$text" > "$fifo_in"
}

__Coproc__isRunning() {
  local proc_pid
  proc_pid="$(_ivar pid)"
  if [[ -z "$proc_pid" ]] ; then
  echo "false"
  return 1
  fi
  if kill -0 "$proc_pid" 2 > /dev/null ; then
  echo "true"
  return 0
  else
  _ivar_set status "exited"
  echo "false"
  return 1
  fi
}

__Coproc__terminate() {
  local proc_pid
  proc_pid="$(_ivar pid)"
  if [[ -n "$proc_pid" ]] ; then
  kill - TERM "$proc_pid" 2 > /dev/null
  _ivar_set status "terminated"
  fi
  @ "$_RECEIVER" _cleanup
}

__Coproc__kill() {
  local proc_pid
  proc_pid="$(_ivar pid)"
  if [[ -n "$proc_pid" ]] ; then
  kill - KILL "$proc_pid" 2 > /dev/null
  _ivar_set status "killed"
  fi
  @ "$_RECEIVER" _cleanup
}

__Coproc___cleanup() {
  local fifo_in fifo_out
  fifo_in="$(_ivar fifoIn)"
  fifo_out="$(_ivar fifoOut)"
  rm -f "$fifo_in" "$fifo_out" 2 > /dev/null
  _ivar_set fifoIn ""
  _ivar_set fifoOut ""
}

__Coproc___setCommand_() {
  local cmd="$1"
  _ivar_set command "$cmd"
}

__Coproc___setStatus_() {
  local s="$1"
  _ivar_set status "$s"
}

