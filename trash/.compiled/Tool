#!/usr/bin/env bash
# Generated by Trashtalk Compiler (jq) - DO NOT EDIT
# Source: Tool.trash
# Generated: 2025-12-26T02:09:54

__Tool__superclass="Object"
__Tool__instanceVars=""
__Tool__classInstanceVars=""
__Tool__traits=""

__Tool__class__name() {
  echo ""
}

__Tool__class__installCommand() {
  echo ""
}

__Tool__class__isInstalled() {
    local tool_name
    tool_name=$(@ "$_CLASS" name)
    if command -v "$tool_name" >/dev/null 2>&1; then
        echo "true"
        else
        echo "false"
    fi
}

__Tool__class__path() {
    local tool_name
    tool_name=$(@ "$_CLASS" name)
    command -v "$tool_name" 2>/dev/null
}

__Tool__class__version() {
    local tool_name tool_path
    tool_name=$(@ "$_CLASS" name)
    tool_path=$(command -v "$tool_name" 2>/dev/null)
    if [[ -z "$tool_path" ]]; then
        echo "not installed"
        return 1
    fi
    # Try common version flags
    "$tool_path" --version 2>/dev/null | head -1 || \
        "$tool_path" -version 2>/dev/null | head -1 || \
        "$tool_path" -V 2>/dev/null | head -1 || \
        echo "unknown"
}

__Tool__class__install() {
    local install_cmd
    install_cmd=$(@ "$_CLASS" installCommand)
    if [[ -z "$install_cmd" ]]; then
        _throw "InstallError" "No install command defined for $(@ "$_CLASS" name)"
        return 1
    fi
    echo "Installing $(@ "$_CLASS" name)..."
    if eval "$install_cmd"; then
        echo "Successfully installed $(@ "$_CLASS" name)"
        return 0
        else
        _throw "InstallError" "Failed to install $(@ "$_CLASS" name)"
        return 1
    fi
}

__Tool__class__ensure() {
    local tool_name is_installed
    tool_name=$(@ "$_CLASS" name)

    if [[ -z "$tool_name" ]]; then
        _throw "ToolError" "Tool name not set"
        return 1
    fi

    # Check if already installed
    is_installed=$(@ "$_CLASS" isInstalled)
    if [[ "$is_installed" == "true" ]]; then
        echo "true"
        return 0
    fi

    # Try to install
    echo "$tool_name not found, attempting install..." >&2
    if ! @ "$_CLASS" install; then
        # install already threw an error
        return 1
    fi

    # Verify installation succeeded
    # Refresh command hash table
    hash -r 2>/dev/null

    is_installed=$(@ "$_CLASS" isInstalled)
    if [[ "$is_installed" == "true" ]]; then
        echo "true"
        return 0
        else
        _throw "PathError" "$tool_name installed but not found on PATH"
        return 1
    fi
}

__Tool__class__run_() {
  local args="$1"
    local tool_name tool_path
    tool_name=$(@ "$_CLASS" name)
    tool_path=$(command -v "$tool_name" 2>/dev/null)

    if [[ -z "$tool_path" ]]; then
        _throw "ToolError" "$tool_name is not installed"
        return 1
    fi

    "$tool_path" $1
}

__Tool__class__runCapture_() {
  local args="$1"
    local tool_name tool_path result
    tool_name=$(@ "$_CLASS" name)
    tool_path=$(command -v "$tool_name" 2>/dev/null)

    if [[ -z "$tool_path" ]]; then
        _throw "ToolError" "$tool_name is not installed"
        return 1
    fi

    result=$("$tool_path" $1 2>&1)
    echo "$result"
}

__Tool__class__runAsync_() {
  local args="$1"
    local tool_name tool_path
    tool_name=$(@ "$_CLASS" name)
    tool_path=$(command -v "$tool_name" 2>/dev/null)

    if [[ -z "$tool_path" ]]; then
        _throw "ToolError" "$tool_name is not installed"
        return 1
    fi

    @ Future value: "$tool_path $1"
}

__Tool__class__commandExists_() {
  local commandName="$1"
    if command -v "$1" >/dev/null 2>&1; then
        echo "true"
        else
        echo "false"
    fi
}
