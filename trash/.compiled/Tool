#!/usr/bin/env bash
# Generated by Trashtalk Compiler (procyon) - DO NOT EDIT
# Source: Tool.trash
# Generated: 2026-01-12T14:23:41

__Tool__superclass="Object"
__Tool__instanceVars=""
__Tool__classInstanceVars=""
__Tool__traits=""
__Tool__sourceHash="a8d59e9826464f3bffdeb0a121b9b1ebb639eb6ed027beea7962cecbb6f4dfa2"

__Tool__source() {
  cat <<'__TRASHTALK_SOURCE_EOF__'
# Tool - Abstract base class for wrapping external command-line tools
# Provides detection, installation, and execution of external programs
# Built on Shell primitives - no raw bash required.
#
# Tool subclasses are singletons - use class methods directly:
#   @ JqTool ensure
#   @ JqTool run: '.foo'
#
# Subclass example:
#   JqTool subclass: Tool
#     classMethod: name [ ^ "jq" ]
#     classMethod: installCommand [ ^ "brew install jq" ]
#
Tool subclass: Object

  # Override in subclasses to return the command name
  classMethod: name [
    ^ ""
  ]

  # Override in subclasses to return the install command
  # e.g., "brew install jq" or "apt-get install -y jq"
  classMethod: installCommand [
    ^ ""
  ]

  # Check if the tool is installed and on PATH
  primitiveClassMethod: isInstalled [
    local toolName checkCmd
    toolName=$(@ "$_RECEIVER" name)
    checkCmd="command -v ${toolName}"
    @ Shell succeeds: "$checkCmd"
  ]

  # Get the path to the tool executable
  primitiveClassMethod: path [
    local toolName checkCmd
    toolName=$(@ "$_RECEIVER" name)
    checkCmd="command -v ${toolName}"
    @ Shell exec: "$checkCmd"
  ]

  # Get the version of the tool (override for tool-specific parsing)
  primitiveClassMethod: version [
    local toolName toolPath versionCmd result
    toolName=$(@ "$_RECEIVER" name)
    toolPath=$(@ "$_RECEIVER" path)

    if [[ -z "$toolPath" ]]; then
      echo "not installed"
      return
    fi

    # Try --version first
    versionCmd="${toolPath} --version 2>/dev/null | head -1"
    result=$(@ Shell exec: "$versionCmd")
    if [[ -n "$result" ]]; then echo "$result"; return; fi

    # Try -version
    versionCmd="${toolPath} -version 2>/dev/null | head -1"
    result=$(@ Shell exec: "$versionCmd")
    if [[ -n "$result" ]]; then echo "$result"; return; fi

    # Try -V
    versionCmd="${toolPath} -V 2>/dev/null | head -1"
    result=$(@ Shell exec: "$versionCmd")
    if [[ -n "$result" ]]; then echo "$result"; return; fi

    echo "unknown"
  ]

  # Install the tool - override in subclasses for custom behavior
  primitiveClassMethod: install [
    local installCmd toolName
    installCmd=$(@ "$_RECEIVER" installCommand)
    toolName=$(@ "$_RECEIVER" name)

    if [[ -z "$installCmd" ]]; then
      _throw "InstallError" "No install command defined for $toolName"
      echo ""
      return
    fi

    @ Console print: "Installing $toolName..."

    if @ Shell succeeds: "$installCmd"; then
      @ Console print: "Successfully installed $toolName"
      echo "true"
    else
      _throw "InstallError" "Failed to install $toolName"
      echo ""
    fi
  ]

  # Ensure the tool is installed and available
  # - Checks if installed
  # - Installs if not
  # - Verifies it's on PATH after install
  # Returns: "true" on success, throws error on failure
  primitiveClassMethod: ensure [
    local toolName isInstalledVal
    toolName=$(@ "$_RECEIVER" name)

    if [[ -z "$toolName" ]]; then
      _throw "ToolError" "Tool name not set"
      echo ""
      return
    fi

    # Check if already installed
    isInstalledVal=$(@ "$_RECEIVER" isInstalled)
    if [[ "$isInstalledVal" == "true" ]]; then
      echo "true"
      return
    fi

    # Try to install
    @ Console error: "$toolName not found, attempting install..."
    @ "$_RECEIVER" install

    # Refresh command hash table
    @ Shell silent: "hash -r"

    # Verify installation succeeded
    isInstalledVal=$(@ "$_RECEIVER" isInstalled)
    if [[ "$isInstalledVal" == "true" ]]; then
      echo "true"
    else
      _throw "PathError" "$toolName installed but not found on PATH"
      echo ""
    fi
  ]

  # Run the tool with arguments (synchronous)
  primitiveClassMethod: run: args [
    local args="$1" toolName toolPath runCmd
    toolName=$(@ "$_RECEIVER" name)
    toolPath=$(@ "$_RECEIVER" path)

    if [[ -z "$toolPath" ]]; then
      _throw "ToolError" "$toolName is not installed"
      echo ""
      return
    fi

    runCmd="${toolPath} ${args}"
    @ Shell exec: "$runCmd"
  ]

  # Run the tool with arguments, capturing stdout and stderr
  primitiveClassMethod: runCapture: args [
    local args="$1" toolName toolPath runCmd
    toolName=$(@ "$_RECEIVER" name)
    toolPath=$(@ "$_RECEIVER" path)

    if [[ -z "$toolPath" ]]; then
      _throw "ToolError" "$toolName is not installed"
      echo ""
      return
    fi

    runCmd="${toolPath} ${args}"
    @ Shell execAll: "$runCmd"
  ]

  # Run the tool asynchronously, returning a Future
  primitiveClassMethod: runAsync: args [
    local args="$1" toolName toolPath futureCmd
    toolName=$(@ "$_RECEIVER" name)
    toolPath=$(@ "$_RECEIVER" path)

    if [[ -z "$toolPath" ]]; then
      _throw "ToolError" "$toolName is not installed"
      echo ""
      return
    fi

    futureCmd="${toolPath} ${args}"
    @ Future value: "$futureCmd"
  ]

  # Check if a command exists on the system (utility method)
  primitiveClassMethod: commandExists: commandName [
    local commandName="$1" checkCmd
    checkCmd="command -v ${commandName}"
    @ Shell succeeds: "$checkCmd"
  ]
__TRASHTALK_SOURCE_EOF__
}

__Tool__class__name() {
  echo """"; return
}

__Tool__class__installCommand() {
  echo """"; return
}

__Tool__class__isInstalled() {
  local toolName checkCmd
  toolName=$(@ "$_RECEIVER" name)
  checkCmd="command -v ${toolName}"
  @ Shell succeeds: "$checkCmd"
}

__Tool__class__path() {
  local toolName checkCmd
  toolName=$(@ "$_RECEIVER" name)
  checkCmd="command -v ${toolName}"
  @ Shell exec: "$checkCmd"
}

__Tool__class__version() {
  local toolName toolPath versionCmd result
  toolName=$(@ "$_RECEIVER" name)
  toolPath=$(@ "$_RECEIVER" path)
  if [[ -z "$toolPath" ]] ; then
  echo "not installed"
  return
  fi
  # Try --version first
  versionCmd="${toolPath} --version 2>/dev/null | head -1"
  result=$(@ Shell exec: "$versionCmd")
  if [[ -n "$result" ]] ; then echo "$result" ; return ; fi
  # Try -version
  versionCmd="${toolPath} -version 2>/dev/null | head -1"
  result=$(@ Shell exec: "$versionCmd")
  if [[ -n "$result" ]] ; then echo "$result" ; return ; fi
  # Try -V
  versionCmd="${toolPath} -V 2>/dev/null | head -1"
  result=$(@ Shell exec: "$versionCmd")
  if [[ -n "$result" ]] ; then echo "$result" ; return ; fi
  echo "unknown"
}

__Tool__class__install() {
  local installCmd toolName
  installCmd=$(@ "$_RECEIVER" installCommand)
  toolName=$(@ "$_RECEIVER" name)
  if [[ -z "$installCmd" ]] ; then
  _throw "InstallError" "No install command defined for $toolName"
  echo ""
  return
  fi
  @ Console print: "Installing $toolName..."
  if @ Shell succeeds: "$installCmd" ; then
  @ Console print: "Successfully installed $toolName"
  echo "true"
  else
  _throw "InstallError" "Failed to install $toolName"
  echo ""
  fi
}

__Tool__class__ensure() {
  local toolName isInstalledVal
  toolName=$(@ "$_RECEIVER" name)
  if [[ -z "$toolName" ]] ; then
  _throw "ToolError" "Tool name not set"
  echo ""
  return
  fi
  # Check if already installed
  isInstalledVal=$(@ "$_RECEIVER" isInstalled)
  if [[ "$isInstalledVal" == "true" ]] ; then
  echo "true"
  return
  fi
  # Try to install
  @ Console error: "$toolName not found, attempting install..."
  @ "$_RECEIVER" install
  # Refresh command hash table
  @ Shell silent: "hash -r"
  # Verify installation succeeded
  isInstalledVal=$(@ "$_RECEIVER" isInstalled)
  if [[ "$isInstalledVal" == "true" ]] ; then
  echo "true"
  else
  _throw "PathError" "$toolName installed but not found on PATH"
  echo ""
  fi
}

__Tool__class__run_() {
  local args="$1"
  local args="$1" toolName toolPath runCmd
  toolName=$(@ "$_RECEIVER" name)
  toolPath=$(@ "$_RECEIVER" path)
  if [[ -z "$toolPath" ]] ; then
  _throw "ToolError" "$toolName is not installed"
  echo ""
  return
  fi
  runCmd="${toolPath} ${args}"
  @ Shell exec: "$runCmd"
}

__Tool__class__runCapture_() {
  local args="$1"
  local args="$1" toolName toolPath runCmd
  toolName=$(@ "$_RECEIVER" name)
  toolPath=$(@ "$_RECEIVER" path)
  if [[ -z "$toolPath" ]] ; then
  _throw "ToolError" "$toolName is not installed"
  echo ""
  return
  fi
  runCmd="${toolPath} ${args}"
  @ Shell execAll: "$runCmd"
}

__Tool__class__runAsync_() {
  local args="$1"
  local args="$1" toolName toolPath futureCmd
  toolName=$(@ "$_RECEIVER" name)
  toolPath=$(@ "$_RECEIVER" path)
  if [[ -z "$toolPath" ]] ; then
  _throw "ToolError" "$toolName is not installed"
  echo ""
  return
  fi
  futureCmd="${toolPath} ${args}"
  @ Future value: "$futureCmd"
}

__Tool__class__commandExists_() {
  local commandName="$1"
  local commandName="$1" checkCmd
  checkCmd="command -v ${commandName}"
  @ Shell succeeds: "$checkCmd"
}

