#!/usr/bin/env bash
# Generated by Trashtalk Compiler (jq) - DO NOT EDIT
# Source: Tool.trash
# Generated: 2026-01-09T15:38:42

__Tool__superclass="Object"
__Tool__instanceVars=""
__Tool__classInstanceVars=""
__Tool__traits=""
__Tool__sourceHash="3da4abc6f45e809b2a7c5b9c064e183103ec3f876cbf709c2a955a93e8932f19"

__Tool__source() {
  cat <<'__TRASHTALK_SOURCE_EOF__'
# Tool - Abstract base class for wrapping external command-line tools
# Provides detection, installation, and execution of external programs
#
# Tool subclasses are singletons - use class methods directly:
#   @ JqTool ensure
#   @ JqTool run: '.foo'
#
# Subclass example:
#   JqTool subclass: Tool
#     classMethod: name [ ^ "jq" ]
#     classMethod: installCommand [ ^ "brew install jq" ]
#
Tool subclass: Object

  # Override in subclasses to return the command name
  classMethod: name [
    ^ ""
  ]

  # Override in subclasses to return the install command
  # e.g., "brew install jq" or "apt-get install -y jq"
  classMethod: installCommand [
    ^ ""
  ]

  # Check if the tool is installed and on PATH
  rawClassMethod: isInstalled [
    local tool_name
    tool_name=$(@ "$_CLASS" name)
    if command -v "$tool_name" >/dev/null 2>&1; then
      echo "true"
    else
      echo "false"
    fi
  ]

  # Get the path to the tool executable
  rawClassMethod: path [
    local tool_name
    tool_name=$(@ "$_CLASS" name)
    command -v "$tool_name" 2>/dev/null
  ]

  # Get the version of the tool (override for tool-specific parsing)
  rawClassMethod: version [
    local tool_name tool_path
    tool_name=$(@ "$_CLASS" name)
    tool_path=$(command -v "$tool_name" 2>/dev/null)
    if [[ -z "$tool_path" ]]; then
      echo "not installed"
      return 1
    fi
    # Try common version flags
    "$tool_path" --version 2>/dev/null | head -1 || \
    "$tool_path" -version 2>/dev/null | head -1 || \
    "$tool_path" -V 2>/dev/null | head -1 || \
    echo "unknown"
  ]

  # Install the tool - override in subclasses for custom behavior
  rawClassMethod: install [
    local install_cmd
    install_cmd=$(@ "$_CLASS" installCommand)
    if [[ -z "$install_cmd" ]]; then
      _throw "InstallError" "No install command defined for $(@ "$_CLASS" name)"
      return 1
    fi
    echo "Installing $(@ "$_CLASS" name)..."
    if eval "$install_cmd"; then
      echo "Successfully installed $(@ "$_CLASS" name)"
      return 0
    else
      _throw "InstallError" "Failed to install $(@ "$_CLASS" name)"
      return 1
    fi
  ]

  # Ensure the tool is installed and available
  # - Checks if installed
  # - Installs if not
  # - Verifies it's on PATH after install
  # Returns: "true" on success, throws error on failure
  rawClassMethod: ensure [
    local tool_name is_installed
    tool_name=$(@ "$_CLASS" name)

    if [[ -z "$tool_name" ]]; then
      _throw "ToolError" "Tool name not set"
      return 1
    fi

    # Check if already installed
    is_installed=$(@ "$_CLASS" isInstalled)
    if [[ "$is_installed" == "true" ]]; then
      echo "true"
      return 0
    fi

    # Try to install
    echo "$tool_name not found, attempting install..." >&2
    if ! @ "$_CLASS" install; then
      # install already threw an error
      return 1
    fi

    # Verify installation succeeded
    # Refresh command hash table
    hash -r 2>/dev/null

    is_installed=$(@ "$_CLASS" isInstalled)
    if [[ "$is_installed" == "true" ]]; then
      echo "true"
      return 0
    else
      _throw "PathError" "$tool_name installed but not found on PATH"
      return 1
    fi
  ]

  # Run the tool with arguments (synchronous)
  rawClassMethod: run: args [
    local tool_name tool_path
    tool_name=$(@ "$_CLASS" name)
    tool_path=$(command -v "$tool_name" 2>/dev/null)

    if [[ -z "$tool_path" ]]; then
      _throw "ToolError" "$tool_name is not installed"
      return 1
    fi

    "$tool_path" $1
  ]

  # Run the tool with arguments, capturing stdout
  rawClassMethod: runCapture: args [
    local tool_name tool_path result
    tool_name=$(@ "$_CLASS" name)
    tool_path=$(command -v "$tool_name" 2>/dev/null)

    if [[ -z "$tool_path" ]]; then
      _throw "ToolError" "$tool_name is not installed"
      return 1
    fi

    result=$("$tool_path" $1 2>&1)
    echo "$result"
  ]

  # Run the tool asynchronously, returning a Future
  rawClassMethod: runAsync: args [
    local tool_name tool_path
    tool_name=$(@ "$_CLASS" name)
    tool_path=$(command -v "$tool_name" 2>/dev/null)

    if [[ -z "$tool_path" ]]; then
      _throw "ToolError" "$tool_name is not installed"
      return 1
    fi

    @ Future value: "$tool_path $1"
  ]

  # Check if a command exists on the system (utility method)
  rawClassMethod: commandExists: commandName [
    if command -v "$1" >/dev/null 2>&1; then
      echo "true"
    else
      echo "false"
    fi
  ]
__TRASHTALK_SOURCE_EOF__
}

__Tool__class__name() {
  echo ""
}

__Tool__class__installCommand() {
  echo ""
}

__Tool__class__isInstalled() {
    local tool_name
    tool_name=$(@ "$_CLASS" name)
    if command -v "$tool_name" >/dev/null 2>&1; then
        echo "true"
        else
        echo "false"
    fi
}

__Tool__class__path() {
    local tool_name
    tool_name=$(@ "$_CLASS" name)
    command -v "$tool_name" 2>/dev/null
}

__Tool__class__version() {
    local tool_name tool_path
    tool_name=$(@ "$_CLASS" name)
    tool_path=$(command -v "$tool_name" 2>/dev/null)
    if [[ -z "$tool_path" ]]; then
        echo "not installed"
        return 1
    fi
    # Try common version flags
    "$tool_path" --version 2>/dev/null | head -1 || \
        "$tool_path" -version 2>/dev/null | head -1 || \
        "$tool_path" -V 2>/dev/null | head -1 || \
        echo "unknown"
}

__Tool__class__install() {
    local install_cmd
    install_cmd=$(@ "$_CLASS" installCommand)
    if [[ -z "$install_cmd" ]]; then
        _throw "InstallError" "No install command defined for $(@ "$_CLASS" name)"
        return 1
    fi
    echo "Installing $(@ "$_CLASS" name)..."
    if eval "$install_cmd"; then
        echo "Successfully installed $(@ "$_CLASS" name)"
        return 0
        else
        _throw "InstallError" "Failed to install $(@ "$_CLASS" name)"
        return 1
    fi
}

__Tool__class__ensure() {
    local tool_name is_installed
    tool_name=$(@ "$_CLASS" name)

    if [[ -z "$tool_name" ]]; then
        _throw "ToolError" "Tool name not set"
        return 1
    fi

    # Check if already installed
    is_installed=$(@ "$_CLASS" isInstalled)
    if [[ "$is_installed" == "true" ]]; then
        echo "true"
        return 0
    fi

    # Try to install
    echo "$tool_name not found, attempting install..." >&2
    if ! @ "$_CLASS" install; then
        # install already threw an error
        return 1
    fi

    # Verify installation succeeded
    # Refresh command hash table
    hash -r 2>/dev/null

    is_installed=$(@ "$_CLASS" isInstalled)
    if [[ "$is_installed" == "true" ]]; then
        echo "true"
        return 0
        else
        _throw "PathError" "$tool_name installed but not found on PATH"
        return 1
    fi
}

__Tool__class__run_() {
  local args="$1"
    local tool_name tool_path
    tool_name=$(@ "$_CLASS" name)
    tool_path=$(command -v "$tool_name" 2>/dev/null)

    if [[ -z "$tool_path" ]]; then
        _throw "ToolError" "$tool_name is not installed"
        return 1
    fi

    "$tool_path" $1
}

__Tool__class__runCapture_() {
  local args="$1"
    local tool_name tool_path result
    tool_name=$(@ "$_CLASS" name)
    tool_path=$(command -v "$tool_name" 2>/dev/null)

    if [[ -z "$tool_path" ]]; then
        _throw "ToolError" "$tool_name is not installed"
        return 1
    fi

    result=$("$tool_path" $1 2>&1)
    echo "$result"
}

__Tool__class__runAsync_() {
  local args="$1"
    local tool_name tool_path
    tool_name=$(@ "$_CLASS" name)
    tool_path=$(command -v "$tool_name" 2>/dev/null)

    if [[ -z "$tool_path" ]]; then
        _throw "ToolError" "$tool_name is not installed"
        return 1
    fi

    @ Future value: "$tool_path $1"
}

__Tool__class__commandExists_() {
  local commandName="$1"
    if command -v "$1" >/dev/null 2>&1; then
        echo "true"
        else
        echo "false"
    fi
}
