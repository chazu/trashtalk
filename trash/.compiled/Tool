#!/usr/bin/env bash
# Generated by Trashtalk Compiler (jq) - DO NOT EDIT
# Source: Tool.trash
# Generated: 2026-01-12T21:20:06

__Tool__superclass="Object"
__Tool__instanceVars=""
__Tool__classInstanceVars=""
__Tool__traits=""
__Tool__sourceHash="5810d847b259a6362fa5637399425fd32807510069eae8d23d6a245c4db3349a"
__Tool__primitiveClass="1"

__Tool__source() {
  cat <<'__TRASHTALK_SOURCE_EOF__'
# Tool - Abstract base class for wrapping external command-line tools
# Provides detection, installation, and execution of external programs
# Built on Shell primitives - no raw bash required.
#
# Tool subclasses are singletons - use class methods directly:
#   @ JqTool ensure
#   @ JqTool run: '.foo'
#
# Subclass example:
#   JqTool subclass: Tool
#     classMethod: name [ ^ "jq" ]
#     classMethod: installCommand [ ^ "brew install jq" ]
#
Tool subclass: Object
  pragma: primitiveClass

  # Override in subclasses to return the command name
  classMethod: name [
    echo ""
  ]

  # Override in subclasses to return the install command
  # e.g., "brew install jq" or "apt-get install -y jq"
  classMethod: installCommand [
    echo ""
  ]

  # Check if the tool is installed and on PATH
  classMethod: isInstalled [
    local toolName checkCmd
    toolName=$(@ "$_RECEIVER" name)
    checkCmd="command -v ${toolName}"
    @ Shell succeeds: "$checkCmd"
  ]

  # Get the path to the tool executable
  classMethod: path [
    local toolName checkCmd
    toolName=$(@ "$_RECEIVER" name)
    checkCmd="command -v ${toolName}"
    @ Shell exec: "$checkCmd"
  ]

  # Get the version of the tool (override for tool-specific parsing)
  classMethod: version [
    local toolName toolPath versionCmd result
    toolName=$(@ "$_RECEIVER" name)
    toolPath=$(@ "$_RECEIVER" path)

    if [[ -z "$toolPath" ]]; then
      echo "not installed"
      return
    fi

    # Try --version first
    versionCmd="${toolPath} --version 2>/dev/null | head -1"
    result=$(@ Shell exec: "$versionCmd")
    if [[ -n "$result" ]]; then echo "$result"; return; fi

    # Try -version
    versionCmd="${toolPath} -version 2>/dev/null | head -1"
    result=$(@ Shell exec: "$versionCmd")
    if [[ -n "$result" ]]; then echo "$result"; return; fi

    # Try -V
    versionCmd="${toolPath} -V 2>/dev/null | head -1"
    result=$(@ Shell exec: "$versionCmd")
    if [[ -n "$result" ]]; then echo "$result"; return; fi

    echo "unknown"
  ]

  # Install the tool - override in subclasses for custom behavior
  classMethod: install [
    local installCmd toolName
    installCmd=$(@ "$_RECEIVER" installCommand)
    toolName=$(@ "$_RECEIVER" name)

    if [[ -z "$installCmd" ]]; then
      _throw "InstallError" "No install command defined for $toolName"
      echo ""
      return
    fi

    @ Console print: "Installing $toolName..."

    if @ Shell succeeds: "$installCmd"; then
      @ Console print: "Successfully installed $toolName"
      echo "true"
    else
      _throw "InstallError" "Failed to install $toolName"
      echo ""
    fi
  ]

  # Ensure the tool is installed and available
  # - Checks if installed
  # - Installs if not
  # - Verifies it's on PATH after install
  # Returns: "true" on success, throws error on failure
  classMethod: ensure [
    local toolName isInstalledVal
    toolName=$(@ "$_RECEIVER" name)

    if [[ -z "$toolName" ]]; then
      _throw "ToolError" "Tool name not set"
      echo ""
      return
    fi

    # Check if already installed
    isInstalledVal=$(@ "$_RECEIVER" isInstalled)
    if [[ "$isInstalledVal" == "true" ]]; then
      echo "true"
      return
    fi

    # Try to install
    @ Console error: "$toolName not found, attempting install..."
    @ "$_RECEIVER" install

    # Refresh command hash table
    @ Shell silent: "hash -r"

    # Verify installation succeeded
    isInstalledVal=$(@ "$_RECEIVER" isInstalled)
    if [[ "$isInstalledVal" == "true" ]]; then
      echo "true"
    else
      _throw "PathError" "$toolName installed but not found on PATH"
      echo ""
    fi
  ]

  # Run the tool with arguments (synchronous)
  classMethod: run: args [
    local args="$1" toolName toolPath runCmd
    toolName=$(@ "$_RECEIVER" name)
    toolPath=$(@ "$_RECEIVER" path)

    if [[ -z "$toolPath" ]]; then
      _throw "ToolError" "$toolName is not installed"
      echo ""
      return
    fi

    runCmd="${toolPath} ${args}"
    @ Shell exec: "$runCmd"
  ]

  # Run the tool with arguments, capturing stdout and stderr
  classMethod: runCapture: args [
    local args="$1" toolName toolPath runCmd
    toolName=$(@ "$_RECEIVER" name)
    toolPath=$(@ "$_RECEIVER" path)

    if [[ -z "$toolPath" ]]; then
      _throw "ToolError" "$toolName is not installed"
      echo ""
      return
    fi

    runCmd="${toolPath} ${args}"
    @ Shell execAll: "$runCmd"
  ]

  # Run the tool asynchronously, returning a Future
  classMethod: runAsync: args [
    local args="$1" toolName toolPath futureCmd
    toolName=$(@ "$_RECEIVER" name)
    toolPath=$(@ "$_RECEIVER" path)

    if [[ -z "$toolPath" ]]; then
      _throw "ToolError" "$toolName is not installed"
      echo ""
      return
    fi

    futureCmd="${toolPath} ${args}"
    @ Future value: "$futureCmd"
  ]

  # Check if a command exists on the system (utility method)
  classMethod: commandExists: commandName [
    local commandName="$1" checkCmd
    checkCmd="command -v ${commandName}"
    @ Shell succeeds: "$checkCmd"
  ]
__TRASHTALK_SOURCE_EOF__
}

__Tool__class__name() {
    echo ""
}

__Tool__class__installCommand() {
    echo ""
}

__Tool__class__isInstalled() {
    local toolName checkCmd
    toolName=$(@ "$_RECEIVER" name)
    checkCmd="command -v ${toolName}"
    @ Shell succeeds: "$checkCmd"
}

__Tool__class__path() {
    local toolName checkCmd
    toolName=$(@ "$_RECEIVER" name)
    checkCmd="command -v ${toolName}"
    @ Shell exec: "$checkCmd"
}

__Tool__class__version() {
    local toolName toolPath versionCmd result
    toolName=$(@ "$_RECEIVER" name)
    toolPath=$(@ "$_RECEIVER" path)

    if [[ -z "$toolPath" ]]; then
        echo "not installed"
        return
    fi

    # Try --version first
    versionCmd="${toolPath} --version 2>/dev/null | head -1"
    result=$(@ Shell exec: "$versionCmd")
    if [[ -n "$result" ]]; then echo "$result"; return; fi

    # Try -version
    versionCmd="${toolPath} -version 2>/dev/null | head -1"
    result=$(@ Shell exec: "$versionCmd")
    if [[ -n "$result" ]]; then echo "$result"; return; fi

    # Try -V
    versionCmd="${toolPath} -V 2>/dev/null | head -1"
    result=$(@ Shell exec: "$versionCmd")
    if [[ -n "$result" ]]; then echo "$result"; return; fi

    echo "unknown"
}

__Tool__class__install() {
    local installCmd toolName
    installCmd=$(@ "$_RECEIVER" installCommand)
    toolName=$(@ "$_RECEIVER" name)

    if [[ -z "$installCmd" ]]; then
        _throw "InstallError" "No install command defined for $toolName"
        echo ""
        return
    fi

    @ Console print: "Installing $toolName..."

    if @ Shell succeeds: "$installCmd"; then
        @ Console print: "Successfully installed $toolName"
        echo "true"
        else
        _throw "InstallError" "Failed to install $toolName"
        echo ""
    fi
}

__Tool__class__ensure() {
    local toolName isInstalledVal
    toolName=$(@ "$_RECEIVER" name)

    if [[ -z "$toolName" ]]; then
        _throw "ToolError" "Tool name not set"
        echo ""
        return
    fi

    # Check if already installed
    isInstalledVal=$(@ "$_RECEIVER" isInstalled)
    if [[ "$isInstalledVal" == "true" ]]; then
        echo "true"
        return
    fi

    # Try to install
    @ Console error: "$toolName not found, attempting install..."
    @ "$_RECEIVER" install

    # Refresh command hash table
    @ Shell silent: "hash -r"

    # Verify installation succeeded
    isInstalledVal=$(@ "$_RECEIVER" isInstalled)
    if [[ "$isInstalledVal" == "true" ]]; then
        echo "true"
        else
        _throw "PathError" "$toolName installed but not found on PATH"
        echo ""
    fi
}

__Tool__class__run_() {
  local args="$1"
    local args="$1" toolName toolPath runCmd
    toolName=$(@ "$_RECEIVER" name)
    toolPath=$(@ "$_RECEIVER" path)

    if [[ -z "$toolPath" ]]; then
        _throw "ToolError" "$toolName is not installed"
        echo ""
        return
    fi

    runCmd="${toolPath} ${args}"
    @ Shell exec: "$runCmd"
}

__Tool__class__runCapture_() {
  local args="$1"
    local args="$1" toolName toolPath runCmd
    toolName=$(@ "$_RECEIVER" name)
    toolPath=$(@ "$_RECEIVER" path)

    if [[ -z "$toolPath" ]]; then
        _throw "ToolError" "$toolName is not installed"
        echo ""
        return
    fi

    runCmd="${toolPath} ${args}"
    @ Shell execAll: "$runCmd"
}

__Tool__class__runAsync_() {
  local args="$1"
    local args="$1" toolName toolPath futureCmd
    toolName=$(@ "$_RECEIVER" name)
    toolPath=$(@ "$_RECEIVER" path)

    if [[ -z "$toolPath" ]]; then
        _throw "ToolError" "$toolName is not installed"
        echo ""
        return
    fi

    futureCmd="${toolPath} ${args}"
    @ Future value: "$futureCmd"
}

__Tool__class__commandExists_() {
  local commandName="$1"
    local commandName="$1" checkCmd
    checkCmd="command -v ${commandName}"
    @ Shell succeeds: "$checkCmd"
}
