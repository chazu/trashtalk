#!/usr/bin/env bash
# Generated by Trashtalk Compiler (jq) - DO NOT EDIT
# Source: Http.trash
# Generated: 2026-01-12T21:18:22

__Http__superclass="Object"
__Http__instanceVars=""
__Http__classInstanceVars=""
__Http__traits=""
__Http__sourceHash="1384fcb10e8d55f28adfb2ed0b5220cb9854ebd4aad4ad06c2fdaf6f296bfc62"
__Http__primitiveClass="1"

__Http__source() {
  cat <<'__TRASHTALK_SOURCE_EOF__'
# Http - HTTP client primitive class
# Provides HTTP operations using curl
#
# Usage:
#   response := @ Http get: 'https://api.example.com/data'
#   response := @ Http post: '{"name":"test"}' to: 'https://api.example.com/data'
#   status := @ Http status: 'https://example.com'
#
Http subclass: Object
  pragma: primitiveClass

  # ==========================================
  # Basic Methods
  # ==========================================

  # Simple GET request
  # Usage: response := @ Http get: 'https://api.example.com/data'
  classMethod: get: url [
    curl -s "$1"
  ]

  # Simple POST request with JSON body
  # Usage: response := @ Http post: '{"name":"test"}' to: 'https://api.example.com'
  classMethod: post: data to: url [
    curl -s -X POST -H "Content-Type: application/json" -d "$1" "$2"
  ]

  # Simple PUT request with JSON body
  # Usage: response := @ Http put: '{"name":"updated"}' to: 'https://api.example.com/1'
  classMethod: put: data to: url [
    curl -s -X PUT -H "Content-Type: application/json" -d "$1" "$2"
  ]

  # Simple PATCH request with JSON body
  # Usage: response := @ Http patch: '{"name":"patched"}' to: 'https://api.example.com/1'
  classMethod: patch: data to: url [
    curl -s -X PATCH -H "Content-Type: application/json" -d "$1" "$2"
  ]

  # Simple DELETE request
  # Usage: response := @ Http delete: 'https://api.example.com/1'
  classMethod: delete: url [
    curl -s -X DELETE "$1"
  ]

  # HEAD request (headers only)
  # Usage: headers := @ Http head: 'https://example.com'
  classMethod: head: url [
    curl -sI "$1"
  ]

  # ==========================================
  # Status and Metadata
  # ==========================================

  # Get HTTP status code only
  # Usage: status := @ Http status: 'https://example.com'
  classMethod: status: url [
    curl -s -o /dev/null -w "%{http_code}" "$1"
  ]

  # Check if URL is reachable (returns true/false)
  # Usage: ok := @ Http ping: 'https://example.com'
  classMethod: ping: url [
    local status
    status=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 5 "$1")
    if [[ "$status" -ge 200 && "$status" -lt 400 ]]; then
      echo "true"
    else
      echo "false"
    fi
  ]

  # Get response with headers
  # Usage: response := @ Http getWithHeaders: 'https://api.example.com'
  classMethod: getWithHeaders: url [
    curl -si "$1"
  ]

  # ==========================================
  # With Headers
  # ==========================================

  # GET with custom header
  # Usage: response := @ Http get: url header: 'X-Custom: value'
  classMethod: get: url header: header [
    curl -s -H "$2" "$1"
  ]

  # GET with multiple headers (as JSON object)
  # Usage: response := @ Http get: url headers: '{"X-Api-Key":"abc","Accept":"application/json"}'
  classMethod: get: url headers: headersJson [
    local args="-s"
    while IFS= read -r header; do
      args="$args -H \"$header\""
    done < <(echo "$2" | jq -r 'to_entries | .[] | "\(.key): \(.value)"')
    eval "curl $args \"$1\""
  ]

  # POST with custom headers
  # Usage: response := @ Http post: data to: url headers: '{"Authorization":"Bearer token"}'
  classMethod: post: data to: url headers: headersJson [
    local args="-s -X POST -H \"Content-Type: application/json\""
    while IFS= read -r header; do
      args="$args -H \"$header\""
    done < <(echo "$3" | jq -r 'to_entries | .[] | "\(.key): \(.value)"')
    eval "curl $args -d '$1' \"$2\""
  ]

  # ==========================================
  # Authentication
  # ==========================================

  # GET with Bearer token
  # Usage: response := @ Http get: url token: 'abc123'
  classMethod: get: url token: token [
    curl -s -H "Authorization: Bearer $2" "$1"
  ]

  # POST with Bearer token
  # Usage: response := @ Http post: data to: url token: 'abc123'
  classMethod: post: data to: url token: token [
    curl -s -X POST -H "Content-Type: application/json" -H "Authorization: Bearer $3" -d "$1" "$2"
  ]

  # GET with Basic auth
  # Usage: response := @ Http get: url user: 'admin' password: 'secret'
  classMethod: get: url user: username password: password [
    curl -s -u "$2:$3" "$1"
  ]

  # ==========================================
  # File Operations
  # ==========================================

  # Download file to path
  # Usage: filepath := @ Http download: url to: '/tmp/file.zip'
  classMethod: download: url to: filepath [
    if curl -s -o "$2" "$1"; then
      echo "$2"
    else
      echo ""
    fi
  ]

  # Upload file
  # Usage: response := @ Http upload: '/tmp/file.txt' to: url
  classMethod: upload: filepath to: url [
    curl -s -X POST -F "file=@$1" "$2"
  ]

  # Upload file with field name
  # Usage: response := @ Http upload: '/tmp/file.txt' as: 'document' to: url
  classMethod: upload: filepath as: fieldName to: url [
    curl -s -X POST -F "$2=@$1" "$3"
  ]

  # ==========================================
  # Form Data
  # ==========================================

  # POST form data (application/x-www-form-urlencoded)
  # Usage: response := @ Http postForm: 'name=test&value=123' to: url
  classMethod: postForm: data to: url [
    curl -s -X POST -d "$1" "$2"
  ]

  # POST multipart form data
  # Usage: response := @ Http postMultipart: '{"field1":"value1","field2":"value2"}' to: url
  classMethod: postMultipart: fieldsJson to: url [
    local args="-s -X POST"
    while IFS= read -r field; do
      args="$args -F \"$field\""
    done < <(echo "$1" | jq -r 'to_entries | .[] | "\(.key)=\(.value)"')
    eval "curl $args \"$2\""
  ]

  # ==========================================
  # Advanced Options
  # ==========================================

  # GET with timeout
  # Usage: response := @ Http get: url timeout: 10
  classMethod: get: url timeout: seconds [
    curl -s --connect-timeout "$2" --max-time "$2" "$1"
  ]

  # GET following redirects
  # Usage: response := @ Http getFollowRedirects: url
  classMethod: getFollowRedirects: url [
    curl -sL "$1"
  ]

  # GET with retry
  # Usage: response := @ Http get: url retries: 3
  classMethod: get: url retries: count [
    curl -s --retry "$2" "$1"
  ]

  # ==========================================
  # Full Response
  # ==========================================

  # GET with full response info as JSON
  # Usage: info := @ Http getFull: url
  classMethod: getFull: url [
    local body status time_total
    local tmp="/tmp/http_$$_body"

    status=$(curl -s -o "$tmp" -w "%{http_code}" "$1")
    body=$(cat "$tmp" 2>/dev/null)
    rm -f "$tmp"

    jo body="$body" status="$status"
  ]

  # GET with timing info as JSON
  # Usage: timing := @ Http getTiming: url
  classMethod: getTiming: url [
    curl -s -o /dev/null -w '{
      "status": %{http_code},
      "time_namelookup": %{time_namelookup},
      "time_connect": %{time_connect},
      "time_appconnect": %{time_appconnect},
      "time_pretransfer": %{time_pretransfer},
      "time_starttransfer": %{time_starttransfer},
      "time_total": %{time_total},
      "size_download": %{size_download}
    }' "$1"
  ]
__TRASHTALK_SOURCE_EOF__
}

__Http__class__get_() {
  local url="$1"
    curl -s "$1"
}

__Http__class__post_to_() {
  local data="$1"
  local url="$2"
    curl -s -X POST -H "Content-Type: application/json" -d "$1" "$2"
}

__Http__class__put_to_() {
  local data="$1"
  local url="$2"
    curl -s -X PUT -H "Content-Type: application/json" -d "$1" "$2"
}

__Http__class__patch_to_() {
  local data="$1"
  local url="$2"
    curl -s -X PATCH -H "Content-Type: application/json" -d "$1" "$2"
}

__Http__class__delete_() {
  local url="$1"
    curl -s -X DELETE "$1"
}

__Http__class__head_() {
  local url="$1"
    curl -sI "$1"
}

__Http__class__status_() {
  local url="$1"
    curl -s -o /dev/null -w "%{http_code}" "$1"
}

__Http__class__ping_() {
  local url="$1"
    local status
    status=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 5 "$1")
    if [[ "$status" -ge 200 && "$status" -lt 400 ]]; then
        echo "true"
        else
        echo "false"
    fi
}

__Http__class__getWithHeaders_() {
  local url="$1"
    curl -si "$1"
}

__Http__class__get_header_() {
  local url="$1"
  local header="$2"
    curl -s -H "$2" "$1"
}

__Http__class__get_headers_() {
  local url="$1"
  local headersJson="$2"
    local args="-s"
    while IFS= read -r header; do
        args="$args -H \" $header \""
    done < <(echo "$2" | jq -r 'to_entries | .[] | "\(.key): \(.value)"')
        eval "curl $args \" $1 \""
}

__Http__class__post_to_headers_() {
  local data="$1"
  local url="$2"
  local headersJson="$3"
    local args="-s -X POST -H \" Content -Type: application /json \""
    while IFS= read -r header; do
        args="$args -H \" $header \""
    done < <(echo "$3" | jq -r 'to_entries | .[] | "\(.key): \(.value)"')
        eval "curl $args -d '$1' \" $2 \""
}

__Http__class__get_token_() {
  local url="$1"
  local token="$2"
    curl -s -H "Authorization: Bearer $2" "$1"
}

__Http__class__post_to_token_() {
  local data="$1"
  local url="$2"
  local token="$3"
    curl -s -X POST -H "Content-Type: application/json" -H "Authorization: Bearer $3" -d "$1" "$2"
}

__Http__class__get_user_password_() {
  local url="$1"
  local username="$2"
  local password="$3"
    curl -s -u "$2:$3" "$1"
}

__Http__class__download_to_() {
  local url="$1"
  local filepath="$2"
    if curl -s -o "$2" "$1"; then
        echo "$2"
        else
        echo ""
    fi
}

__Http__class__upload_to_() {
  local filepath="$1"
  local url="$2"
    curl -s -X POST -F "file=@$1" "$2"
}

__Http__class__upload_as_to_() {
  local filepath="$1"
  local fieldName="$2"
  local url="$3"
    curl -s -X POST -F "$2=@$1" "$3"
}

__Http__class__postForm_to_() {
  local data="$1"
  local url="$2"
    curl -s -X POST -d "$1" "$2"
}

__Http__class__postMultipart_to_() {
  local fieldsJson="$1"
  local url="$2"
    local args="-s -X POST"
    while IFS= read -r field; do
        args="$args -F \" $field \""
    done < <(echo "$1" | jq -r 'to_entries | .[] | "\(.key)=\(.value)"')
        eval "curl $args \" $2 \""
}

__Http__class__get_timeout_() {
  local url="$1"
  local seconds="$2"
    curl -s --connect -timeout "$2" --max -time "$2" "$1"
}

__Http__class__getFollowRedirects_() {
  local url="$1"
    curl -sL "$1"
}

__Http__class__get_retries_() {
  local url="$1"
  local count="$2"
    curl -s --retry "$2" "$1"
}

__Http__class__getFull_() {
  local url="$1"
    local body status time_total
    local tmp="/tmp/http_$$_body"

    status=$(curl -s -o "$tmp" -w "%{http_code}" "$1")
    body=$(cat "$tmp" 2>/dev/null)
    rm -f "$tmp"

    jo body="$body" status="$status"
}

__Http__class__getTiming_() {
  local url="$1"
    curl -s -o /dev/null -w '{
    "status": %{http_code},
    "time_namelookup": %{time_namelookup},
    "time_connect": %{time_connect},
    "time_appconnect": %{time_appconnect},
    "time_pretransfer": %{time_pretransfer},
    "time_starttransfer": %{time_starttransfer},
    "time_total": %{time_total},
    "size_download": %{size_download}
    }' "$1"
}
