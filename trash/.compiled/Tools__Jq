#!/usr/bin/env bash
# Generated by Trashtalk Compiler (jq) - DO NOT EDIT
# Source: Jq.trash
# Generated: 2026-01-12T22:52:36

__Tools__Jq__superclass="Tool"
__Tools__Jq__instanceVars=""
__Tools__Jq__classInstanceVars=""
__Tools__Jq__traits=""
__Tools__Jq__sourceHash="19959a4279cd27cfe71539950803e4c26bef2dee0a27d1f5164b49f9a8e9501d"
__Tools__Jq__package="Tools"
__Tools__Jq__qualifiedName="Tools::Jq"
__Tools__Jq__primitiveClass="1"

__Tools__Jq__source() {
  cat <<'__TRASHTALK_SOURCE_EOF__'
# Tools::Jq - Wrapper for the jq JSON processor
# Example of how to subclass Tool for a specific external program
# Built on Tool/Shell primitives - no raw bash required.
#
# Usage:
#   @ Tools::Jq ensure
#   @ Tools::Jq parse: '.name' on: '{"name": "test"}'
#
package: Tools

Jq subclass: Tool
  pragma: primitiveClass

  classMethod: name [
    echo "jq"
  ]

  classMethod: installCommand [
    echo "brew install jq"
  ]

  # Parse JSON with a jq filter
  classMethod: parse: filter on: json [
    local filter="$1" json="$2" toolPath cmd
    toolPath=$(@ "$_RECEIVER" path)

    if [[ -z "$toolPath" ]]; then
      _throw "ToolError" "jq is not installed"
      echo ""
      return
    fi

    cmd="echo '${json}' | ${toolPath} '${filter}'"
    @ Shell exec: "$cmd"
  ]

  # Parse JSON from a file
  classMethod: parseFile: filepath with: filter [
    local filepath="$1" filter="$2" toolPath cmd
    toolPath=$(@ "$_RECEIVER" path)

    if [[ -z "$toolPath" ]]; then
      _throw "ToolError" "jq is not installed"
      echo ""
      return
    fi

    cmd="${toolPath} '${filter}' ${filepath}"
    @ Shell exec: "$cmd"
  ]

  # Compact output (no pretty printing)
  classMethod: compact: json [
    local json="$1" toolPath cmd
    toolPath=$(@ "$_RECEIVER" path)

    if [[ -z "$toolPath" ]]; then
      _throw "ToolError" "jq is not installed"
      echo ""
      return
    fi

    cmd="echo '${json}' | ${toolPath} -c '.'"
    @ Shell exec: "$cmd"
  ]

  # Get a specific key from JSON (raw output)
  classMethod: get: key from: json [
    local key="$1" json="$2" toolPath cmd
    toolPath=$(@ "$_RECEIVER" path)

    if [[ -z "$toolPath" ]]; then
      _throw "ToolError" "jq is not installed"
      echo ""
      return
    fi

    cmd="echo '${json}' | ${toolPath} -r '.${key}'"
    @ Shell exec: "$cmd"
  ]
__TRASHTALK_SOURCE_EOF__
}

__Tools__Jq__class__name() {
    echo "jq"
}

__Tools__Jq__class__installCommand() {
    echo "brew install jq"
}

__Tools__Jq__class__parse_on_() {
  local filter="$1"
  local json="$2"
    local filter="$1" json="$2" toolPath cmd
    toolPath=$(@ "$_RECEIVER" path)

    if [[ -z "$toolPath" ]]; then
        _throw "ToolError" "jq is not installed"
        echo ""
        return
    fi

    cmd="echo '${json}' | ${toolPath} '${filter}'"
    @ Shell exec: "$cmd"
}

__Tools__Jq__class__parseFile_with_() {
  local filepath="$1"
  local filter="$2"
    local filepath="$1" filter="$2" toolPath cmd
    toolPath=$(@ "$_RECEIVER" path)

    if [[ -z "$toolPath" ]]; then
        _throw "ToolError" "jq is not installed"
        echo ""
        return
    fi

    cmd="${toolPath} '${filter}' ${filepath}"
    @ Shell exec: "$cmd"
}

__Tools__Jq__class__compact_() {
  local json="$1"
    local json="$1" toolPath cmd
    toolPath=$(@ "$_RECEIVER" path)

    if [[ -z "$toolPath" ]]; then
        _throw "ToolError" "jq is not installed"
        echo ""
        return
    fi

    cmd="echo '${json}' | ${toolPath} -c '.'"
    @ Shell exec: "$cmd"
}

__Tools__Jq__class__get_from_() {
  local key="$1"
  local json="$2"
    local key="$1" json="$2" toolPath cmd
    toolPath=$(@ "$_RECEIVER" path)

    if [[ -z "$toolPath" ]]; then
        _throw "ToolError" "jq is not installed"
        echo ""
        return
    fi

    cmd="echo '${json}' | ${toolPath} -r '.${key}'"
    @ Shell exec: "$cmd"
}
