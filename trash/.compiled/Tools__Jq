#!/usr/bin/env bash
# Generated by Trashtalk Compiler (procyon) - DO NOT EDIT
# Source: Jq.trash
# Generated: 2026-01-12T14:23:39

__Tools__Jq__superclass="Tool"
__Tools__Jq__instanceVars=""
__Tools__Jq__classInstanceVars=""
__Tools__Jq__traits=""
__Tools__Jq__sourceHash="f3c1f92474aa0457a272acd638be621fa0b361c67d2c56eb7ed5e6acbed6e883"

__Tools__Jq__source() {
  cat <<'__TRASHTALK_SOURCE_EOF__'
# Tools::Jq - Wrapper for the jq JSON processor
# Example of how to subclass Tool for a specific external program
# Built on Tool/Shell primitives - no raw bash required.
#
# Usage:
#   @ Tools::Jq ensure
#   @ Tools::Jq parse: '.name' on: '{"name": "test"}'
#
package: Tools

Jq subclass: Tool

  classMethod: name [
    ^ "jq"
  ]

  classMethod: installCommand [
    ^ "brew install jq"
  ]

  # Parse JSON with a jq filter
  primitiveClassMethod: parse: filter on: json [
    local filter="$1" json="$2" toolPath cmd
    toolPath=$(@ "$_RECEIVER" path)

    if [[ -z "$toolPath" ]]; then
      _throw "ToolError" "jq is not installed"
      echo ""
      return
    fi

    cmd="echo '${json}' | ${toolPath} '${filter}'"
    @ Shell exec: "$cmd"
  ]

  # Parse JSON from a file
  primitiveClassMethod: parseFile: filepath with: filter [
    local filepath="$1" filter="$2" toolPath cmd
    toolPath=$(@ "$_RECEIVER" path)

    if [[ -z "$toolPath" ]]; then
      _throw "ToolError" "jq is not installed"
      echo ""
      return
    fi

    cmd="${toolPath} '${filter}' ${filepath}"
    @ Shell exec: "$cmd"
  ]

  # Compact output (no pretty printing)
  primitiveClassMethod: compact: json [
    local json="$1" toolPath cmd
    toolPath=$(@ "$_RECEIVER" path)

    if [[ -z "$toolPath" ]]; then
      _throw "ToolError" "jq is not installed"
      echo ""
      return
    fi

    cmd="echo '${json}' | ${toolPath} -c '.'"
    @ Shell exec: "$cmd"
  ]

  # Get a specific key from JSON (raw output)
  primitiveClassMethod: get: key from: json [
    local key="$1" json="$2" toolPath cmd
    toolPath=$(@ "$_RECEIVER" path)

    if [[ -z "$toolPath" ]]; then
      _throw "ToolError" "jq is not installed"
      echo ""
      return
    fi

    cmd="echo '${json}' | ${toolPath} -r '.${key}'"
    @ Shell exec: "$cmd"
  ]
__TRASHTALK_SOURCE_EOF__
}

__Tools__Jq__class__name() {
  echo ""jq""; return
}

__Tools__Jq__class__installCommand() {
  echo ""brew install jq""; return
}

__Tools__Jq__class__parse_on_() {
  local filter="$1"
  local json="$2"
  local filter="$1" json="$2" toolPath cmd
  toolPath=$(@ "$_RECEIVER" path)
  if [[ -z "$toolPath" ]] ; then
  _throw "ToolError" "jq is not installed"
  echo ""
  return
  fi
  cmd="echo '${json}' | ${toolPath} '${filter}'"
  @ Shell exec: "$cmd"
}

__Tools__Jq__class__parseFile_with_() {
  local filepath="$1"
  local filter="$2"
  local filepath="$1" filter="$2" toolPath cmd
  toolPath=$(@ "$_RECEIVER" path)
  if [[ -z "$toolPath" ]] ; then
  _throw "ToolError" "jq is not installed"
  echo ""
  return
  fi
  cmd="${toolPath} '${filter}' ${filepath}"
  @ Shell exec: "$cmd"
}

__Tools__Jq__class__compact_() {
  local json="$1"
  local json="$1" toolPath cmd
  toolPath=$(@ "$_RECEIVER" path)
  if [[ -z "$toolPath" ]] ; then
  _throw "ToolError" "jq is not installed"
  echo ""
  return
  fi
  cmd="echo '${json}' | ${toolPath} -c '.'"
  @ Shell exec: "$cmd"
}

__Tools__Jq__class__get_from_() {
  local key="$1"
  local json="$2"
  local key="$1" json="$2" toolPath cmd
  toolPath=$(@ "$_RECEIVER" path)
  if [[ -z "$toolPath" ]] ; then
  _throw "ToolError" "jq is not installed"
  echo ""
  return
  fi
  cmd="echo '${json}' | ${toolPath} -r '.${key}'"
  @ Shell exec: "$cmd"
}

