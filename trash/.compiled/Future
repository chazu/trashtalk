#!/usr/bin/env bash
# Generated by Trashtalk Compiler (jq) - DO NOT EDIT
# Source: Future.trash
# Generated: 2026-01-04T02:40:12

__Future__superclass="Object"
__Future__instanceVars="command pid result_file status exit_code"
__Future__classInstanceVars=""
__Future__traits=""
__Future__sourceHash="4c4717d34efe8eedc4b20ad36cc64801c798f85128f9c0c6a3cb36eb0fba5b38"

__Future__source() {
  cat <<'__TRASHTALK_SOURCE_EOF__'
# Future - Simple async computation with result retrieval
Future subclass: Object
  instanceVars: command pid result_file status exit_code

  # Create a future for a command (does not start it yet)
  # Usage: future=$(@ Future for: '@ Counter expensiveCalculation')
  rawClassMethod: for: command [
    local future_id
    future_id=$(_generate_instance_id Future)

    # Set up result file paths
    local result_dir="/tmp/trashtalk/futures"
    mkdir -p "$result_dir"
    local result_file="$result_dir/$future_id"

    # Create instance with command stored but not yet running
    _create_instance Future "$future_id"
    @ "$future_id" setCommand "$command"
    @ "$future_id" setResult_file "$result_file"
    @ "$future_id" setStatus "created"
    @ "$future_id" setExit_code ""
    @ "$future_id" setPid ""

    echo "$future_id"
  ]

  # Start the computation in background
  # Returns the PID of the background process
  rawMethod: start [
    local cmd result_file exit_file
    cmd=$(_ivar command)
    result_file=$(_ivar result_file)
    exit_file="${result_file}.exit"

    # Run command in background subshell
    (eval "$cmd" > "$result_file" 2>&1; echo $? > "$exit_file") &
    local bg_pid=$!

    _ivar_set pid "$bg_pid"
    _ivar_set status "pending"

    echo "$bg_pid"
  ]

  # Block until the computation completes, return result
  rawMethod: await [
    local pid result_file exit_file
    pid=$(_ivar pid)
    result_file=$(_ivar result_file)
    exit_file="${result_file}.exit"

    # Wait for process to complete
    wait "$pid" 2>/dev/null

    # Read exit code and update status
    local exit_code
    exit_code=$(cat "$exit_file" 2>/dev/null || echo "1")
    _ivar_set exit_code "$exit_code"

    if [[ "$exit_code" == "0" ]]; then
      _ivar_set status "completed"
    else
      _ivar_set status "failed"
    fi

    # Return result
    cat "$result_file"
  ]

  # Check if computation is done without blocking
  rawMethod: poll [
    local pid
    pid=$(_ivar pid)

    if kill -0 "$pid" 2>/dev/null; then
      echo "pending"
    else
      # Process finished, update status
      @ "$_RECEIVER" await >/dev/null
      echo "$(_ivar status)"
    fi
  ]

  # Check if done (returns 0 if done, 1 if pending)
  rawMethod: isDone [
    local pid
    pid=$(_ivar pid)
    ! kill -0 "$pid" 2>/dev/null
  ]

  # Cancel the computation
  rawMethod: cancel [
    local pid
    pid=$(_ivar pid)

    if kill -0 "$pid" 2>/dev/null; then
      kill -TERM "$pid" 2>/dev/null
      sleep 0.1
      kill -KILL "$pid" 2>/dev/null
      _ivar_set status "cancelled"
      echo "Cancelled"
    else
      echo "Already completed"
    fi
  ]

  # Get current status
  rawMethod: status [
    local pid status
    status=$(_ivar status)
    pid=$(_ivar pid)

    # Update status if process finished
    if [[ "$status" == "pending" ]] && ! kill -0 "$pid" 2>/dev/null; then
      @ "$_RECEIVER" await >/dev/null
      status=$(_ivar status)
    fi

    echo "$status"
  ]

  # Get exit code (empty if still pending)
  rawMethod: exitCode [
    _ivar exit_code
  ]

  # Clean up resources
  rawMethod: cleanup [
    local result_file
    result_file=$(_ivar result_file)
    rm -f "$result_file" "${result_file}.exit" 2>/dev/null
    @ "$_RECEIVER" delete
  ]

  # Show help
  classMethod: help [
    echo "=== Future - Async Computation ==="
    echo ""
    echo "Usage (two-call pattern - recommended):"
    echo "  future=\$(@ Future for: 'command')   # Create future"
    echo "  @ \$future start                     # Start background process"
    echo "  result=\$(@ \$future await)          # Get result"
    echo ""
    echo "Class Methods:"
    echo "  for: <command>  - Create future (stores command, does not start)"
    echo ""
    echo "Instance Methods:"
    echo "  start           - Start the background computation"
    echo "  await           - Block until done, return result"
    echo "  poll            - Check status without blocking"
    echo "  isDone          - Returns 0 if done, 1 if pending"
    echo "  cancel          - Kill the computation"
    echo "  status          - Show status (created/pending/completed/failed/cancelled)"
    echo "  exitCode        - Get exit code (empty if pending)"
    echo "  cleanup         - Remove result files and delete future"
    echo ""
    echo "Example:"
    echo "  # Create future for expensive computation"
    echo "  f=\$(@ Future for: 'sleep 2 && echo done')"
    echo "  @ \$f start  # Start it"
    echo "  "
    echo "  # Do other work while it runs..."
    echo "  @ SomeClass doOtherStuff"
    echo "  "
    echo "  # Get result (blocks if not ready)"
    echo "  result=\$(@ \$f await)"
    echo "  echo \"Result: \$result\""
    echo "  @ \$f cleanup"
  ]
__TRASHTALK_SOURCE_EOF__
}

__Future__command() {
  echo "$(_ivar command)"; return
}

__Future__command_() {
  _ivar_set command "$1"
}

__Future__getCommand() {
  echo "$(_ivar command)"; return
}

__Future__setCommand_() {
  _ivar_set command "$1"
}
__Future__pid() {
  echo "$(_ivar pid)"; return
}

__Future__pid_() {
  _ivar_set pid "$1"
}

__Future__getPid() {
  echo "$(_ivar pid)"; return
}

__Future__setPid_() {
  _ivar_set pid "$1"
}
__Future__result_file() {
  echo "$(_ivar result_file)"; return
}

__Future__result_file_() {
  _ivar_set result_file "$1"
}

__Future__getResult_file() {
  echo "$(_ivar result_file)"; return
}

__Future__setResult_file_() {
  _ivar_set result_file "$1"
}
__Future__status() {
  echo "$(_ivar status)"; return
}

__Future__status_() {
  _ivar_set status "$1"
}

__Future__getStatus() {
  echo "$(_ivar status)"; return
}

__Future__setStatus_() {
  _ivar_set status "$1"
}
__Future__exit_code() {
  echo "$(_ivar exit_code)"; return
}

__Future__exit_code_() {
  _ivar_set exit_code "$1"
}

__Future__getExit_code() {
  echo "$(_ivar exit_code)"; return
}

__Future__setExit_code_() {
  _ivar_set exit_code "$1"
}

__Future__class__for_() {
  local command="$1"
    local future_id
    future_id=$(_generate_instance_id Future)

    # Set up result file paths
    local result_dir="/tmp/trashtalk/futures"
    mkdir -p "$result_dir"
    local result_file="$result_dir/$future_id"

    # Create instance with command stored but not yet running
    _create_instance Future "$future_id"
    @ "$future_id" setCommand "$command"
    @ "$future_id" setResult_file "$result_file"
    @ "$future_id" setStatus "created"
    @ "$future_id" setExit_code ""
    @ "$future_id" setPid ""

    echo "$future_id"
}

__Future__start() {
    local cmd result_file exit_file
    cmd=$(_ivar command)
    result_file=$(_ivar result_file)
    exit_file="${result_file}.exit"

    # Run command in background subshell
    (eval "$cmd" >"$result_file" 2>&1; echo $? >"$exit_file") &
    local bg_pid=$!

    _ivar_set pid "$bg_pid"
    _ivar_set status "pending"

    echo "$bg_pid"
}

__Future__await() {
    local pid result_file exit_file
    pid=$(_ivar pid)
    result_file=$(_ivar result_file)
    exit_file="${result_file}.exit"

    # Wait for process to complete
    wait "$pid" 2>/dev/null

    # Read exit code and update status
    local exit_code
    exit_code=$(cat "$exit_file" 2>/dev/null || echo "1")
    _ivar_set exit_code "$exit_code"

    if [[ "$exit_code" == "0" ]]; then
        _ivar_set status "completed"
        else
        _ivar_set status "failed"
    fi

    # Return result
    cat "$result_file"
}

__Future__poll() {
    local pid
    pid=$(_ivar pid)

    if kill -0 "$pid" 2>/dev/null; then
        echo "pending"
        else
        # Process finished, update status
        @ "$_RECEIVER" await >/dev/null
        echo "$(_ivar status)"
    fi
}

__Future__isDone() {
    local pid
    pid=$(_ivar pid)
    ! kill -0 "$pid" 2>/dev/null
}

__Future__cancel() {
    local pid
    pid=$(_ivar pid)

    if kill -0 "$pid" 2>/dev/null; then
        kill -TERM "$pid" 2>/dev/null
        sleep 0.1
        kill -KILL "$pid" 2>/dev/null
        _ivar_set status "cancelled"
        echo "Cancelled"
        else
        echo "Already completed"
    fi
}

__Future__status() {
    local pid status
    status=$(_ivar status)
    pid=$(_ivar pid)

    # Update status if process finished
    if [[ "$status" == "pending" ]] && ! kill -0 "$pid" 2>/dev/null; then
        @ "$_RECEIVER" await >/dev/null
        status=$(_ivar status)
    fi

    echo "$status"
}

__Future__exitCode() {
    _ivar exit_code
}

__Future__cleanup() {
    local result_file
    result_file=$(_ivar result_file)
    rm -f "$result_file" "${result_file}.exit" 2>/dev/null
    @ "$_RECEIVER" delete
}

__Future__class__help() {
  echo "=== Future - Async Computation ==="
  echo ""
  echo "Usage (two-call pattern - recommended):"
  echo " future=\$(@ Future for: 'command') # Create future"
  echo " @ \$future start # Start background process"
  echo " result=\$(@ \$future await) # Get result"
  echo ""
  echo "Class Methods:"
  echo " for: <command> - Create future (stores command, does not start)"
  echo ""
  echo "Instance Methods:"
  echo " start - Start the background computation"
  echo " await - Block until done, return result"
  echo " poll - Check status without blocking"
  echo " isDone - Returns 0 if done, 1 if pending"
  echo " cancel - Kill the computation"
  echo " status - Show status (created/pending/completed/failed/cancelled)"
  echo " exitCode - Get exit code (empty if pending)"
  echo " cleanup - Remove result files and delete future"
  echo ""
  echo "Example:"
  echo " # Create future for expensive computation"
  echo " f=\$(@ Future for: 'sleep 2 && echo done')"
  echo " @ \$f start # Start it"
  echo " "
  echo " # Do other work while it runs..."
  echo " @ SomeClass doOtherStuff"
  echo " "
  echo " # Get result (blocks if not ready)"
  echo " result=\$(@ \$f await)"
  echo " echo \" Result: \$result \""
  echo " @ \$f cleanup"
}
