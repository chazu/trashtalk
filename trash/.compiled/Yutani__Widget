#!/usr/bin/env bash
# Generated by Trashtalk Compiler (procyon) - DO NOT EDIT
# Source: Widget.trash
# Generated: 2026-01-12T21:22:52

__Yutani__Widget__superclass="Object"
__Yutani__Widget__instanceVars="session: widgetId: title: dispatcher:"
__Yutani__Widget__classInstanceVars=""
__Yutani__Widget__traits=""
__Yutani__Widget__sourceHash="f651f1149fa61e748ec3506054abbae8d91043c4688f0db3f77ee098b32eab25"

__Yutani__Widget__source() {
  cat <<'__TRASHTALK_SOURCE_EOF__'
package: Yutani

Widget subclass: Object
  instanceVars: session:'' widgetId:'' title:'' dispatcher:''

  # Session accessor
  method: getSession [
    ^ session
  ]

  method: setSession: s [
    session := s
  ]

  # Widget ID accessor
  method: getWidgetId [
    ^ widgetId
  ]

  method: setWidgetId: id [
    widgetId := id
  ]

  # Title accessor
  method: getTitle [
    ^ title
  ]

  method: setTitle: t [
    title := t
  ]

  # Dispatcher accessor
  method: getDispatcher [
    ^ dispatcher
  ]

  method: setDispatcher: d [
    dispatcher := d
  ]

  # Delete this widget from the session
  method: delete [
    | s w d |
    s := session.
    w := widgetId.
    d := dispatcher.
    (d notEmpty) ifTrue: [
      (w notEmpty) ifTrue: [
        @ d removeHandlerFor: w
      ]
    ].
    (s notEmpty) ifTrue: [
      (w notEmpty) ifTrue: [
        @ s deleteWidget: w
      ]
    ]
  ]

  # Focus this widget
  method: focus [
    | s w |
    s := session.
    w := widgetId.
    (s notEmpty) ifTrue: [
      (w notEmpty) ifTrue: [
        @ s focusWidget: w
      ]
    ]
  ]

  # Register an event handler for this widget
  # Handler is eval'd with $__EVENT set to the Event instance
  method: onEventDo: handler [
    | d w |
    d := dispatcher.
    w := widgetId.
    (d notEmpty) ifTrue: [
      (w notEmpty) ifTrue: [
        @ d onWidget: w do: handler
      ]
    ]
  ]

  # Convenience: Register handler for submission events
  # Handler receives $__EVENT and $__TEXT (submitted text)
  # Note: WIDGET_CHANGED stores text, WIDGET_DONE triggers handler with stored text
  # This method uses bash-specific features (printf, temp files) for cross-subshell state
  rawMethod: onSubmitDo: handler [
    pragma: bashOnly
    local handler="$1" _dispatcher _wid wrappedHandler
    _dispatcher="$(_ivar dispatcher)"
    _wid="$(_ivar widgetId)"
    if [[ -n "$_dispatcher" && -n "$_wid" ]]; then
      # Use a temp file to store text (shell vars don't persist across subshell calls)
      local storageFile="/tmp/yutani_text_${_wid}.txt"
      # Wrap handler to store text on CHANGED and fire on DONE
      printf -v wrappedHandler '__wt=$(@ "$__EVENT" widgetEventType); if [[ "$__wt" == "WIDGET_CHANGED" ]]; then @ "$__EVENT" widgetDataAt: "text" > %s; elif [[ "$__wt" == "WIDGET_DONE" ]]; then __TEXT=$(cat %s 2>/dev/null); %s; fi' "$storageFile" "$storageFile" "$handler"
      @ "$_dispatcher" onWidget: "$_wid" do: "$wrappedHandler"
    else
      echo "[WIDGET] Missing dispatcher or wid, not registering" >&2
    fi
  ]
__TRASHTALK_SOURCE_EOF__
}

__Yutani__Widget__session() {
  echo "$(_ivar session)"; return
}

__Yutani__Widget__session_() {
  _ivar_set session "$1"
}

__Yutani__Widget__widgetId() {
  echo "$(_ivar widgetId)"; return
}

__Yutani__Widget__widgetId_() {
  _ivar_set widgetId "$1"
}

__Yutani__Widget__title() {
  echo "$(_ivar title)"; return
}

__Yutani__Widget__title_() {
  _ivar_set title "$1"
}

__Yutani__Widget__dispatcher() {
  echo "$(_ivar dispatcher)"; return
}

__Yutani__Widget__dispatcher_() {
  _ivar_set dispatcher "$1"
}

__Yutani__Widget__getSession() {
  echo "$(_ivar session)"; return
}

__Yutani__Widget__setSession_() {
  local s="$1"
  _ivar_set session "$s"
}

__Yutani__Widget__getWidgetId() {
  echo "$(_ivar widgetId)"; return
}

__Yutani__Widget__setWidgetId_() {
  local id="$1"
  _ivar_set widgetId "$id"
}

__Yutani__Widget__getTitle() {
  echo "$(_ivar title)"; return
}

__Yutani__Widget__setTitle_() {
  local t="$1"
  _ivar_set title "$t"
}

__Yutani__Widget__getDispatcher() {
  echo "$(_ivar dispatcher)"; return
}

__Yutani__Widget__setDispatcher_() {
  local d="$1"
  _ivar_set dispatcher "$d"
}

__Yutani__Widget__delete() {
  local s w d
  s="$(_ivar session)"
  w="$(_ivar widgetId)"
  d="$(_ivar dispatcher)"
  if [[ -n "$(@ "$d" notEmpty)" ]]; then
    if [[ -n "$(@ "$w" notEmpty)" ]]; then
      $(@ "$d" removeHandlerFor_ $w)
    fi
  fi
  if [[ -n "$(@ "$s" notEmpty)" ]]; then
    if [[ -n "$(@ "$w" notEmpty)" ]]; then
      $(@ "$s" deleteWidget_ $w)
    fi
  fi
}

__Yutani__Widget__focus() {
  local s w
  s="$(_ivar session)"
  w="$(_ivar widgetId)"
  if [[ -n "$(@ "$s" notEmpty)" ]]; then
    if [[ -n "$(@ "$w" notEmpty)" ]]; then
      $(@ "$s" focusWidget_ $w)
    fi
  fi
}

__Yutani__Widget__onEventDo_() {
  local handler="$1"
  local d w
  d="$(_ivar dispatcher)"
  w="$(_ivar widgetId)"
  if [[ -n "$(@ "$d" notEmpty)" ]]; then
    if [[ -n "$(@ "$w" notEmpty)" ]]; then
      $(@ "$d" onWidget_do_ $w $handler)
    fi
  fi
}

__Yutani__Widget__onSubmitDo_() {
  local handler="$1"
  local handler="$1" _dispatcher _wid wrappedHandler
  _dispatcher="$(_ivar dispatcher)"
  _wid="$(_ivar widgetId)"
  if [[ -n "$_dispatcher" && -n "$_wid" ]] ; then
  # Use a temp file to store text (shell vars don't persist across subshell calls)
  local storageFile="/tmp/yutani_text_${_wid}.txt"
  # Wrap handler to store text on CHANGED and fire on DONE
  printf -v wrappedHandler '__wt=$(@ "$__EVENT" widgetEventType); if [[ "$__wt" == "WIDGET_CHANGED" ]]; then @ "$__EVENT" widgetDataAt: "text" > %s; elif [[ "$__wt" == "WIDGET_DONE" ]]; then __TEXT=$(cat %s 2>/dev/null); %s; fi' "$storageFile" "$storageFile" "$handler"
  @ "$_dispatcher" onWidget: "$_wid" do: "$wrappedHandler"
  else
  echo "[WIDGET] Missing dispatcher or wid, not registering" >& 2
  fi
}

