#!/usr/bin/env bash
# Generated by Trashtalk Compiler (jq) - DO NOT EDIT
# Source: Shell.trash
# Generated: 2026-01-12T22:13:34

__Shell__superclass="Object"
__Shell__instanceVars=""
__Shell__classInstanceVars=""
__Shell__traits=""
__Shell__sourceHash="f8946bf3755e98b746e0b30f222d11910aacd3aba1f8dd5dba1a1e644a908fee"
__Shell__primitiveClass="1"

__Shell__source() {
  cat <<'__TRASHTALK_SOURCE_EOF__'
# Shell - Command execution primitive class
# Provides simple command execution without Process overhead
#
# Usage:
#   output := @ Shell exec: 'ls -la'
#   @ Shell run: 'make test'
#   pid := @ Shell spawn: 'sleep 10'
#
Shell subclass: Object
  pragma: primitiveClass

  # ==========================================
  # Simple Execution
  # ==========================================

  # Execute command and return stdout
  # Usage: output := @ Shell exec: 'ls -la'
  classMethod: exec: command [
    eval "$1"
  ]

  # Execute command, return stdout, capture exit code in $?
  # Usage: output := @ Shell run: 'make test'
  classMethod: run: command [
    eval "$1"
  ]

  # Execute command silently (discard output)
  # Usage: @ Shell silent: 'rm -f temp.txt'
  classMethod: silent: command [
    eval "$1" >/dev/null 2>&1
  ]

  # Execute command and return exit code only
  # Usage: code := @ Shell exitCode: 'make test'
  classMethod: exitCode: command [
    eval "$1" >/dev/null 2>&1
    echo $?
  ]

  # Execute command and return true/false based on success
  # Usage: ok := @ Shell succeeds: 'make test'
  classMethod: succeeds: command [
    if eval "$1" >/dev/null 2>&1; then
      echo "true"
    else
      echo "false"
    fi
  ]

  # Execute command and return true/false based on failure
  # Usage: failed := @ Shell fails: 'make test'
  classMethod: fails: command [
    if eval "$1" >/dev/null 2>&1; then
      echo "false"
    else
      echo "true"
    fi
  ]

  # ==========================================
  # Output Capture
  # ==========================================

  # Execute command and return both stdout and stderr combined
  # Usage: output := @ Shell execAll: 'make 2>&1'
  # Note: Using bash -c to avoid tokenizer mangling 2>&1 into 2 >& 1
  classMethod: execAll: command [
    bash -c "$1 2>&1"
  ]

  # Execute command and return stderr only
  # Usage: errors := @ Shell execErr: 'make test'
  # Note: Using bash -c to avoid tokenizer mangling redirects
  classMethod: execErr: command [
    bash -c "$1 2>&1 >/dev/null"
  ]

  # Execute command and return JSON with stdout, stderr, exitCode
  # Usage: result := @ Shell execFull: 'make test'
  classMethod: execFull: command [
    local stdout_file="/tmp/shell_$$_stdout"
    local stderr_file="/tmp/shell_$$_stderr"

    # Run in subshell to capture exit code even for 'exit N' commands
    (eval "$1") >"$stdout_file" 2>"$stderr_file"
    local exit_code=$?

    local stdout stderr
    stdout=$(cat "$stdout_file" 2>/dev/null)
    stderr=$(cat "$stderr_file" 2>/dev/null)
    rm -f "$stdout_file" "$stderr_file"

    jo stdout="$stdout" stderr="$stderr" exitCode="$exit_code"
  ]

  # ==========================================
  # Background Execution
  # ==========================================

  # Spawn a command in the background, return PID
  # Usage: pid := @ Shell spawn: 'sleep 10'
  # Note: Using subshell to avoid tokenizer mangling redirects
  classMethod: spawn: command [
    ( eval "$1" ) > /dev/null &
    echo $!
  ]

  # Spawn with output to file, return PID
  # Usage: pid := @ Shell spawn: 'long-task' outputTo: '/tmp/out.log'
  # Note: Using subshell to avoid tokenizer mangling redirects
  classMethod: spawn: command outputTo: filepath [
    ( eval "$1" ) > "$2" &
    echo $!
  ]

  # Spawn with separate stdout and stderr files, return PID
  # Usage: pid := @ Shell spawn: 'cmd' stdoutTo: '/tmp/out' stderrTo: '/tmp/err'
  classMethod: spawn: command stdoutTo: stdoutFile stderrTo: stderrFile [
    ( eval "$1" ) > "$2" 2> "$3" &
    echo $!
  ]

  # Wait for a PID to complete
  # Usage: @ Shell wait: pid
  classMethod: wait: pid [
    wait "$1" 2>/dev/null
    echo $?
  ]

  # ==========================================
  # Process Control
  # ==========================================

  # Check if a PID is still running
  # Usage: running := @ Shell isAlive: pid
  # Note: Using ps instead of kill -0 to avoid tokenizer mangling 2>/dev/null
  classMethod: isAlive: pid [
    if ps -p "$1" > /dev/null; then
      echo "true"
    else
      echo "false"
    fi
  ]

  # Send a signal to a PID
  # Usage: @ Shell signal: 'TERM' to: pid
  classMethod: signal: signalName to: pid [
    kill "-$1" "$2" 2>/dev/null
  ]

  # Send SIGTERM to a PID
  # Usage: @ Shell terminate: pid
  classMethod: terminate: pid [
    kill -TERM "$1" 2>/dev/null
  ]

  # Send SIGKILL to a PID
  # Usage: @ Shell kill: pid
  classMethod: kill: pid [
    kill -KILL "$1" 2>/dev/null
  ]

  # Send SIGSTOP to a PID (pause)
  # Usage: @ Shell pause: pid
  classMethod: pause: pid [
    kill -STOP "$1" 2>/dev/null
  ]

  # Send SIGCONT to a PID (resume)
  # Usage: @ Shell resume: pid
  classMethod: resume: pid [
    kill -CONT "$1" 2>/dev/null
  ]

  # ==========================================
  # Piping and Chaining
  # ==========================================

  # Execute command and pipe output through another command
  # Usage: result := @ Shell exec: 'cat file.txt' pipeTo: 'grep pattern'
  classMethod: exec: command pipeTo: pipeCommand [
    eval "$1" | eval "$2"
  ]

  # Execute command and pipe through two more commands
  # Usage: result := @ Shell exec: 'cat file' pipeTo: 'grep x' pipeTo: 'wc -l'
  classMethod: exec: command pipeTo: pipe1 pipeTo: pipe2 [
    eval "$1" | eval "$2" | eval "$3"
  ]

  # ==========================================
  # Input/Output
  # ==========================================

  # Execute command with stdin from string
  # Usage: result := @ Shell exec: 'wc -w' withInput: 'hello world'
  classMethod: exec: command withInput: input [
    echo "$2" | eval "$1"
  ]

  # Execute command with stdin from file
  # Usage: result := @ Shell exec: 'wc -l' withInputFrom: '/tmp/data.txt'
  classMethod: exec: command withInputFrom: filepath [
    eval "$1" < "$2"
  ]

  # Execute command with stdout to file
  # Usage: @ Shell exec: 'ls -la' outputTo: '/tmp/listing.txt'
  classMethod: exec: command outputTo: filepath [
    eval "$1" > "$2"
  ]

  # Execute command with stdout appended to file
  # Usage: @ Shell exec: 'echo line' appendTo: '/tmp/log.txt'
  classMethod: exec: command appendTo: filepath [
    eval "$1" >> "$2"
  ]

  # ==========================================
  # Conditional Execution
  # ==========================================

  # Execute command only if another succeeds
  # Usage: @ Shell if: 'test -f file' then: 'rm file'
  classMethod: if: condition then: command [
    if eval "$1" >/dev/null 2>&1; then
      eval "$2"
    fi
  ]

  # Execute command only if another fails
  # Usage: @ Shell unless: 'test -f file' then: 'touch file'
  classMethod: unless: condition then: command [
    if ! eval "$1" >/dev/null 2>&1; then
      eval "$2"
    fi
  ]

  # Execute command with timeout
  # Usage: result := @ Shell exec: 'slow-command' timeout: 5
  classMethod: exec: command timeout: seconds [
    timeout "$2" bash -c "$1"
  ]

  # ==========================================
  # Current Shell State
  # ==========================================

  # Get the current process ID
  classMethod: pid [
    echo $$
  ]

  # Get the parent process ID
  classMethod: ppid [
    echo $PPID
  ]

  # Get the last exit code
  classMethod: lastExitCode [
    echo $?
  ]
__TRASHTALK_SOURCE_EOF__
}

__Shell__class__exec_() {
  local command="$1"
    eval "$1"
}

__Shell__class__run_() {
  local command="$1"
    eval "$1"
}

__Shell__class__silent_() {
  local command="$1"
    eval "$1" >/dev/null 2>&1
}

__Shell__class__exitCode_() {
  local command="$1"
    eval "$1" >/dev/null 2>&1
    echo $?
}

__Shell__class__succeeds_() {
  local command="$1"
    if eval "$1" >/dev/null 2>&1; then
        echo "true"
        else
        echo "false"
    fi
}

__Shell__class__fails_() {
  local command="$1"
    if eval "$1" >/dev/null 2>&1; then
        echo "false"
        else
        echo "true"
    fi
}

__Shell__class__execAll_() {
  local command="$1"
    bash -c "$1 2>&1"
}

__Shell__class__execErr_() {
  local command="$1"
    bash -c "$1 2>&1>/dev/null"
}

__Shell__class__execFull_() {
  local command="$1"
    local stdout_file="/tmp/shell_$$_stdout"
    local stderr_file="/tmp/shell_$$_stderr"

    # Run in subshell to capture exit code even for 'exit N' commands
    (eval "$1") >"$stdout_file" 2>"$stderr_file"
    local exit_code=$?

    local stdout stderr
    stdout=$(cat "$stdout_file" 2>/dev/null)
    stderr=$(cat "$stderr_file" 2>/dev/null)
    rm -f "$stdout_file" "$stderr_file"

    jo stdout="$stdout" stderr="$stderr" exitCode="$exit_code"
}

__Shell__class__spawn_() {
  local command="$1"
    (eval "$1") >/dev/null &
    echo $!
}

__Shell__class__spawn_outputTo_() {
  local command="$1"
  local filepath="$2"
    (eval "$1") >"$2" &
    echo $!
}

__Shell__class__spawn_stdoutTo_stderrTo_() {
  local command="$1"
  local stdoutFile="$2"
  local stderrFile="$3"
    (eval "$1") >"$2" 2>"$3" &
    echo $!
}

__Shell__class__wait_() {
  local pid="$1"
    wait "$1" 2>/dev/null
    echo $?
}

__Shell__class__isAlive_() {
  local pid="$1"
    if ps -p "$1" >/dev/null; then
        echo "true"
        else
        echo "false"
    fi
}

__Shell__class__signal_to_() {
  local signalName="$1"
  local pid="$2"
    kill "-$1" "$2" 2>/dev/null
}

__Shell__class__terminate_() {
  local pid="$1"
    kill -TERM "$1" 2>/dev/null
}

__Shell__class__kill_() {
  local pid="$1"
    kill -KILL "$1" 2>/dev/null
}

__Shell__class__pause_() {
  local pid="$1"
    kill -STOP "$1" 2>/dev/null
}

__Shell__class__resume_() {
  local pid="$1"
    kill -CONT "$1" 2>/dev/null
}

__Shell__class__exec_pipeTo_() {
  local command="$1"
  local pipeCommand="$2"
    eval "$1" | eval "$2"
}

__Shell__class__exec_pipeTo_pipeTo_() {
  local command="$1"
  local pipe1="$2"
  local pipe2="$3"
    eval "$1" | eval "$2" | eval "$3"
}

__Shell__class__exec_withInput_() {
  local command="$1"
  local input="$2"
    echo "$2" | eval "$1"
}

__Shell__class__exec_withInputFrom_() {
  local command="$1"
  local filepath="$2"
    eval "$1" <"$2"
}

__Shell__class__exec_outputTo_() {
  local command="$1"
  local filepath="$2"
    eval "$1" >"$2"
}

__Shell__class__exec_appendTo_() {
  local command="$1"
  local filepath="$2"
    eval "$1" >>"$2"
}

__Shell__class__if_then_() {
  local condition="$1"
  local command="$2"
    if eval "$1" >/dev/null 2>&1; then
        eval "$2"
    fi
}

__Shell__class__unless_then_() {
  local condition="$1"
  local command="$2"
    if ! eval "$1" >/dev/null 2>&1; then
        eval "$2"
    fi
}

__Shell__class__exec_timeout_() {
  local command="$1"
  local seconds="$2"
    timeout "$2" bash -c "$1"
}

__Shell__class__pid() {
    echo $$
}

__Shell__class__ppid() {
    echo $PPID
}

__Shell__class__lastExitCode() {
    echo $?
}
