#!/usr/bin/env bash
# Generated by Trashtalk Compiler (procyon) - DO NOT EDIT
# Source: Procyon.trash
# Generated: 2026-01-09T20:30:07

__Tools__Procyon__superclass="Tool"
__Tools__Procyon__instanceVars=""
__Tools__Procyon__classInstanceVars=""
__Tools__Procyon__traits=""
__Tools__Procyon__sourceHash="d3b2009364abc7884ec9d61c6f13bb70e94c6b10eaf9ba42395d11e4d734b2b1"

__Tools__Procyon__source() {
  cat <<'__TRASHTALK_SOURCE_EOF__'
# Tools::Procyon - Wrapper for the Procyon Go compiler
# Installs via `go install` from GitHub
#
# Procyon compiles Trashtalk AST JSON to native Go binaries for performance.
# It supports a subset of Trashtalk features, falling back to Bash for unsupported constructs.
#
# v0.7.0 features:
#   - --serve mode: each .native binary can run as its own daemon
#   - --mode=plugin: generate c-shared libraries for dynamic loading
#   - Metadata: --source, --hash, --info flags
#
# Usage:
#   @ Tools::Procyon ensure              # Install if needed
#   @ Tools::Procyon version             # Show version
#   @ Tools::Procyon compile: input.json # Compile AST JSON to Go
#
package: Tools

Procyon subclass: Tool

  classMethod: name [
    ^ "procyon"
  ]

  classMethod: installCommand [
    ^ "go install github.com/chazu/procyon/cmd/procyon@v0.7.0"
  ]

  # Override version to use procyon's --version flag
  rawClassMethod: version [
    local tool_path
    tool_path=$(command -v procyon 2>/dev/null)
    if [[ -z "$tool_path" ]]; then
      echo "not installed"
      return 1
    fi
    "$tool_path" --version 2>/dev/null || echo "unknown"
  ]

  # Compile AST JSON to Go code (outputs to stdout)
  # Note: procyon reads from stdin, so we pipe the file
  rawClassMethod: compile: inputFile [
    local tool_path
    tool_path=$(@ "$_CLASS" path)
    if [[ -z "$tool_path" ]]; then
      _throw "ToolError" "procyon is not installed"
      return 1
    fi
    "$tool_path" < "$1"
  ]

  # Compile AST JSON and write to output file
  rawClassMethod: compile: inputFile to: outputFile [
    local tool_path
    tool_path=$(@ "$_CLASS" path)
    if [[ -z "$tool_path" ]]; then
      _throw "ToolError" "procyon is not installed"
      return 1
    fi
    "$tool_path" < "$1" > "$2"
  ]

  # Get info about what procyon supports
  rawClassMethod: info [
    local tool_path
    tool_path=$(@ "$_CLASS" path)
    if [[ -z "$tool_path" ]]; then
      _throw "ToolError" "procyon is not installed"
      return 1
    fi
    "$tool_path" --help 2>&1 | head -20
  ]

  # Compile a .trash file to a native binary
  # Usage: @ Tools::Procyon compileNative: Counter.trash
  # Result: Creates ~/.trashtalk/trash/.compiled/Counter.native
  rawClassMethod: compileNative: trashFile [
    local tool_path
    tool_path=$(@ "$_CLASS" path)
    if [[ -z "$tool_path" ]]; then
      _throw "ToolError" "procyon is not installed"
      return 1
    fi

    local trash_file="$1"

    # Validate input file exists
    if [[ ! -f "$trash_file" ]]; then
      _throw "FileError" "File not found: $trash_file"
      return 1
    fi

    # Extract class name from filename (e.g., Counter.trash -> Counter)
    local basename=$(basename "$trash_file" .trash)
    # Handle namespaced classes in subdirectories (e.g., Yutani/Widget.trash -> Yutani__Widget)
    local dir=$(dirname "$trash_file")
    local class_name="$basename"

    # Check if it's in a package subdirectory under trash/
    # Use grep to avoid glob pattern issues with the compiler
    if echo "$dir" | grep -q "/trash/"; then
      local pkg=$(basename "$dir")
      if [[ "$pkg" != "trash" && "$pkg" != "." ]]; then
        class_name="${pkg}__${basename}"
      fi
    fi

    echo "Compiling $trash_file -> $class_name.native" >&2

    # Create temp build directory
    local build_dir=$(mktemp -d)
    trap "rm -rf '$build_dir'" EXIT

    # Step 1: Generate AST JSON
    echo "  [1/4] Generating AST..." >&2
    local ast_file="$build_dir/ast.json"
    local trashtalk_root="${TRASHDIR%/trash}"
    if ! "$trashtalk_root/lib/jq-compiler/driver.bash" ast "$trash_file" > "$ast_file" 2>/dev/null; then
      _throw "CompileError" "Failed to parse $trash_file"
      return 1
    fi

    # Step 2: Compile to Go
    echo "  [2/4] Compiling to Go..." >&2
    local go_file="$build_dir/main.go"
    if ! "$tool_path" < "$ast_file" > "$go_file" 2>"$build_dir/procyon.log"; then
      cat "$build_dir/procyon.log" >&2
      _throw "CompileError" "Procyon failed to compile $trash_file"
      return 1
    fi

    # Show procyon output (skipped methods, etc.)
    if [[ -s "$build_dir/procyon.log" ]]; then
      cat "$build_dir/procyon.log" >&2
    fi

    # Step 3: Copy source file (needed for go:embed)
    echo "  [3/4] Building native binary..." >&2
    cp "$trash_file" "$build_dir/$basename.trash"

    # Step 4: Initialize go module and build
    (
      cd "$build_dir"
      go mod init "trashtalk/$class_name" >/dev/null 2>&1
      go mod tidy >/dev/null 2>&1

      local output_dir="$TRASHDIR/.compiled"
      local native_binary="$output_dir/${class_name}.native"

      if ! go build -o "$native_binary" "." 2>"$build_dir/go.log"; then
        cat "$build_dir/go.log" >&2
        _throw "BuildError" "Go build failed"
        return 1
      fi

      echo "  [4/4] Installed: $native_binary" >&2
      echo "$native_binary"
    )
  ]

  # Compile all .trash files that would benefit from native compilation
  # Usage: @ Tools::Procyon compileAll
  rawClassMethod: compileAll [
    local count=0
    local failed=0

    echo "Compiling all .trash files to native binaries..." >&2

    for trash_file in "$TRASHDIR"/*.trash; do
      [[ -f "$trash_file" ]] || continue

      local basename=$(basename "$trash_file" .trash)
      # Skip traits
      [[ -d "$TRASHDIR/traits/$basename.trash" ]] && continue

      if @ "$_CLASS" compileNative: "$trash_file" >/dev/null 2>&1; then
        ((count++))
      else
        ((failed++))
        echo "  Failed: $basename" >&2
      fi
    done

    echo "Compiled $count classes ($failed failed)" >&2
    echo "$count"
  ]

  # Remove a native binary
  # Usage: @ Tools::Procyon removeNative: Counter
  rawClassMethod: removeNative: className [
    local native_binary="$TRASHDIR/.compiled/${1}.native"
    if [[ -f "$native_binary" ]]; then
      rm "$native_binary"
      echo "Removed: $native_binary" >&2
      echo "true"
    else
      echo "Not found: $native_binary" >&2
      echo "false"
    fi
  ]

  # List all installed native binaries
  rawClassMethod: listNative [
    local count=0
    for native in "$TRASHDIR"/.compiled/*.native; do
      [[ -f "$native" ]] || continue
      basename "$native" .native
      ((count++))
    done
    echo "($count native binaries)" >&2
  ]
__TRASHTALK_SOURCE_EOF__
}

__Tools__Procyon__class__name() {
  echo "procyon"; return
}

__Tools__Procyon__class__installCommand() {
  echo "go install github.com/chazu/procyon/cmd/procyon@v0.7.0"; return
}

__Tools__Procyon__class__version() {
  local tool_path
  tool_path=$(command -v procyon 2>/dev/null)
  if [[ -z "$tool_path" ]] ; then
  echo "not installed"
  return 1
  fi
  "$tool_path" - - version 2 > /dev/null || echo "unknown"
}

__Tools__Procyon__class__compile_() {
  local inputFile="$1"
  local tool_path
  tool_path=$(@ "$_CLASS" path)
  if [[ -z "$tool_path" ]] ; then
  _throw "ToolError" "procyon is not installed"
  return 1
  fi
  "$tool_path" < "$1"
}

__Tools__Procyon__class__compile_to_() {
  local inputFile="$1"
  local outputFile="$2"
  local tool_path
  tool_path=$(@ "$_CLASS" path)
  if [[ -z "$tool_path" ]] ; then
  _throw "ToolError" "procyon is not installed"
  return 1
  fi
  "$tool_path" < "$1" > "$2"
}

__Tools__Procyon__class__info() {
  local tool_path
  tool_path=$(@ "$_CLASS" path)
  if [[ -z "$tool_path" ]] ; then
  _throw "ToolError" "procyon is not installed"
  return 1
  fi
  "$tool_path" - - help 2 >& 1 | head -20
}

__Tools__Procyon__class__compileNative_() {
  local trashFile="$1"
  local tool_path
  tool_path=$(@ "$_CLASS" path)
  if [[ -z "$tool_path" ]] ; then
  _throw "ToolError" "procyon is not installed"
  return 1
  fi
  local trash_file="$1"
  # Validate input file exists
  if [[ ! -f "$trash_file" ]] ; then
  _throw "FileError" "File not found: $trash_file"
  return 1
  fi
  # Extract class name from filename (e.g., Counter.trash -> Counter)
  local basename=$(basename "$trash_file" .trash)
  # Handle namespaced classes in subdirectories (e.g., Yutani/Widget.trash -> Yutani__Widget)
  local dir=$(dirname "$trash_file")
  local class_name="$basename"
  # Check if it's in a package subdirectory under trash/
  # Use grep to avoid glob pattern issues with the compiler
  if echo "$dir" | grep -q "/trash/" ; then
  local pkg=$(basename "$dir")
  if [[ "$pkg" != "trash" && "$pkg" != "." ]] ; then
  class_name="${pkg}__${basename}"
  fi
  fi
  echo "Compiling $trash_file -> $class_name.native" >& 2
  # Create temp build directory
  local build_dir=$(mktemp -d)
  trap "rm -rf '$build_dir'" EXIT
  # Step 1: Generate AST JSON
  echo "  [1/4] Generating AST..." >& 2
  local ast_file="$build_dir/ast.json"
  local trashtalk_root="${TRASHDIR%/trash}"
  if ! "$trashtalk_root/lib/jq-compiler/driver.bash" ast "$trash_file" > "$ast_file" 2 > /dev/null ; then
  _throw "CompileError" "Failed to parse $trash_file"
  return 1
  fi
  # Step 2: Compile to Go
  echo "  [2/4] Compiling to Go..." >& 2
  local go_file="$build_dir/main.go"
  if ! "$tool_path" < "$ast_file" > "$go_file" 2 > "$build_dir/procyon.log" ; then
  cat "$build_dir/procyon.log" >& 2
  _throw "CompileError" "Procyon failed to compile $trash_file"
  return 1
  fi
  # Show procyon output (skipped methods, etc.)
  if [[ -s "$build_dir/procyon.log" ]] ; then
  cat "$build_dir/procyon.log" >& 2
  fi
  # Step 3: Copy source file (needed for go:embed)
  echo "  [3/4] Building native binary..." >& 2
  cp "$trash_file" "$build_dir/$basename.trash"
  # Step 4: Initialize go module and build
  (
  cd "$build_dir"
  go mod init "trashtalk/$class_name" > /dev/null 2 >& 1
  go mod tidy > /dev/null 2 >& 1
  local output_dir="$TRASHDIR/.compiled"
  local native_binary="$output_dir/${class_name}.native"
  if ! go build -o "$native_binary" "." 2 > "$build_dir/go.log" ; then
  cat "$build_dir/go.log" >& 2
  _throw "BuildError" "Go build failed"
  return 1
  fi
  echo "  [4/4] Installed: $native_binary" >& 2
  echo "$native_binary"
  )
}

__Tools__Procyon__class__compileAll() {
  local count=0
  local failed=0
  echo "Compiling all .trash files to native binaries..." >& 2
  for trash_file in "$TRASHDIR" / * . trash ; do
  [[ -f "$trash_file" ]] || continue
  local basename=$(basename "$trash_file" .trash)
  # Skip traits
  [[ -d "$TRASHDIR/traits/$basename.trash" ]] && continue
  if @ "$_CLASS" compileNative: "$trash_file" > /dev/null 2 >& 1 ; then
  ((count++))
  else
  ((failed++))
  echo "  Failed: $basename" >& 2
  fi
  done
  echo "Compiled $count classes ($failed failed)" >& 2
  echo "$count"
}

__Tools__Procyon__class__removeNative_() {
  local className="$1"
  local native_binary="$TRASHDIR/.compiled/${1}.native"
  if [[ -f "$native_binary" ]] ; then
  rm "$native_binary"
  echo "Removed: $native_binary" >& 2
  echo "true"
  else
  echo "Not found: $native_binary" >& 2
  echo "false"
  fi
}

__Tools__Procyon__class__listNative() {
  local count=0
  for native in "$TRASHDIR" / . compiled / * . native ; do
  [[ -f "$native" ]] || continue
  basename "$native" . native
  ((count++))
  done
  echo "($count native binaries)" >& 2
}

