#!/usr/bin/env bash
# Generated by Trashtalk Compiler (jq) - DO NOT EDIT
# Source: Persistable.trash (trait)
# Generated: 2026-01-12T23:17:03

__Persistable__is_trait="1"
__Persistable__sourceHash="0df183fb4cb0e60064ec6cb099c5da4a5c3ae93c53c1726ff02e5d180c35b79f"

__Persistable__source() {
  cat <<'__TRASHTALK_SOURCE_EOF__'
# Persistable trait - provides database persistence for objects
# Objects including this trait can be saved to and loaded from the Store (SQLite).
#
# Usage:
#   Counter subclass: Object
#     include: Persistable
#     instanceVars: value:0
#
#   # Create and save in one step
#   counter=$(@ Counter create)
#
#   # Or create, modify, then save
#   counter=$(@ Counter new)
#   @ $counter increment
#   @ $counter save
#
#   # Query persisted objects
#   @ Counter findAll           # All saved Counter instances
#   @ Counter find 'value > 5'  # Filtered query
#   @ Counter count             # Number of saved instances

Persistable trait

  # Save this object to the Store (idempotent - creates or updates)
  method: save [
    | data |
    data := @ Runtime dataFor: self
    @ Store put: self data: data
  ]

  # Delete this object from the Store (keeps it in memory)
  method: unpersist [
    @ Store deleteInstance: self
  ]

  # Delete this object from both memory and Store
  method: delete [
    @ Store deleteInstance: self
    @ Runtime delete: self
  ]

  # Check if this object is persisted in the Store
  method: isPersisted [
    ^ @ Store exists: self
  ]

  # Reload this object from the Store (discards in-memory changes)
  method: reload [
    | data |
    data := @ Store getInstance: self
    @ Runtime setData: data for: self
  ]

  # Return this object's data as JSON
  method: asJson [
    ^ @ Runtime dataFor: self
  ]

  # Create a new instance and immediately save it to the Store
  # Usage: counter=$(@ Counter create)
  classMethod: create [
    | id |
    id := @ self new
    @ id save
    ^ id
  ]

  # Return all persisted instance IDs for this class
  # Usage: @ Counter findAll
  classMethod: findAll [
    ^ @ Store findByClass: self
  ]

  # Return count of persisted instances for this class
  # Usage: @ Counter count
  classMethod: count [
    ^ @ Store countByClass: self
  ]

  # Find persisted instances matching a predicate
  # Usage: @ Counter find 'value > 5'
  # Supports: =, !=, >, <, >=, <=
  # Returns: newline-separated list of instance IDs
  # Note: Uses raw bash for predicate parsing
  classMethod: find: predicate [
    pragma: primitive
    local predicate="$1"

    if [[ -z "$predicate" ]]; then
      @ Store findByClass: "$_RECEIVER"
      return
    fi

    _find_with_predicate "$_RECEIVER" "$predicate"
  ]

  # Load all persisted instances of this class into memory
  # Usage: @ Counter loadAll
  # Note: Uses raw bash for iteration over newline-separated IDs
  classMethod: loadAll [
    pragma: primitive
    local ids id
    ids=$(@ Store findByClass: "$_RECEIVER")
    for id in $ids; do
      @ "$id" reload 2>/dev/null
    done
  ]
__TRASHTALK_SOURCE_EOF__
}

__Persistable__save() {
  local data
  data="$(@ Runtime dataFor: "$_RECEIVER")"
  @ Store put: "$_RECEIVER" data: "$data"
}

__Persistable__unpersist() {
  @ Store deleteInstance: "$_RECEIVER"
}

__Persistable__delete() {
  @ Store deleteInstance: "$_RECEIVER"
  @ Runtime delete: "$_RECEIVER"
}

__Persistable__isPersisted() {
  @ Store exists: "$_RECEIVER"; return
}

__Persistable__reload() {
  local data
  data="$(@ Store getInstance: "$_RECEIVER")"
  @ Runtime setData: "$data" for: "$_RECEIVER"
}

__Persistable__asJson() {
  @ Runtime dataFor: "$_RECEIVER"; return
}

__Persistable__class__create() {
  local id
  id="$(@ "$_RECEIVER" new)"
  @ "$id" save
  echo "$id"; return
}

__Persistable__class__findAll() {
  @ Store findByClass: "$_RECEIVER"; return
}

__Persistable__class__count() {
  @ Store countByClass: "$_RECEIVER"; return
}

__Persistable__class__find_() {
  local predicate="$1"
    local predicate="$1"

    if [[ -z "$predicate" ]]; then
        @ Store findByClass: "$_RECEIVER"
        return
    fi

    _find_with_predicate "$_RECEIVER" "$predicate"
}

__Persistable__class__loadAll() {
    local ids id
    ids=$(@ Store findByClass: "$_RECEIVER")
    for id in $ids; do
        @ "$id" reload 2>/dev/null
    done
}
