#!/usr/bin/env bash
# Generated by Trashtalk Compiler (jq) - DO NOT EDIT
# Source: Debuggable.trash (trait)
# Generated: 2026-01-12T23:41:06

__Debuggable__is_trait="1"
__Debuggable__sourceHash="3e1fe966cd265e941be5d6cb13b7abbb7dc6fdd8fcd24e5b4938cdf290ad9139"

__Debuggable__source() {
  cat <<'__TRASHTALK_SOURCE_EOF__'
# Debuggable trait - provides debugging capabilities to objects
# All methods are pure Trashtalk (no pragmas) for native compilation
Debuggable trait

  # Output debug message to stderr with timestamp
  # Usage: @ self debug: 'Something happened'
  method: debug: message [
    | timestamp output |
    timestamp := @ Time nowFormatted: '%Y-%m-%d %H:%M:%S'.
    output := "[" , timestamp , "] DEBUG (" , self , "): " , message.
    @ Console error: output
  ]

  # Trace a method call
  # Usage: @ self trace: 'increment' args: '5'
  method: trace: methodName args: args [
    | msg |
    msg := "Calling " , methodName , " with args: " , args.
    @ self debug: msg
  ]

  # Inspect object details - shows class and available methods
  # Usage: @ self inspect
  method: inspect [
    | className methods line |
    className := @ Runtime classFor: self.
    methods := @ Runtime methodsFor: className.
    line := "Object: " , self.
    @ Console print: line.
    line := "Class: " , className.
    @ Console print: line.
    @ Console print: 'Methods:'.
    line := "  " , methods.
    @ Console print: line
  ]

  # Show the inheritance chain for this object's class
  # Usage: @ self ancestry
  method: ancestry [
    | className currentClass superclass line |
    className := @ Runtime classFor: self.
    line := "Inheritance chain for " , self.
    @ Console print: line.
    line := "  " , className.
    @ Console print: line.
    currentClass := className.
    [currentClass notEmpty] whileTrue: [
      superclass := @ Runtime superclassOf: currentClass.
      superclass notEmpty ifTrue: [
        line := "  " , superclass.
        @ Console print: line
      ].
      currentClass := superclass
    ]
  ]
__TRASHTALK_SOURCE_EOF__
}

__Debuggable__debug_() {
  local message="$1"
  local timestamp output
  timestamp="$(@ Time nowFormatted: '%Y-%m-%d %H:%M:%S')"
  output="[${timestamp}] DEBUG ($_RECEIVER): ${message}"
  @ Console error: "$output"
}

__Debuggable__trace_args_() {
  local methodName="$1"
  local args="$2"
  local msg
  msg="Calling ${methodName} with args: ${args}"
  @ "$_RECEIVER" debug: "$msg"
}

__Debuggable__inspect() {
  local className methods line
  className="$(@ Runtime classFor: "$_RECEIVER")"
  methods="$(@ Runtime methodsFor: "$className")"
  line="Object: $_RECEIVER"
  @ Console print: "$line"
  line="Class: ${className}"
  @ Console print: "$line"
  @ Console print: 'Methods:'
  line="  ${methods}"
  @ Console print: "$line"
}

__Debuggable__ancestry() {
  local className currentClass superclass line
  className="$(@ Runtime classFor: "$_RECEIVER")"
  line="Inheritance chain for $_RECEIVER"
  @ Console print: "$line"
  line="  ${className}"
  @ Console print: "$line"
  currentClass="$className"
  while [[ -n "$currentClass" ]]; do superclass="$(@ Runtime superclassOf: "$currentClass")"; if [[ -n "$superclass" ]]; then line="  ${superclass}"; @ Console print: "$line"; fi; currentClass="$superclass"; done
}
