#!/usr/bin/env bash
# Generated by Trashtalk Compiler (jq) - DO NOT EDIT
# Source: Protocol.trash
# Generated: 2026-01-12T21:19:12

__Protocol__superclass="Object"
__Protocol__instanceVars=""
__Protocol__classInstanceVars=""
__Protocol__traits=""
__Protocol__sourceHash="f49c377c051af7230c7be476f0703005c11e68b977e743e7551a695e4c221d60"
__Protocol__primitiveClass="1"

__Protocol__source() {
  cat <<'__TRASHTALK_SOURCE_EOF__'
# Protocol - Base class for protocol definitions
# Protocols define required methods that implementing classes must provide
Protocol subclass: Object
  pragma: primitiveClass

  # Returns the list of required method selectors as space-separated string
  # Populated from __ProtocolName__requires metadata by compiler
  classMethod: requiredMethods [
    local req_var="__${_CLASS}__requires"
    echo "${!req_var:-}"
  ]

  # Check if a class satisfies this protocol's requirements
  classMethod: isSatisfiedBy: className [
    local class_to_check="$1"
    local required selector
    required=$(@ "$_CLASS" requiredMethods)

    # If no requirements, trivially satisfied
    [[ -z "$required" ]] && echo "true" && return 0

    # Check each required method
    for selector in $required; do
      if ! _class_has_method "$class_to_check" "$selector"; then
        echo "false"
        return 0
      fi
    done

    echo "true"
  ]
__TRASHTALK_SOURCE_EOF__
}

__Protocol__class__requiredMethods() {
    local req_var="__${_CLASS}__requires"
    echo "${!req_var:-}"
}

__Protocol__class__isSatisfiedBy_() {
  local className="$1"
    local class_to_check="$1"
    local required selector
    required=$(@ "$_CLASS" requiredMethods)

    # If no requirements, trivially satisfied
    [[ -z "$required" ]] && echo "true" && return 0

    # Check each required method
    for selector in $required; do
        if ! _class_has_method "$class_to_check" "$selector"; then
            echo "false"
            return 0
        fi
    done

    echo "true"
}
