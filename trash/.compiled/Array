#!/usr/bin/env bash
# Generated by Trashtalk Compiler (jq) - DO NOT EDIT
# Source: Array.trash
# Generated: 2026-01-12T23:30:37

__Array__superclass="Object"
__Array__instanceVars="items:[]"
__Array__classInstanceVars=""
__Array__traits="Debuggable Persistable"
__Array__sourceHash="dc8679e864c9893281d43e51e3431a456aaade3bc277eee725dc85fc266eec29"

__Array__source() {
  cat <<'__TRASHTALK_SOURCE_EOF__'
# Array - Collection object for managing lists
Array subclass: Object
  include: Debuggable
  include: Persistable
  instanceVars: items:'[]'

  # Create a new array
  classMethod: new [
    | id |
    id := @ Runtime generateId: "Array"
    @ Runtime create: "Array" id: id
    ^ id
  ]

  # Create array from newline-separated text
  # Usage: arr := @ Array fromLines: "a\nb\nc"
  # Returns array containing ["a", "b", "c"]
  classMethod: fromLines: text [
    | arr jsonArray |
    arr := @ Array new.
    jsonArray := text stringToJsonArray.
    @ arr setItems: jsonArray.
    ^ arr
  ]

  # Accessor for items ivar
  method: getItems [
    ^ items
  ]

  # Setter for items ivar
  method: setItems: newItems [
    items := newItems
  ]

  # Private helper - get the raw items JSON array
  method: _getItemsArray [
    ^ items
  ]

  # Get element at index
  method: at: index [
    ^ items arrayAt: index
  ]

  # Set element at index
  method: at: index put: value [
    items := items arrayAt: index put: value
    ^ value
  ]

  # Add element to end
  method: push: value [
    items := items arrayPush: value
    ^ value
  ]

  # Remove and return last element
  method: pop [
    | last |
    last := items arrayLast
    items := items arrayRemoveAt: -1
    ^ last
  ]

  # Get array length
  method: size [
    ^ items arrayLength
  ]

  # Check if array is empty
  method: isEmpty [
    ^ items arrayIsEmpty
  ]

  # Get first element
  method: first [
    ^ items arrayFirst
  ]

  # Get last element
  method: last [
    ^ items arrayLast
  ]

  # Print array contents
  method: show [
    (items arrayIsEmpty) ifTrue: [^ '(empty array)'] ifFalse: [^ items]
  ]

  # Initialize with values
  method: withValues: values [
    pragma: primitive
    local items value
    items="[]"
    for value in $1; do
      items=$(echo "$items" | jq -c --arg v "$value" '. + [$v]')
    done
    _ivar_set items "$items"
    echo "$_RECEIVER"
  ]

  # Iterate over each element, calling block with each value
  # Usage: @ myArray do: [:each | @ Console print: each]
  method: do: aBlock [
    pragma: bashOnly
    | i len |
    len := items arrayLength.
    i := 0.
    [i < len] whileTrue: [
      @ aBlock valueWith: (items arrayAt: i).
      i := i + 1
    ]
  ]

  # Map each element through a block, returning new array
  # Usage: doubled := @ myArray collect: [:x | x * 2]
  method: collect: aBlock [
    pragma: bashOnly
    | i len newItems result newArray |
    len := items arrayLength.
    newItems := '[]'.
    i := 0.
    [i < len] whileTrue: [
      result := @ aBlock valueWith: (items arrayAt: i).
      newItems := newItems arrayPush: result.
      i := i + 1
    ].
    newArray := @ Array new.
    @ newArray setItems: newItems.
    ^ newArray
  ]

  # Select elements where block returns true (non-empty string)
  # Usage: evens := @ myArray select: [:x | x % 2 == 0]
  method: select: aBlock [
    pragma: bashOnly
    | i len newItems element result newArray |
    len := items arrayLength.
    newItems := '[]'.
    i := 0.
    [i < len] whileTrue: [
      element := items arrayAt: i.
      result := @ aBlock valueWith: element.
      result notEmpty ifTrue: [
        newItems := newItems arrayPush: element
      ].
      i := i + 1
    ].
    newArray := @ Array new.
    @ newArray setItems: newItems.
    ^ newArray
  ]

  # Find first element where block returns true
  # Usage: found := @ myArray detect: [:x | x > 5]
  # Returns empty string if no match found
  method: detect: aBlock [
    pragma: bashOnly
    | i len element result |
    len := items arrayLength.
    i := 0.
    [i < len] whileTrue: [
      element := items arrayAt: i.
      result := @ aBlock valueWith: element.
      result notEmpty ifTrue: [^ element].
      i := i + 1
    ].
    ^ ''
  ]

  # Find first element where block returns true, with default
  # Usage: found := @ myArray detect: [:x | x > 5] ifNone: ['not found']
  method: detect: aBlock ifNone: defaultBlock [
    pragma: bashOnly
    | i len element result |
    len := items arrayLength.
    i := 0.
    [i < len] whileTrue: [
      element := items arrayAt: i.
      result := @ aBlock valueWith: element.
      result notEmpty ifTrue: [^ element].
      i := i + 1
    ].
    ^ @ defaultBlock value
  ]

  # Reduce array to single value using block
  # Usage: sum := @ myArray inject: 0 into: [:acc :each | acc + each]
  method: inject: initial into: aBlock [
    pragma: bashOnly
    | i len acc |
    len := items arrayLength.
    acc := initial.
    i := 0.
    [i < len] whileTrue: [
      acc := @ aBlock valueWith: acc and: (items arrayAt: i).
      i := i + 1
    ].
    ^ acc
  ]
__TRASHTALK_SOURCE_EOF__
}

__Array__items() {
  echo "$(_ivar items)"; return
}

__Array__items_() {
  _ivar_set items "$1"
}

__Array__getItems() {
  echo "$(_ivar items)"; return
}

__Array__setItems_() {
  _ivar_set items "$1"
}

__Array__class__new() {
  local id
  id="$(@ Runtime generateId: "Array")"
  @ Runtime create: "Array" id: "$id"
  echo "$id"; return
}

__Array__class__fromLines_() {
  local text="$1"
  local arr jsonArray
  arr="$(@ Array new)"
  jsonArray="$(echo "$text" | jq -Rc '[., inputs]')"
  @ "$arr" setItems: "$jsonArray"
  echo "$arr"; return
}

__Array__getItems() {
  echo "$(_ivar items)"; return
}

__Array__setItems_() {
  local newItems="$1"
  _ivar_set items "$newItems"
}

__Array___getItemsArray() {
  echo "$(_ivar items)"; return
}

__Array__at_() {
  local index="$1"
  echo "$(echo "$(_ivar items)" | jq -r --argjson i "$index" '.[$i] // empty')"; return
}

__Array__at_put_() {
  local index="$1"
  local value="$2"
  _ivar_set items "$(echo "$(_ivar items)" | jq -c --argjson i "$index" --arg v "$value" '.[$i] = $v')"
  echo "$value"; return
}

__Array__push_() {
  local value="$1"
  _ivar_set items "$(echo "$(_ivar items)" | jq -c --arg v "$value" '. + [$v]')"
  echo "$value"; return
}

__Array__pop() {
  local last
  last="$(echo "$(_ivar items)" | jq -r '.[-1] // empty')"
  _ivar_set items "$(echo "$(_ivar items)" | jq -c --argjson i "-1" 'del(.[$i])')"
  echo "$last"; return
}

__Array__size() {
  echo "$(echo "$(_ivar items)" | jq 'length')"; return
}

__Array__isEmpty() {
  echo "$(echo "$(_ivar items)" | jq 'length == 0')"; return
}

__Array__first() {
  echo "$(echo "$(_ivar items)" | jq -r '.[0] // empty')"; return
}

__Array__last() {
  echo "$(echo "$(_ivar items)" | jq -r '.[-1] // empty')"; return
}

__Array__show() {
  if [[ "$(echo "$(_ivar items)" | jq 'length == 0')" == "true" ]]; then echo "(empty array)"; return; else echo "$(_ivar items)"; return; fi
}

__Array__withValues_() {
  local values="$1"
    local items value
    items="[]"
    for value in $1; do
        items=$(echo "$items" | jq -c --arg v "$value" '. + [$v]')
    done
    _ivar_set items "$items"
    echo "$_RECEIVER"
}

declare -g __Array__do___bashOnly=1
__Array__do_() {
  local aBlock="$1"
  local i len
  len="$(echo "$(_ivar items)" | jq 'length')"
  i="0"
  while (( $i < $len )); do @ "$aBlock" valueWith: "$(echo "$(_ivar items)" | jq -r --argjson i "$i" '.[$i] // empty')"; (( i = ($i + 1) )); done
}

declare -g __Array__collect___bashOnly=1
__Array__collect_() {
  local aBlock="$1"
  local i len newItems result newArray
  len="$(echo "$(_ivar items)" | jq 'length')"
  newItems="[]"
  i="0"
  while (( $i < $len )); do result="$(@ "$aBlock" valueWith: "$(echo "$(_ivar items)" | jq -r --argjson i "$i" '.[$i] // empty')")"; newItems="$(echo "$newItems" | jq -c --arg v "$result" '. + [$v]')"; (( i = ($i + 1) )); done
  newArray="$(@ Array new)"
  @ "$newArray" setItems: "$newItems"
  echo "$newArray"; return
}

declare -g __Array__select___bashOnly=1
__Array__select_() {
  local aBlock="$1"
  local i len newItems element result newArray
  len="$(echo "$(_ivar items)" | jq 'length')"
  newItems="[]"
  i="0"
  while (( $i < $len )); do element="$(echo "$(_ivar items)" | jq -r --argjson i "$i" '.[$i] // empty')"; result="$(@ "$aBlock" valueWith: "$element")"; if [[ -n "$result" ]]; then newItems="$(echo "$newItems" | jq -c --arg v "$element" '. + [$v]')"; fi; (( i = ($i + 1) )); done
  newArray="$(@ Array new)"
  @ "$newArray" setItems: "$newItems"
  echo "$newArray"; return
}

declare -g __Array__detect___bashOnly=1
__Array__detect_() {
  local aBlock="$1"
  local i len element result
  len="$(echo "$(_ivar items)" | jq 'length')"
  i="0"
  while (( $i < $len )); do element="$(echo "$(_ivar items)" | jq -r --argjson i "$i" '.[$i] // empty')"; result="$(@ "$aBlock" valueWith: "$element")"; if [[ -n "$result" ]]; then echo "$element"; return; fi; (( i = ($i + 1) )); done
  echo ""; return
}

declare -g __Array__detect_ifNone___bashOnly=1
__Array__detect_ifNone_() {
  local aBlock="$1"
  local defaultBlock="$2"
  local i len element result
  len="$(echo "$(_ivar items)" | jq 'length')"
  i="0"
  while (( $i < $len )); do element="$(echo "$(_ivar items)" | jq -r --argjson i "$i" '.[$i] // empty')"; result="$(@ "$aBlock" valueWith: "$element")"; if [[ -n "$result" ]]; then echo "$element"; return; fi; (( i = ($i + 1) )); done
  @ "$defaultBlock" value; return
}

declare -g __Array__inject_into___bashOnly=1
__Array__inject_into_() {
  local initial="$1"
  local aBlock="$2"
  local i len acc
  len="$(echo "$(_ivar items)" | jq 'length')"
  acc="$initial"
  i="0"
  while (( $i < $len )); do acc="$(@ "$aBlock" valueWith: "$acc" and: "$(echo "$(_ivar items)" | jq -r --argjson i "$i" '.[$i] // empty')")"; (( i = ($i + 1) )); done
  echo "$acc"; return
}
