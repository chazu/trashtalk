#!/usr/bin/env bash
# Generated by Trashtalk Compiler (jq) - DO NOT EDIT
# Source: Trash.trash
# Generated: 2026-01-04T02:41:36

__Trash__superclass="Object"
__Trash__instanceVars=""
__Trash__classInstanceVars=""
__Trash__traits="Debuggable"
__Trash__sourceHash="7e5f8825e007c0c81455dc03b2becbc098ad3598b4fbf770a25309c6a2881989"

__Trash__source() {
  cat <<'__TRASHTALK_SOURCE_EOF__'
# Trash - The system object representing the entire trash system
# Provides introspection, management, and system-wide operations
Trash subclass: Object
  include: Debuggable

  # Get system information
  method: info [
    echo "=== Trash System Information ==="
    echo "Version: 0.1.0"
    echo "Directory: $TRASHDIR"
    echo "Objects: $(@ self listObjects | wc -l)"
    echo "Traits: $(@ self listTraits | wc -l)"
    echo "Active Processes: $(@ Process listProcesses | wc -l)"
    echo "Database: $SQLITE_JSON_DB"
  ]

  # List all available objects (compiled classes)
  method: listObjects [
    find "$TRASHDIR/.compiled" -maxdepth 1 -type f 2>/dev/null | while read -r file; do
      basename "$file"
    done | sort
  ]

  # List all available traits (compiled traits)
  method: listTraits [
    if [[ -d "$TRASHDIR/.compiled/traits" ]]; then
      find "$TRASHDIR/.compiled/traits" -type f 2>/dev/null | while read -r file; do
        basename "$file"
      done | sort
    fi
  ]

  # Get methods available on a class
  rawMethod: methodsFor: class_name [
    local compiled_file="$TRASHDIR/.compiled/$class_name"
    local runtime_file="$TRASHDIR/$class_name"

    # Check for compiled or runtime class file
    if [[ -f "$compiled_file" ]]; then
      source "$compiled_file"
    elif [[ -f "$runtime_file" ]]; then
      source "$runtime_file"
    else
      echo "Class $class_name not found"
      return 1
    fi

    echo "Methods for $class_name:"
    # List functions defined for this class
    declare -F | awk '{print $3}' | grep "^__${class_name}__" | grep -v "__class__" | sed "s/__${class_name}__/  /"

    # Show class methods
    echo "Class methods:"
    declare -F | awk '{print $3}' | grep "^__${class_name}__class__" | sed "s/__${class_name}__class__/  /"

    # Show trait methods
    local traits_var="__${class_name}__traits"
    local traits="${!traits_var:-}"
    if [[ -n "$traits" ]]; then
      for trait in $traits; do
        local trait_file="$TRASHDIR/.compiled/traits/$trait"
        if [[ -f "$trait_file" ]]; then
          source "$trait_file"
          echo ""
          echo "From trait $trait:"
          declare -F | awk '{print $3}' | grep "^__${trait}__" | grep -v "__class__" | sed "s/__${trait}__/  /"
          # Trait class methods
          local trait_class_methods
          trait_class_methods=$(declare -F | awk '{print $3}' | grep "^__${trait}__class__" | sed "s/__${trait}__class__/  /")
          if [[ -n "$trait_class_methods" ]]; then
            echo "  (class methods):"
            echo "$trait_class_methods" | sed 's/^/  /'
          fi
        fi
      done
    fi

    # Show inherited methods
    local super_var="__${class_name}__superclass"
    local superclass="${!super_var:-}"
    if [[ -n "$superclass" && "$superclass" != "nil" && "$superclass" != "Object" ]]; then
      echo ""
      echo "(inherited from $superclass)"
      @ "$_RECEIVER" methodsFor: "$superclass" | sed 's/^/  /'
    fi
  ]

  # Get methods in a specific category for a class
  rawMethod: methodsIn: class_name category: cat_name [
    # Get compiled class metadata
    local compiled_file="$TRASHDIR/.compiled/$class_name"
    if [[ ! -f "$compiled_file" ]]; then
      echo "Error: Class $class_name not found"
      return 1
    fi

    # Source the class to get metadata
    source "$compiled_file"

    # Get method categories metadata
    local cats_var="__${class_name}__methodCategories"
    local cats="${!cats_var:-}"

    if [[ -z "$cats" ]]; then
      echo "No categorized methods for $class_name"
      return 0
    fi

    # Parse and filter by category
    echo "Methods in '$cat_name' for $class_name:"
    for entry in $cats; do
      local method="${entry%%:*}"
      local category="${entry#*:}"
      if [[ "$category" == "$cat_name" ]]; then
        echo "  $method"
      fi
    done
  ]

  # List all categories for a class
  rawMethod: categoriesFor: class_name [
    # Get compiled class metadata
    local compiled_file="$TRASHDIR/.compiled/$class_name"
    if [[ ! -f "$compiled_file" ]]; then
      echo "Error: Class $class_name not found"
      return 1
    fi

    # Source the class to get metadata
    source "$compiled_file"

    # Get method categories metadata
    local cats_var="__${class_name}__methodCategories"
    local cats="${!cats_var:-}"

    if [[ -z "$cats" ]]; then
      echo "No categories for $class_name"
      return 0
    fi

    # Extract unique categories
    echo "Categories for $class_name:"
    local seen=""
    for entry in $cats; do
      local category="${entry#*:}"
      if [[ ! " $seen " =~ " $category " ]]; then
        echo "  $category"
        seen="$seen $category"
      fi
    done
  ]

  # Show inheritance hierarchy for a class
  rawMethod: hierarchyFor: class_name [
    local compiled_file="$TRASHDIR/.compiled/$class_name"
    local runtime_file="$TRASHDIR/$class_name"

    if [[ -f "$compiled_file" || -f "$runtime_file" ]]; then
      echo "Inheritance hierarchy for $class_name:"
      @ "$_RECEIVER" _showHierarchy: "$class_name" depth: 0
    else
      echo "Class $class_name not found"
      return 1
    fi
  ]

  # Helper for showing hierarchy (uses compiled metadata)
  rawMethod: _showHierarchy: class_name depth: depth [
    local indent="" i superclass super_var
    local compiled_file="$TRASHDIR/.compiled/$class_name"
    local runtime_file="$TRASHDIR/$class_name"

    for ((i=0; i<depth; i++)); do
      indent="  $indent"
    done
    echo "$indent$class_name"

    # Source class to get metadata
    if [[ -f "$compiled_file" ]]; then
      source "$compiled_file"
    elif [[ -f "$runtime_file" ]]; then
      source "$runtime_file"
    else
      return 0
    fi

    # Get superclass from metadata
    super_var="__${class_name}__superclass"
    superclass="${!super_var:-}"
    if [[ -n "$superclass" && "$superclass" != "nil" ]]; then
      @ "$_RECEIVER" _showHierarchy: "$superclass" depth: $((depth + 1))
    fi
  ]

  # Create a new class file with modern .trash syntax
  rawMethod: createObject: object_name super: superclass [
    local trash_file="$TRASHDIR/${object_name}.trash"
    superclass="${superclass:-Object}"

    if [[ -f "$trash_file" ]]; then
      echo "Class $object_name already exists"
      return 1
    fi

    cat > "$trash_file" << EOF
# $object_name - Created by Trash system
$object_name subclass: $superclass

  rawMethod: example [
    echo "Hello from $object_name"
  ]

  rawClassMethod: new [
    local id=\$(_generate_instance_id "$object_name")
    _create_instance "$object_name" "\$id"
    echo "\$id"
  ]
EOF

    echo "Created $trash_file (inherits from $superclass)"
    echo "Compiling..."
    "$SCRIPT_DIR/jq-compiler/driver.bash" compile "$trash_file" > "$TRASHDIR/.compiled/$object_name" 2>/dev/null
    source "$TRASHDIR/.compiled/$object_name"
    echo "✓ $object_name ready to use"
  ]

  # Remove an object (with confirmation)
  method: removeObject: object_name [
    | object_file confirmation |
    object_file := "$TRASHDIR/$object_name"
    if [[ ! -f "$object_file" ]]; then
      echo "Object $object_name not found"
      return 1
    fi
    echo "Are you sure you want to remove object $object_name? (y/N)"
    read -r confirmation
    if [[ "$confirmation" =~ ^[Yy]$ ]]; then
      rm "$object_file"
      echo "Removed object $object_name"
    else
      echo "Cancelled"
    fi
  ]

  # Reload all object stubs
  method: reload [
    echo "Reloading all object stubs..."
    initialize_trash
    echo "Reload complete"
  ]

  # Reload a single class (hot reload for development)
  rawMethod: reloadClass: class_name [
    if [[ -z "$class_name" ]]; then
      echo "Usage: @ Trash reloadClass <ClassName>"
      return 1
    fi

    local compiled_file="$TRASHDIR/.compiled/$class_name"
    local class_file="$TRASHDIR/$class_name"
    local trait_file="$TRASHDIR/traits/$class_name"
    local compiled_trait="$TRASHDIR/.compiled/traits/$class_name"

    # Clear the sourcing cache so the class will be re-sourced
    _clear_class_cache "$class_name"

    # Check if it's a trait
    if [[ -f "$compiled_trait" ]]; then
      echo "Reloading trait $class_name..."
      # Unset old trait functions
      while IFS= read -r func; do
        unset -f "$func" 2>/dev/null
      done < <(declare -F | awk '{print $3}' | grep "^__${class_name}__")
      # Source the compiled trait
      source "$compiled_trait"
      _mark_class_sourced "$class_name"
      echo "✓ Trait $class_name reloaded"
      return 0
    fi

    # Check for compiled class
    if [[ -f "$compiled_file" ]]; then
      echo "Reloading class $class_name..."
      # Unset old class functions
      while IFS= read -r func; do
        unset -f "$func" 2>/dev/null
      done < <(declare -F | awk '{print $3}' | grep "^__${class_name}__")
      # Source the compiled class
      source "$compiled_file"
      _mark_class_sourced "$class_name"
      echo "✓ Class $class_name reloaded"
      return 0
    fi

    # Fall back to legacy class file
    if [[ -f "$class_file" ]]; then
      echo "Reloading legacy class $class_name..."
      source "$class_file"
      _mark_class_sourced "$class_name"
      echo "✓ Legacy class $class_name reloaded"
      return 0
    fi

    echo "Error: Class $class_name not found"
    echo "Searched:"
    echo "  - $compiled_file"
    echo "  - $compiled_trait"
    echo "  - $class_file"
    return 1
  ]

  # Compile and reload a class from .trash source
  # Safe: compiles to temp file first, validates, only replaces on success
  rawMethod: compileAndReload: class_name [
    if [[ -z "$class_name" ]]; then
      echo "Usage: @ Trash compileAndReload <ClassName>"
      return 1
    fi

    local source_file="$TRASHDIR/${class_name}.trash"
    local user_source="$TRASHDIR/user/${class_name}.trash"
    local trait_source="$TRASHDIR/traits/${class_name}.trash"
    local target_file=""
    local file_to_compile=""
    local temp_file="/tmp/trash_compile_$$_${class_name}"

    # Find source file and determine target (check user dir before system dir)
    if [[ -f "$user_source" ]]; then
      file_to_compile="$user_source"
      target_file="$TRASHDIR/.compiled/$class_name"
      echo "Compiling user class $class_name..."
    elif [[ -f "$trait_source" ]]; then
      file_to_compile="$trait_source"
      target_file="$TRASHDIR/.compiled/traits/$class_name"
      echo "Compiling trait $class_name..."
    elif [[ -f "$source_file" ]]; then
      file_to_compile="$source_file"
      target_file="$TRASHDIR/.compiled/$class_name"
      echo "Compiling class $class_name..."
    else
      echo "Error: No source file found for $class_name"
      echo "Searched:"
      echo "  - $user_source"
      echo "  - $source_file"
      echo "  - $trait_source"
      return 1
    fi

    # Compile to temp file
    if ! "$SCRIPT_DIR/jq-compiler/driver.bash" compile "$file_to_compile" > "$temp_file" 2>&1; then
      echo "Compilation failed:"
      cat "$temp_file"
      rm -f "$temp_file"
      return 1
    fi

    # Validate bash syntax
    if ! bash -n "$temp_file" 2>&1; then
      echo "Syntax validation failed - class not updated"
      rm -f "$temp_file"
      return 1
    fi

    # Success - replace the compiled file
    mv "$temp_file" "$target_file"
    @ "$_RECEIVER" reloadClass "$class_name"
    return $?
  ]

  # Show system statistics
  method: stats [
    echo "=== Trash System Statistics ==="
    echo "Objects: $(@ self listObjects | wc -l)"
    echo "Traits: $(@ self listTraits | wc -l)"
    echo "KV entries: $(kvlist 2>/dev/null | wc -l)"
    echo "Active processes: $(@ Process listProcesses 2>/dev/null | wc -l)"
    echo "Memory usage: $(du -sh "$TRASHDIR" | cut -f1)"
    echo "KV store size: $(du -sh "$KV_USER_DIR" 2>/dev/null | cut -f1 || echo "0B")"
  ]

  # Clean up system
  method: cleanup [
    echo "Cleaning up trash system..."
    @ Process listProcesses >/dev/null 2>&1
    echo "Cleanup complete"
  ]

  # Show help
  method: help [
    echo "=== Trash System Commands ==="
    echo "@ Trash info                    - Show system information"
    echo "@ Trash listObjects             - List all objects"
    echo "@ Trash listTraits              - List all traits"
    echo "@ Trash methodsFor <object>     - Show methods for object"
    echo "@ Trash hierarchyFor <object>   - Show inheritance hierarchy"
    echo "@ Trash new <class>              - Create class skeleton and edit"
    echo "@ Trash edit <class>             - Edit class and recompile on save"
    echo "@ Trash createObject <name> [super] - Create new object (no edit)"
    echo "@ Trash removeObject <name>     - Remove object"
    echo "@ Trash reload                  - Reload all object stubs"
    echo "@ Trash reloadClass <class>     - Hot reload a single class"
    echo "@ Trash compileAndReload <class> - Compile and reload from .trash"
    echo "@ Trash stats                   - Show system statistics"
    echo "@ Trash cleanup                 - Clean up system"
    echo "@ Trash version                 - Show version information"
    echo "@ Trash inspect <object>        - Detailed object inspection"
    echo "@ Trash repl                    - Launch interactive REPL"
    echo ""
    echo "=== Instance Queries (use class methods) ==="
    echo "@ <Class> findAll               - Find all instances of class"
    echo "@ <Class> find '<predicate>'    - Find with predicate"
    echo "@ <Class> count                 - Count instances of class"
    echo "@ Store listClasses             - List classes with instances"
    echo ""
    echo "=== Debugging ==="
    echo "@ Trash showStack               - Show current call stack"
    echo "@ Trash clearStack              - Clear call stack"
    echo ""
    echo "=== Source Introspection ==="
    echo "@ Trash sourceFor: <class>      - Get embedded source code"
    echo "@ Trash hashFor: <class>        - Get source hash (SHA-256)"
  ]

  # Show version information
  method: version [
    echo "Trash System v$TRASH_VERSION"
    echo "Author: $TRASH_AUTHOR"
    echo "Description: $TRASH_DESCRIPTION"
    echo "Bash version: $BASH_VERSION"
    echo "System: $(uname -s) $(uname -r)"
  ]

  # Get the embedded source code for a class
  # Usage: @ Trash sourceFor: Counter
  rawMethod: sourceFor: class_name [
    local source_func="__${class_name}__source"
    if declare -f "$source_func" >/dev/null 2>&1; then
      "$source_func"
    else
      # Try loading the compiled class first
      local compiled_file="$TRASHDIR/.compiled/$class_name"
      if [[ -f "$compiled_file" ]]; then
        source "$compiled_file"
        if declare -f "$source_func" >/dev/null 2>&1; then
          "$source_func"
        else
          echo "Error: Class $class_name does not have embedded source"
          return 1
        fi
      else
        echo "Error: Class $class_name not found"
        return 1
      fi
    fi
  ]

  # Get the source hash for a class
  # Usage: @ Trash hashFor: Counter
  rawMethod: hashFor: class_name [
    local hash_var="__${class_name}__sourceHash"
    local compiled_file="$TRASHDIR/.compiled/$class_name"

    # Try to get from already-loaded class
    if [[ -n "${!hash_var:-}" ]]; then
      echo "${!hash_var}"
      return 0
    fi

    # Try loading the compiled class
    if [[ -f "$compiled_file" ]]; then
      source "$compiled_file"
      if [[ -n "${!hash_var:-}" ]]; then
        echo "${!hash_var}"
        return 0
      fi
    fi

    echo "Error: Could not get hash for $class_name"
    return 1
  ]

  # Launch interactive REPL
  # Note: For rlwrap support (history, completions), run bin/trash directly
  rawClassMethod: repl [
    local trashtalk_root
    trashtalk_root="$(dirname "$TRASHDIR")"
    "$trashtalk_root/bin/trash-repl"
  ]

  # Detailed object inspection
  method: inspect: object_name [
    | object_file traits state |
    if [[ -z "$object_name" ]]; then
      echo "Usage: @ Trash inspect <object_name>"
      return 1
    fi
    echo "=== Detailed Inspection: $object_name ==="
    object_file := "$TRASHDIR/$object_name"
    if [[ ! -f "$object_file" ]]; then
      echo "Object $object_name not found"
      return 1
    fi
    echo "File: $object_file"
    echo "Size: $(wc -l < "$object_file") lines"
    echo "Modified: $(stat -f "%Sm" "$object_file" 2>/dev/null || stat -c "%y" "$object_file" 2>/dev/null)"
    echo ""
    @ self hierarchyFor: "$object_name"
    echo ""
    @ self methodsFor: "$object_name"
    echo ""
    traits := $(grep "^include" "$object_file" | awk '{print $2}')
    if [[ -n "$traits" ]]; then
      echo "Traits:"
      echo "$traits" | sed 's/^/  /'
    else
      echo "Traits: none"
    fi
  ]

  # Create a new class with minimal skeleton and open in editor
  # New classes are created in the user directory (trash/user/)
  rawMethod: new: class_name [
    local user_file="$TRASHDIR/user/${class_name}.trash"
    local system_file="$TRASHDIR/${class_name}.trash"
    local trait_file="$TRASHDIR/traits/${class_name}.trash"

    # Check if class already exists anywhere
    if [[ -f "$user_file" ]]; then
      echo "Class $class_name already exists in user/. Use '@ Trash edit $class_name' to edit."
      return 1
    fi
    if [[ -f "$system_file" ]]; then
      echo "Class $class_name already exists as a system class. Use '@ Trash edit $class_name' to edit."
      return 1
    fi
    if [[ -f "$trait_file" ]]; then
      echo "A trait named $class_name already exists. Use '@ Trash edit $class_name' to edit."
      return 1
    fi

    # Ensure user directory exists
    mkdir -p "$TRASHDIR/user"

    # Create minimal skeleton in user directory
    printf '%s\n' \
      "$class_name subclass: Object" \
      "  instanceVars:" \
      "" \
      "  rawClassMethod: new [" \
      "    local id=\$(_generate_instance_id $class_name)" \
      "    _create_instance $class_name \"\$id\"" \
      "    echo \"\$id\"" \
      "  ]" \
      "" \
      "  method: example [" \
      "    ^ \"Hello from $class_name\"" \
      "  ]" \
      > "$user_file"

    echo "Created $user_file"

    # Open in editor and compile if saved
    local before_mtime after_mtime
    before_mtime=$(stat -f "%m" "$user_file" 2>/dev/null || stat -c "%Y" "$user_file" 2>/dev/null)

    ${EDITOR:-vi} "$user_file" </dev/tty >/dev/tty

    after_mtime=$(stat -f "%m" "$user_file" 2>/dev/null || stat -c "%Y" "$user_file" 2>/dev/null)

    if [[ "$before_mtime" != "$after_mtime" ]]; then
      echo "File modified, compiling..."
      @ "$_RECEIVER" compileAndReload "$class_name"
    else
      echo "No changes detected"
    fi
  ]

  # Edit an existing class and recompile on save
  rawMethod: edit: class_name [
    local trash_file="$TRASHDIR/${class_name}.trash"
    local user_file="$TRASHDIR/user/${class_name}.trash"
    local trait_file="$TRASHDIR/traits/${class_name}.trash"
    local file_to_edit=""

    # Find the source file (check user dir before system dir)
    if [[ -f "$user_file" ]]; then
      file_to_edit="$user_file"
    elif [[ -f "$trash_file" ]]; then
      file_to_edit="$trash_file"
    elif [[ -f "$trait_file" ]]; then
      file_to_edit="$trait_file"
    else
      echo "Error: No source file found for $class_name"
      echo "Searched:"
      echo "  - $user_file"
      echo "  - $trash_file"
      echo "  - $trait_file"
      echo ""
      echo "Use '@ Trash new $class_name' to create a new class."
      return 1
    fi

    # Open in editor and compile if saved
    local before_mtime after_mtime
    before_mtime=$(stat -f "%m" "$file_to_edit" 2>/dev/null || stat -c "%Y" "$file_to_edit" 2>/dev/null)

    ${EDITOR:-vi} "$file_to_edit" </dev/tty >/dev/tty

    after_mtime=$(stat -f "%m" "$file_to_edit" 2>/dev/null || stat -c "%Y" "$file_to_edit" 2>/dev/null)

    if [[ "$before_mtime" != "$after_mtime" ]]; then
      echo "File modified, compiling..."
      @ "$_RECEIVER" compileAndReload "$class_name"
    else
      echo "No changes detected"
    fi
  ]

  # Evaluate a string of Trashtalk code
  # Usage: @ Trash eval: 'counter := @ Counter new. @ counter increment. @ counter getValue'
  # Returns the result of the last expression
  rawClassMethod: eval: code [
    local temp_class="_TempEval_$$_$RANDOM"
    local temp_file="/tmp/${temp_class}.trash"
    local compiled_file="/tmp/${temp_class}.compiled"
    local result

    # Wrap code in a temporary class with a run method
    cat > "$temp_file" << EVALEOF
${temp_class} subclass: Object
  rawClassMethod: run [
    $1
  ]
EVALEOF

    # Compile the temporary class
    if ! "$SCRIPT_DIR/jq-compiler/driver.bash" compile "$temp_file" > "$compiled_file" 2>&1; then
      echo "Eval compile error:" >&2
      cat "$compiled_file" >&2
      rm -f "$temp_file" "$compiled_file"
      return 1
    fi

    # Validate bash syntax
    if ! bash -n "$compiled_file" 2>&1; then
      echo "Eval syntax error" >&2
      rm -f "$temp_file" "$compiled_file"
      return 1
    fi

    # Source and execute
    source "$compiled_file"
    result=$("__${temp_class}__class__run")
    local exit_code=$?

    # Clean up
    rm -f "$temp_file" "$compiled_file"
    # Unset the temporary functions
    unset -f "__${temp_class}__class__run" 2>/dev/null
    unset "__${temp_class}__superclass" 2>/dev/null
    unset "__${temp_class}__is_a" 2>/dev/null

    echo "$result"
    return $exit_code
  ]

  # Evaluate code from a file
  # Usage: @ Trash evalFile: '/path/to/script.trash'
  rawClassMethod: evalFile: filepath [
    if [[ ! -f "$1" ]]; then
      echo "Error: File not found: $1" >&2
      return 1
    fi
    local code
    code=$(cat "$1")
    @ Trash eval: "$code"
  ]

  # Quick class creation with template
  rawMethod: quickCreate: class_name template: template [
    template="${template:-basic}"
    local trash_file="$TRASHDIR/${class_name}.trash"

    if [[ -f "$trash_file" ]]; then
      echo "Class $class_name already exists"
      return 1
    fi

    case "$template" in
      "service")
        cat > "$trash_file" << EOF
# $class_name - Service template
$class_name subclass: Object
  include: Debuggable

  rawMethod: start [
    @ self debug: "Starting service..."
    echo "Service started"
  ]

  rawMethod: stop [
    @ self debug: "Stopping service..."
    echo "Service stopped"
  ]

  rawMethod: status [
    echo "Service is running"
  ]

  rawMethod: restart [
    @ "\$_RECEIVER" stop
    @ "\$_RECEIVER" start
  ]

  rawClassMethod: new [
    local id=\$(_generate_instance_id "$class_name")
    _create_instance "$class_name" "\$id"
    echo "\$id"
  ]
EOF
        ;;
      "actor")
        cat > "$trash_file" << EOF
# $class_name - Actor template (for use with Process)
$class_name subclass: Object
  include: Debuggable
  instanceVars: status:active

  rawMethod: receive: message [
    @ self debug: "Received message: \$message"
    case "\$message" in
      "ping") echo "pong" ;;
      "status") echo "active" ;;
      *) echo "Unknown message: \$message" ;;
    esac
  ]

  rawMethod: initialize [
    @ self debug: "Actor initialized"
  ]

  rawClassMethod: new [
    local id=\$(_generate_instance_id "$class_name")
    _create_instance "$class_name" "\$id"
    echo "\$id"
  ]
EOF
        ;;
      *)
        # Basic template
        cat > "$trash_file" << EOF
# $class_name - Created by Trash system
$class_name subclass: Object

  rawMethod: example [
    echo "Hello from $class_name"
  ]

  rawClassMethod: new [
    local id=\$(_generate_instance_id "$class_name")
    _create_instance "$class_name" "\$id"
    echo "\$id"
  ]
EOF
        ;;
    esac

    echo "Created $trash_file using $template template"
    echo "Compiling..."
    mkdir -p "$TRASHDIR/.compiled"
    "$SCRIPT_DIR/jq-compiler/driver.bash" compile "$trash_file" > "$TRASHDIR/.compiled/$class_name" 2>/dev/null
    source "$TRASHDIR/.compiled/$class_name"
    echo "✓ $class_name ready to use"
  ]
__TRASHTALK_SOURCE_EOF__
}

__Trash__info() {
  echo "=== Trash System Information ==="
  echo "Version: 0.1.0"
  echo "Directory: $TRASHDIR"
  echo "Objects: $(@ $_RECEIVER listObjects | wc -l)"
  echo "Traits: $(@ $_RECEIVER listTraits | wc -l)"
  echo "Active Processes: $(@ Process listProcesses | wc -l)"
  echo "Database: $SQLITE_JSON_DB"
}

__Trash__listObjects() {
  find "$TRASHDIR/.compiled" -maxdepth 1 -type f 2>/dev/null | while read -r file; do
  basename "$file"
  done | sort
}

__Trash__listTraits() {
  if [[ -d "$TRASHDIR/.compiled/traits" ]]; then
  find "$TRASHDIR/.compiled/traits" -type f 2>/dev/null | while read -r file; do
  basename "$file"
  done | sort
  fi
}

__Trash__methodsFor_() {
  local class_name="$1"
    local compiled_file="$TRASHDIR/.compiled/$class_name"
    local runtime_file="$TRASHDIR/$class_name"

    # Check for compiled or runtime class file
    if [[ -f "$compiled_file" ]]; then
        source "$compiled_file"
        elif [[ -f "$runtime_file" ]]; then
            source "$runtime_file"
            else
            echo "Class $class_name not found"
            return 1
        fi

        echo "Methods for $class_name:"
        # List functions defined for this class
        declare -F | awk '{print $3}' | grep "^__${class_name}__" | grep -v "__class__" | sed "s/__${class_name}__/ /"

        # Show class methods
        echo "Class methods:"
        declare -F | awk '{print $3}' | grep "^__${class_name}__class__" | sed "s/__${class_name}__class__/ /"

        # Show trait methods
        local traits_var="__${class_name}__traits"
        local traits="${!traits_var:-}"
        if [[ -n "$traits" ]]; then
            for trait in $traits; do
                local trait_file="$TRASHDIR/.compiled/traits/$trait"
                if [[ -f "$trait_file" ]]; then
                    source "$trait_file"
                    echo ""
                    echo "From trait $trait:"
                    declare -F | awk '{print $3}' | grep "^__${trait}__" | grep -v "__class__" | sed "s/__${trait}__/ /"
                    # Trait class methods
                    local trait_class_methods
                    trait_class_methods=$(declare -F | awk '{print $3}' | grep "^__${trait}__class__" | sed "s/__${trait}__class__/ /")
                    if [[ -n "$trait_class_methods" ]]; then
                        echo " (class methods):"
                        echo "$trait_class_methods" | sed 's/^/ /'
                    fi
                fi
            done
        fi

        # Show inherited methods
        local super_var="__${class_name}__superclass"
        local superclass="${!super_var:-}"
        if [[ -n "$superclass" && "$superclass" != "nil" && "$superclass" != "Object" ]]; then
            echo ""
            echo "(inherited from $superclass)"
            @ "$_RECEIVER" methodsFor: "$superclass" | sed 's/^/ /'
        fi
}

__Trash__methodsIn_category_() {
  local class_name="$1"
  local cat_name="$2"
    # Get compiled class metadata
    local compiled_file="$TRASHDIR/.compiled/$class_name"
    if [[ ! -f "$compiled_file" ]]; then
        echo "Error: Class $class_name not found"
        return 1
    fi

    # Source the class to get metadata
    source "$compiled_file"

    # Get method categories metadata
    local cats_var="__${class_name}__methodCategories"
    local cats="${!cats_var:-}"

    if [[ -z "$cats" ]]; then
        echo "No categorized methods for $class_name"
        return 0
    fi

    # Parse and filter by category
    echo "Methods in '$cat_name' for $class_name:"
    for entry in $cats; do
        local method="${entry%%:*}"
        local category="${entry#*:}"
        if [[ "$category" == "$cat_name" ]]; then
            echo " $method"
        fi
    done
}

__Trash__categoriesFor_() {
  local class_name="$1"
    # Get compiled class metadata
    local compiled_file="$TRASHDIR/.compiled/$class_name"
    if [[ ! -f "$compiled_file" ]]; then
        echo "Error: Class $class_name not found"
        return 1
    fi

    # Source the class to get metadata
    source "$compiled_file"

    # Get method categories metadata
    local cats_var="__${class_name}__methodCategories"
    local cats="${!cats_var:-}"

    if [[ -z "$cats" ]]; then
        echo "No categories for $class_name"
        return 0
    fi

    # Extract unique categories
    echo "Categories for $class_name:"
    local seen=""
    for entry in $cats; do
        local category="${entry#*:}"
        if [[ ! " $seen " =~ " $category " ]]; then
            echo " $category"
            seen="$seen $category"
        fi
    done
}

__Trash__hierarchyFor_() {
  local class_name="$1"
    local compiled_file="$TRASHDIR/.compiled/$class_name"
    local runtime_file="$TRASHDIR/$class_name"

    if [[ -f "$compiled_file" || -f "$runtime_file" ]]; then
        echo "Inheritance hierarchy for $class_name:"
        @ "$_RECEIVER" _showHierarchy: "$class_name" depth: 0
        else
        echo "Class $class_name not found"
        return 1
    fi
}

__Trash___showHierarchy_depth_() {
  local class_name="$1"
  local depth="$2"
    local indent="" i superclass super_var
    local compiled_file="$TRASHDIR/.compiled/$class_name"
    local runtime_file="$TRASHDIR/$class_name"

    for ((i=0; i<depth; i++)); do
        indent=" $indent"
    done
    echo "$indent$class_name"

    # Source class to get metadata
    if [[ -f "$compiled_file" ]]; then
        source "$compiled_file"
        elif [[ -f "$runtime_file" ]]; then
            source "$runtime_file"
            else
            return 0
        fi

        # Get superclass from metadata
        super_var="__${class_name}__superclass"
        superclass="${!super_var:-}"
        if [[ -n "$superclass" && "$superclass" != "nil" ]]; then
            @ "$_RECEIVER" _showHierarchy: "$superclass" depth: $((depth + 1))
        fi
}

__Trash__createObject_super_() {
  local object_name="$1"
  local superclass="$2"
    local trash_file="$TRASHDIR/${object_name}.trash"
    superclass="${superclass:-Object}"

    if [[ -f "$trash_file" ]]; then
        echo "Class $object_name already exists"
        return 1
    fi

    cat >"$trash_file" <<EOF
# $object_name - Created by Trash system
$object_name subclass: $superclass

rawMethod: example [
echo "Hello from $object_name"
]

rawClassMethod: new [
local id = \$(_generate_instance_id "$object_name")
_create_instance "$object_name" "\$id"
echo "\$id"
]
EOF

    echo "Created $trash_file (inherits from $superclass)"
    echo "Compiling..."
    "$SCRIPT_DIR/jq-compiler/driver.bash" compile "$trash_file" >"$TRASHDIR/.compiled/$object_name" 2>/dev/null
    source "$TRASHDIR/.compiled/$object_name"
    echo "✓ $object_name ready to use"
}

__Trash__removeObject_() {
  local object_name="$1"
  local object_file confirmation
  object_file="$TRASHDIR/$object_name"
  if [[ ! -f "$object_file" ]]; then
  echo "Object $object_name not found"
  return 1
  fi
  echo "Are you sure you want to remove object $object_name? (y/N)"
  read -r confirmation
  if [[ "$confirmation" =~ ^[Yy]$ ]]; then
  rm "$object_file"
  echo "Removed object $object_name"
  else
  echo "Cancelled"
  fi
}

__Trash__reload() {
  echo "Reloading all object stubs..."
  initialize_trash
  echo "Reload complete"
}

__Trash__reloadClass_() {
  local class_name="$1"
    if [[ -z "$class_name" ]]; then
        echo "Usage: @ Trash reloadClass <ClassName>"
        return 1
    fi

    local compiled_file="$TRASHDIR/.compiled/$class_name"
    local class_file="$TRASHDIR/$class_name"
    local trait_file="$TRASHDIR/traits/$class_name"
    local compiled_trait="$TRASHDIR/.compiled/traits/$class_name"

    # Clear the sourcing cache so the class will be re-sourced
    _clear_class_cache "$class_name"

    # Check if it's a trait
    if [[ -f "$compiled_trait" ]]; then
        echo "Reloading trait $class_name..."
        # Unset old trait functions
        while IFS= read -r func; do
            unset -f "$func" 2>/dev/null
        done < <(declare -F | awk '{print $3}' | grep "^__${class_name}__")
            # Source the compiled trait
            source "$compiled_trait"
            _mark_class_sourced "$class_name"
            echo "✓ Trait $class_name reloaded"
            return 0
        fi

        # Check for compiled class
        if [[ -f "$compiled_file" ]]; then
            echo "Reloading class $class_name..."
            # Unset old class functions
            while IFS= read -r func; do
                unset -f "$func" 2>/dev/null
            done < <(declare -F | awk '{print $3}' | grep "^__${class_name}__")
                # Source the compiled class
                source "$compiled_file"
                _mark_class_sourced "$class_name"
                echo "✓ Class $class_name reloaded"
                return 0
            fi

            # Fall back to legacy class file
            if [[ -f "$class_file" ]]; then
                echo "Reloading legacy class $class_name..."
                source "$class_file"
                _mark_class_sourced "$class_name"
                echo "✓ Legacy class $class_name reloaded"
                return 0
            fi

            echo "Error: Class $class_name not found"
            echo "Searched:"
            echo " - $compiled_file"
            echo " - $compiled_trait"
            echo " - $class_file"
            return 1
}

__Trash__compileAndReload_() {
  local class_name="$1"
    if [[ -z "$class_name" ]]; then
        echo "Usage: @ Trash compileAndReload <ClassName>"
        return 1
    fi

    local source_file="$TRASHDIR/${class_name}.trash"
    local user_source="$TRASHDIR/user/${class_name}.trash"
    local trait_source="$TRASHDIR/traits/${class_name}.trash"
    local target_file=""
    local file_to_compile=""
    local temp_file="/tmp/trash_compile_$$_${class_name}"

    # Find source file and determine target (check user dir before system dir)
    if [[ -f "$user_source" ]]; then
    file_to_compile="$user_source"
        target_file="$TRASHDIR/.compiled/$class_name"
        echo "Compiling user class $class_name..."
        elif [[ -f "$trait_source" ]]; then
        file_to_compile="$trait_source"
            target_file="$TRASHDIR/.compiled/traits/$class_name"
            echo "Compiling trait $class_name..."
            elif [[ -f "$source_file" ]]; then
            file_to_compile="$source_file"
                target_file="$TRASHDIR/.compiled/$class_name"
                echo "Compiling class $class_name..."
                else
                echo "Error: No source file found for $class_name"
                echo "Searched:"
                echo " - $user_source"
                echo " - $source_file"
                echo " - $trait_source"
                return 1
            fi

            # Compile to temp file
            if ! "$SCRIPT_DIR/jq-compiler/driver.bash" compile "$file_to_compile" >"$temp_file" 2>&1; then
                echo "Compilation failed:"
                cat "$temp_file"
                rm -f "$temp_file"
                return 1
            fi

            # Validate bash syntax
            if ! bash -n "$temp_file" 2>&1; then
                echo "Syntax validation failed - class not updated"
                rm -f "$temp_file"
                return 1
            fi

            # Success - replace the compiled file
            mv "$temp_file" "$target_file"
            @ "$_RECEIVER" reloadClass "$class_name"
            return $?
}

__Trash__stats() {
  echo "=== Trash System Statistics ==="
  echo "Objects: $(@ $_RECEIVER listObjects | wc -l)"
  echo "Traits: $(@ $_RECEIVER listTraits | wc -l)"
  echo "KV entries: $(kvlist 2>/dev/null | wc -l)"
  echo "Active processes: $(@ Process listProcesses 2>/dev/null | wc -l)"
  echo "Memory usage: $(du -sh "$TRASHDIR" | cut -f1)"
  echo "KV store size: $(du -sh "$KV_USER_DIR" 2>/dev/null | cut -f1 || echo "0B")"
}

__Trash__cleanup() {
  echo "Cleaning up trash system..."
  @ Process listProcesses >/dev/null 2>&1
  echo "Cleanup complete"
}

__Trash__help() {
  echo "=== Trash System Commands ==="
  echo "@ Trash info - Show system information"
  echo "@ Trash listObjects - List all objects"
  echo "@ Trash listTraits - List all traits"
  echo "@ Trash methodsFor <object> - Show methods for object"
  echo "@ Trash hierarchyFor <object> - Show inheritance hierarchy"
  echo "@ Trash new <class> - Create class skeleton and edit"
  echo "@ Trash edit <class> - Edit class and recompile on save"
  echo "@ Trash createObject <name> [super] - Create new object (no edit)"
  echo "@ Trash removeObject <name> - Remove object"
  echo "@ Trash reload - Reload all object stubs"
  echo "@ Trash reloadClass <class> - Hot reload a single class"
  echo "@ Trash compileAndReload <class> - Compile and reload from .trash"
  echo "@ Trash stats - Show system statistics"
  echo "@ Trash cleanup - Clean up system"
  echo "@ Trash version - Show version information"
  echo "@ Trash inspect <object> - Detailed object inspection"
  echo "@ Trash repl - Launch interactive REPL"
  echo ""
  echo "=== Instance Queries (use class methods) ==="
  echo "@ <Class> findAll - Find all instances of class"
  echo "@ <Class> find '<predicate>' - Find with predicate"
  echo "@ <Class> count - Count instances of class"
  echo "@ Store listClasses - List classes with instances"
  echo ""
  echo "=== Debugging ==="
  echo "@ Trash showStack - Show current call stack"
  echo "@ Trash clearStack - Clear call stack"
  echo ""
  echo "=== Source Introspection ==="
  echo "@ Trash sourceFor: <class> - Get embedded source code"
  echo "@ Trash hashFor: <class> - Get source hash (SHA-256)"
}

__Trash__version() {
  echo "Trash System v$TRASH_VERSION"
  echo "Author: $TRASH_AUTHOR"
  echo "Description: $TRASH_DESCRIPTION"
  echo "Bash version: $BASH_VERSION"
  echo "System: $(uname -s) $(uname -r)"
}

__Trash__sourceFor_() {
  local class_name="$1"
    local source_func="__${class_name}__source"
    if declare -f "$source_func" >/dev/null 2>&1; then
        "$source_func"
        else
        # Try loading the compiled class first
        local compiled_file="$TRASHDIR/.compiled/$class_name"
        if [[ -f "$compiled_file" ]]; then
            source "$compiled_file"
            if declare -f "$source_func" >/dev/null 2>&1; then
                "$source_func"
                else
                echo "Error: Class $class_name does not have embedded source"
                return 1
            fi
            else
            echo "Error: Class $class_name not found"
            return 1
        fi
    fi
}

__Trash__hashFor_() {
  local class_name="$1"
    local hash_var="__${class_name}__sourceHash"
    local compiled_file="$TRASHDIR/.compiled/$class_name"

    # Try to get from already-loaded class
    if [[ -n "${!hash_var:-}" ]]; then
        echo "${!hash_var}"
        return 0
    fi

    # Try loading the compiled class
    if [[ -f "$compiled_file" ]]; then
        source "$compiled_file"
        if [[ -n "${!hash_var:-}" ]]; then
            echo "${!hash_var}"
            return 0
        fi
    fi

    echo "Error: Could not get hash for $class_name"
    return 1
}

__Trash__class__repl() {
    local trashtalk_root
    trashtalk_root="$(dirname "$TRASHDIR")"
    "$trashtalk_root/bin/trash-repl"
}

__Trash__inspect_() {
  local object_name="$1"
  local object_file traits state
  if [[ -z "$object_name" ]]; then
  echo "Usage: @ Trash inspect <object_name>"
  return 1
  fi
  echo "=== Detailed Inspection: $object_name ==="
  object_file="$TRASHDIR/$object_name"
  if [[ ! -f "$object_file" ]]; then
  echo "Object $object_name not found"
  return 1
  fi
  echo "File: $object_file"
  echo "Size: $(wc -l < "$object_file") lines"
  echo "Modified: $(stat -f "%Sm" "$object_file" 2>/dev/null || stat -c "%y" "$object_file" 2>/dev/null)"
  echo ""
  @ "$_RECEIVER" hierarchyFor: "$object_name"
  echo ""
  @ "$_RECEIVER" methodsFor: "$object_name"
  echo ""
  traits=$(grep "^include" "$object_file" | awk '{print $2}')
  if [[ -n "$traits" ]]; then
  echo "Traits:"
  echo "$traits" | sed 's/^/ /'
  else
  echo "Traits: none"
  fi
}

__Trash__new_() {
  local class_name="$1"
    local user_file="$TRASHDIR/user/${class_name}.trash"
    local system_file="$TRASHDIR/${class_name}.trash"
    local trait_file="$TRASHDIR/traits/${class_name}.trash"

    # Check if class already exists anywhere
    if [[ -f "$user_file" ]]; then
        echo "Class $class_name already exists in user/. Use '@ Trash edit $class_name' to edit."
        return 1
    fi
    if [[ -f "$system_file" ]]; then
        echo "Class $class_name already exists as a system class. Use '@ Trash edit $class_name' to edit."
        return 1
    fi
    if [[ -f "$trait_file" ]]; then
        echo "A trait named $class_name already exists. Use '@ Trash edit $class_name' to edit."
        return 1
    fi

    # Ensure user directory exists
    mkdir -p "$TRASHDIR/user"

    # Create minimal skeleton in user directory
    printf '%s\n' \
        "$class_name subclass: Object" \
        " instanceVars:" \
        "" \
        " rawClassMethod: new [" \
        " local id=\$(_generate_instance_id $class_name)" \
        " _create_instance $class_name \" \$id \"" \
        " echo \" \$id \"" \
        " ]" \
        "" \
        " method: example [" \
        " ^ \" Hello from $class_name \"" \
        " ]" \
        >"$user_file"

    echo "Created $user_file"

    # Open in editor and compile if saved
    local before_mtime after_mtime
    before_mtime=$(stat -f "%m" "$user_file" 2>/dev/null || stat -c "%Y" "$user_file" 2>/dev/null)

    ${EDITOR:-vi} "$user_file" </dev/tty >/dev/tty

    after_mtime=$(stat -f "%m" "$user_file" 2>/dev/null || stat -c "%Y" "$user_file" 2>/dev/null)

    if [[ "$before_mtime" != "$after_mtime" ]]; then
        echo "File modified, compiling..."
        @ "$_RECEIVER" compileAndReload "$class_name"
        else
        echo "No changes detected"
    fi
}

__Trash__edit_() {
  local class_name="$1"
    local trash_file="$TRASHDIR/${class_name}.trash"
    local user_file="$TRASHDIR/user/${class_name}.trash"
    local trait_file="$TRASHDIR/traits/${class_name}.trash"
    local file_to_edit=""

    # Find the source file (check user dir before system dir)
    if [[ -f "$user_file" ]]; then
    file_to_edit="$user_file"
        elif [[ -f "$trash_file" ]]; then
        file_to_edit="$trash_file"
            elif [[ -f "$trait_file" ]]; then
            file_to_edit="$trait_file"
                else
                echo "Error: No source file found for $class_name"
                echo "Searched:"
                echo " - $user_file"
                echo " - $trash_file"
                echo " - $trait_file"
                echo ""
                echo "Use '@ Trash new $class_name' to create a new class."
                return 1
            fi

            # Open in editor and compile if saved
            local before_mtime after_mtime
            before_mtime=$(stat -f "%m" "$file_to_edit" 2>/dev/null || stat -c "%Y" "$file_to_edit" 2>/dev/null)

            ${EDITOR:-vi} "$file_to_edit" </dev/tty >/dev/tty

            after_mtime=$(stat -f "%m" "$file_to_edit" 2>/dev/null || stat -c "%Y" "$file_to_edit" 2>/dev/null)

            if [[ "$before_mtime" != "$after_mtime" ]]; then
                echo "File modified, compiling..."
                @ "$_RECEIVER" compileAndReload "$class_name"
                else
                echo "No changes detected"
            fi
}

__Trash__class__eval_() {
  local code="$1"
    local temp_class="_TempEval_$$_$RANDOM"
    local temp_file="/tmp/${temp_class}.trash"
    local compiled_file="/tmp/${temp_class}.compiled"
    local result

    # Wrap code in a temporary class with a run method
    cat >"$temp_file" <<EVALEOF
${temp_class} subclass: Object
rawClassMethod: run [
$1
]
EVALEOF

    # Compile the temporary class
    if ! "$SCRIPT_DIR/jq-compiler/driver.bash" compile "$temp_file" >"$compiled_file" 2>&1; then
        echo "Eval compile error:" >&2
        cat "$compiled_file" >&2
        rm -f "$temp_file" "$compiled_file"
        return 1
    fi

    # Validate bash syntax
    if ! bash -n "$compiled_file" 2>&1; then
        echo "Eval syntax error" >&2
        rm -f "$temp_file" "$compiled_file"
        return 1
    fi

    # Source and execute
    source "$compiled_file"
    result=$("__${temp_class}__class__run")
    local exit_code=$?

    # Clean up
    rm -f "$temp_file" "$compiled_file"
    # Unset the temporary functions
    unset -f "__${temp_class}__class__run" 2>/dev/null
    unset "__${temp_class}__superclass" 2>/dev/null
    unset "__${temp_class}__is_a" 2>/dev/null

    echo "$result"
    return $exit_code
}

__Trash__class__evalFile_() {
  local filepath="$1"
    if [[ ! -f "$1" ]]; then
        echo "Error: File not found: $1" >&2
        return 1
    fi
    local code
    code=$(cat "$1")
    @ Trash eval: "$code"
}

__Trash__quickCreate_template_() {
  local class_name="$1"
  local template="$2"
    template="${template:-basic}"
    local trash_file="$TRASHDIR/${class_name}.trash"

    if [[ -f "$trash_file" ]]; then
        echo "Class $class_name already exists"
        return 1
    fi

    case "$template" in
        "service")
        cat >"$trash_file" <<EOF
# $class_name - Service template
$class_name subclass: Object
include: Debuggable

rawMethod: start [
@ self debug: "Starting service..."
echo "Service started"
]

rawMethod: stop [
@ self debug: "Stopping service..."
echo "Service stopped"
]

rawMethod: status [
echo "Service is running"
]

rawMethod: restart [
@ "\$_RECEIVER" stop
@ "\$_RECEIVER" start
]

rawClassMethod: new [
local id = \$(_generate_instance_id "$class_name")
_create_instance "$class_name" "\$id"
echo "\$id"
]
EOF
    ;;
        "actor")
        cat >"$trash_file" <<EOF
# $class_name - Actor template (for use with Process)
$class_name subclass: Object
include: Debuggable
instanceVars: status: active

rawMethod: receive: message [
@ self debug: "Received message: \$message"
case "\$message" in
"ping") echo "pong";;
"status") echo "active";;
*) echo "Unknown message: \$message";;
esac
]

rawMethod: initialize [
@ self debug: "Actor initialized"
]

rawClassMethod: new [
local id = \$(_generate_instance_id "$class_name")
_create_instance "$class_name" "\$id"
echo "\$id"
]
EOF
    ;;
        *)
        # Basic template
        cat >"$trash_file" <<EOF
# $class_name - Created by Trash system
$class_name subclass: Object

rawMethod: example [
echo "Hello from $class_name"
]

rawClassMethod: new [
local id = \$(_generate_instance_id "$class_name")
_create_instance "$class_name" "\$id"
echo "\$id"
]
EOF
    ;;
    esac

    echo "Created $trash_file using $template template"
    echo "Compiling..."
    mkdir -p "$TRASHDIR/.compiled"
    "$SCRIPT_DIR/jq-compiler/driver.bash" compile "$trash_file" >"$TRASHDIR/.compiled/$class_name" 2>/dev/null
    source "$TRASHDIR/.compiled/$class_name"
    echo "✓ $class_name ready to use"
}
