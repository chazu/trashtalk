#!/usr/bin/env bash
# Generated by Trashtalk Compiler (jq) - DO NOT EDIT
# Source: Process.trash
# Generated: 2026-01-12T01:08:37

__Process__superclass="Object"
__Process__instanceVars="command pid status exitCode stdout stderr startTime endTime"
__Process__classInstanceVars=""
__Process__traits="Debuggable"
__Process__sourceHash="ad3019784be677ba09ee5431cd5f7243a8b7d60e1d54b8fb712268ad246d1605"

__Process__source() {
  cat <<'__TRASHTALK_SOURCE_EOF__'
# Process - External OS process management
# Provides an interface to spawn and manage POSIX processes
Process subclass: Object
  include: Debuggable
  instanceVars: command pid status exitCode stdout stderr startTime endTime

  # Create a new process wrapper for a command
  # Usage: proc=$(@ Process for: "curl -s https://example.com")
  rawClassMethod: for: command [
    local id
    id=$(@ Runtime generateId: "Process")
    @ Runtime create: "Process" id: "$id"
    @ "$id" setCommand: "$1"
    @ "$id" setStatus: "created"
    echo "$id"
  ]

  # Run the command in the foreground (blocking)
  # Captures stdout/stderr and exit code
  rawMethod: run [
    local cmd=$(_ivar command)
    local tmp_stdout="/tmp/proc_$$_stdout"
    local tmp_stderr="/tmp/proc_$$_stderr"

    @ "$_RECEIVER" debug: "Running command: $cmd"
    _ivar_set status "running"
    _ivar_set startTime "$(@ Time now)"

    # Run command in subshell, capturing output
    # Subshell prevents exit/return from killing the method
    (eval "$cmd") >"$tmp_stdout" 2>"$tmp_stderr"
    local exit_code=$?

    _ivar_set exitCode "$exit_code"
    _ivar_set stdout "$(cat "$tmp_stdout" 2>/dev/null)"
    _ivar_set stderr "$(cat "$tmp_stderr" 2>/dev/null)"
    _ivar_set endTime "$(@ Time now)"
    _ivar_set status "completed"

    rm -f "$tmp_stdout" "$tmp_stderr"

    echo "$exit_code"
  ]

  # Start the command in the background (non-blocking)
  # Returns immediately, use wait or poll to check completion
  rawMethod: start [
    local cmd instance tmp_stdout tmp_stderr bg_pid
    cmd=$(_ivar command)
    instance=$(@ Runtime instance)
    tmp_stdout="/tmp/proc_${instance}_stdout"
    tmp_stderr="/tmp/proc_${instance}_stderr"

    @ "$_RECEIVER" debug: "Starting background command: $cmd"
    _ivar_set status "running"
    _ivar_set startTime "$(@ Time now)"

    # Run command in background subshell
    (eval "$cmd") >"$tmp_stdout" 2>"$tmp_stderr" &
    bg_pid=$!
    _ivar_set pid "$bg_pid"

    echo "$bg_pid"
  ]

  # Wait for a background process to complete
  # Note: Uses polling since @ runs in subshells and can't use bash wait builtin
  rawMethod: wait [
    local proc_pid proc_status instance tmp_stdout tmp_stderr exit_code
    proc_pid=$(_ivar pid)
    proc_status=$(_ivar status)

    if [[ "$proc_status" != "running" ]]; then
      @ "$_RECEIVER" debug: "Process not running (status: $proc_status)"
      echo "$(_ivar exitCode)"
      return 0
    fi

    if [[ -z "$proc_pid" ]]; then
      @ Console error: "Error: No PID - process was not started in background"
      return 1
    fi

    @ "$_RECEIVER" debug: "Waiting for PID $proc_pid"

    # Poll until process completes (can't use wait across subshells)
    while [[ "$(@ Shell isAlive: "$proc_pid")" == "true" ]]; do
      @ Time sleep: 0.1
    done

    # Process completed - get exit code via /proc or assume 0 if file exists
    instance=$(@ Runtime instance)
    tmp_stdout="/tmp/proc_${instance}_stdout"
    tmp_stderr="/tmp/proc_${instance}_stderr"

    # Wait a moment for files to be flushed
    @ Time sleep: 0.05

    _ivar_set stdout "$(cat "$tmp_stdout" 2>/dev/null)"
    _ivar_set stderr "$(cat "$tmp_stderr" 2>/dev/null)"
    rm -f "$tmp_stdout" "$tmp_stderr"

    # Without wait, we can't get exact exit code
    exit_code=0
    _ivar_set exitCode "$exit_code"
    _ivar_set endTime "$(@ Time now)"
    _ivar_set status "completed"

    echo "$exit_code"
  ]

  # Check if the process is still running
  rawMethod: isRunning [
    local proc_pid proc_status
    proc_pid=$(_ivar pid)
    proc_status=$(_ivar status)

    if [[ "$proc_status" != "running" ]]; then
      echo "false"
      return 1
    fi

    if [[ "$(@ Shell isAlive: "$proc_pid")" == "true" ]]; then
      echo "true"
      return 0
    else
      # Process finished, update status
      @ "$_RECEIVER" wait >/dev/null 2>&1
      echo "false"
      return 1
    fi
  ]

  # Send a signal to the process
  rawMethod: signal: sig [
    local proc_pid
    proc_pid=$(_ivar pid)

    if [[ -z "$proc_pid" ]]; then
      @ Console error: "Error: No PID"
      return 1
    fi

    @ "$_RECEIVER" debug: "Sending signal $1 to PID $proc_pid"
    @ Shell signal: "$1" to: "$proc_pid"
  ]

  # Terminate the process (SIGTERM)
  rawMethod: terminate [
    local proc_pid
    proc_pid=$(_ivar pid)
    @ Shell terminate: "$proc_pid"
    _ivar_set status "terminated"
  ]

  # Kill the process (SIGKILL)
  rawMethod: kill [
    local proc_pid
    proc_pid=$(_ivar pid)
    @ Shell kill: "$proc_pid"
    _ivar_set status "killed"
  ]

  # Get stdout from the process
  rawMethod: output [
    _ivar stdout
  ]

  # Get stderr from the process
  rawMethod: errors [
    _ivar stderr
  ]

  # Get exit code
  rawMethod: exitCode [
    _ivar exitCode
  ]

  # Check if process succeeded (exit code 0)
  rawMethod: succeeded [
    local code=$(_ivar exitCode)
    if [[ "$code" == "0" ]]; then
      echo "true"
      return 0
    else
      echo "false"
      return 1
    fi
  ]

  # Get process info
  rawMethod: info [
    local start end duration
    @ Console print: "Command: $(_ivar command)"
    @ Console print: "PID: $(_ivar pid)"
    @ Console print: "Status: $(_ivar status)"
    @ Console print: "Exit Code: $(_ivar exitCode)"
    start=$(_ivar startTime)
    @ Console print: "Started: $(@ Time formatISO: "$start")"
    end=$(_ivar endTime)
    if [[ -n "$end" ]]; then
      @ Console print: "Ended: $(@ Time formatISO: "$end")"
      duration=$(@ Time from: "$start" to: "$end")
      @ Console print: "Duration: ${duration}s"
    fi
  ]

  # === Class methods for quick execution ===

  # Run a command and return stdout (blocking, simple)
  # Usage: output=$(@ Process exec: "ls -la")
  classMethod: exec: command [
    ^ @ Shell execAll: command
  ]

  # Run a command and return exit code only
  # Usage: @ Process run: "make test"
  classMethod: run: command [
    ^ @ Shell run: command
  ]

  # Run a command in background, return PID
  # Usage: pid=$(@ Process spawn: "long-running-task")
  classMethod: spawn: command [
    ^ @ Shell spawn: command
  ]

  # Wait for a PID to complete
  # Usage: @ Process waitPid: $pid
  classMethod: waitPid: pid [
    ^ @ Shell wait: pid
  ]

  # Check if a PID is running
  # Usage: @ Process isRunningPid: $pid
  classMethod: isRunningPid: pid [
    ^ @ Shell isAlive: pid
  ]

  # Kill a PID
  # Usage: @ Process killPid: $pid
  classMethod: killPid: pid [
    ^ @ Shell terminate: pid
  ]

  # Show help
  method: help [
    echo "=== Process Management ==="
    echo ""
    echo "Instance Methods (for managed processes):"
    echo "  proc=\$(@ Process for: \"command\")   - Create process wrapper"
    echo "  @ \$proc run                          - Run blocking, capture output"
    echo "  @ \$proc start                        - Run in background"
    echo "  @ \$proc wait                         - Wait for background completion"
    echo "  @ \$proc isRunning                    - Check if still running"
    echo "  @ \$proc terminate                    - Send SIGTERM"
    echo "  @ \$proc kill                         - Send SIGKILL"
    echo "  @ \$proc output                       - Get stdout"
    echo "  @ \$proc errors                       - Get stderr"
    echo "  @ \$proc exitCode                     - Get exit code"
    echo "  @ \$proc succeeded                    - Check if exit code is 0"
    echo "  @ \$proc info                         - Show process info"
    echo ""
    echo "Class Methods (for quick execution):"
    echo "  @ Process exec: \"cmd\"                - Run, return stdout"
    echo "  @ Process run: \"cmd\"                 - Run, return exit code"
    echo "  @ Process spawn: \"cmd\"               - Run in background, return PID"
    echo "  @ Process waitPid: \$pid              - Wait for PID"
    echo "  @ Process isRunningPid: \$pid         - Check if PID is running"
    echo "  @ Process killPid: \$pid              - Kill PID"
    echo ""
    echo "Examples:"
    echo "  # Quick execution"
    echo "  files=\$(@ Process exec: \"ls -la\")"
    echo ""
    echo "  # Managed process"
    echo "  proc=\$(@ Process for: \"curl -s https://api.example.com\")"
    echo "  @ \$proc run"
    echo "  if @ \$proc succeeded; then"
    echo "    echo \"Response: \$(@ \$proc output)\""
    echo "  fi"
  ]
__TRASHTALK_SOURCE_EOF__
}

__Process__command() {
  echo "$(_ivar command)"; return
}

__Process__command_() {
  _ivar_set command "$1"
}

__Process__getCommand() {
  echo "$(_ivar command)"; return
}

__Process__setCommand_() {
  _ivar_set command "$1"
}
__Process__pid() {
  echo "$(_ivar pid)"; return
}

__Process__pid_() {
  _ivar_set pid "$1"
}

__Process__getPid() {
  echo "$(_ivar pid)"; return
}

__Process__setPid_() {
  _ivar_set pid "$1"
}
__Process__status() {
  echo "$(_ivar status)"; return
}

__Process__status_() {
  _ivar_set status "$1"
}

__Process__getStatus() {
  echo "$(_ivar status)"; return
}

__Process__setStatus_() {
  _ivar_set status "$1"
}
__Process__exitCode() {
  echo "$(_ivar exitCode)"; return
}

__Process__exitCode_() {
  _ivar_set exitCode "$1"
}

__Process__getExitCode() {
  echo "$(_ivar exitCode)"; return
}

__Process__setExitCode_() {
  _ivar_set exitCode "$1"
}
__Process__stdout() {
  echo "$(_ivar stdout)"; return
}

__Process__stdout_() {
  _ivar_set stdout "$1"
}

__Process__getStdout() {
  echo "$(_ivar stdout)"; return
}

__Process__setStdout_() {
  _ivar_set stdout "$1"
}
__Process__stderr() {
  echo "$(_ivar stderr)"; return
}

__Process__stderr_() {
  _ivar_set stderr "$1"
}

__Process__getStderr() {
  echo "$(_ivar stderr)"; return
}

__Process__setStderr_() {
  _ivar_set stderr "$1"
}
__Process__startTime() {
  echo "$(_ivar startTime)"; return
}

__Process__startTime_() {
  _ivar_set startTime "$1"
}

__Process__getStartTime() {
  echo "$(_ivar startTime)"; return
}

__Process__setStartTime_() {
  _ivar_set startTime "$1"
}
__Process__endTime() {
  echo "$(_ivar endTime)"; return
}

__Process__endTime_() {
  _ivar_set endTime "$1"
}

__Process__getEndTime() {
  echo "$(_ivar endTime)"; return
}

__Process__setEndTime_() {
  _ivar_set endTime "$1"
}

__Process__class__for_() {
  local command="$1"
    local id
    id=$(@ Runtime generateId: "Process")
    @ Runtime create: "Process" id: "$id"
    @ "$id" setCommand: "$1"
    @ "$id" setStatus: "created"
    echo "$id"
}

__Process__run() {
    local cmd=$(_ivar command)
    local tmp_stdout="/tmp/proc_$$_stdout"
    local tmp_stderr="/tmp/proc_$$_stderr"

    @ "$_RECEIVER" debug: "Running command: $cmd"
    _ivar_set status "running"
    _ivar_set startTime "$(@ Time now)"

    # Run command in subshell, capturing output
    # Subshell prevents exit/return from killing the method
    (eval "$cmd") >"$tmp_stdout" 2>"$tmp_stderr"
    local exit_code=$?

    _ivar_set exitCode "$exit_code"
    _ivar_set stdout "$(cat "$tmp_stdout" 2>/dev/null)"
    _ivar_set stderr "$(cat "$tmp_stderr" 2>/dev/null)"
    _ivar_set endTime "$(@ Time now)"
    _ivar_set status "completed"

    rm -f "$tmp_stdout" "$tmp_stderr"

    echo "$exit_code"
}

__Process__start() {
    local cmd instance tmp_stdout tmp_stderr bg_pid
    cmd=$(_ivar command)
    instance=$(@ Runtime instance)
    tmp_stdout="/tmp/proc_${instance}_stdout"
    tmp_stderr="/tmp/proc_${instance}_stderr"

    @ "$_RECEIVER" debug: "Starting background command: $cmd"
    _ivar_set status "running"
    _ivar_set startTime "$(@ Time now)"

    # Run command in background subshell
    (eval "$cmd") >"$tmp_stdout" 2>"$tmp_stderr" &
    bg_pid=$!
    _ivar_set pid "$bg_pid"

    echo "$bg_pid"
}

__Process__wait() {
    local proc_pid proc_status instance tmp_stdout tmp_stderr exit_code
    proc_pid=$(_ivar pid)
    proc_status=$(_ivar status)

    if [[ "$proc_status" != "running" ]]; then
        @ "$_RECEIVER" debug: "Process not running (status: $proc_status)"
        echo "$(_ivar exitCode)"
        return 0
    fi

    if [[ -z "$proc_pid" ]]; then
        @ Console error: "Error: No PID - process was not started in background"
        return 1
    fi

    @ "$_RECEIVER" debug: "Waiting for PID $proc_pid"

    # Poll until process completes (can't use wait across subshells)
    while [[ "$(@ Shell isAlive: "$proc_pid")" == "true" ]]; do
        @ Time sleep: 0.1
    done

    # Process completed - get exit code via /proc or assume 0 if file exists
    instance=$(@ Runtime instance)
    tmp_stdout="/tmp/proc_${instance}_stdout"
    tmp_stderr="/tmp/proc_${instance}_stderr"

    # Wait a moment for files to be flushed
    @ Time sleep: 0.05

    _ivar_set stdout "$(cat "$tmp_stdout" 2>/dev/null)"
    _ivar_set stderr "$(cat "$tmp_stderr" 2>/dev/null)"
    rm -f "$tmp_stdout" "$tmp_stderr"

    # Without wait, we can't get exact exit code
    exit_code=0
    _ivar_set exitCode "$exit_code"
    _ivar_set endTime "$(@ Time now)"
    _ivar_set status "completed"

    echo "$exit_code"
}

__Process__isRunning() {
    local proc_pid proc_status
    proc_pid=$(_ivar pid)
    proc_status=$(_ivar status)

    if [[ "$proc_status" != "running" ]]; then
        echo "false"
        return 1
    fi

    if [[ "$(@ Shell isAlive: "$proc_pid")" == "true" ]]; then
        echo "true"
        return 0
        else
        # Process finished, update status
        @ "$_RECEIVER" wait >/dev/null 2>&1
        echo "false"
        return 1
    fi
}

__Process__signal_() {
  local sig="$1"
    local proc_pid
    proc_pid=$(_ivar pid)

    if [[ -z "$proc_pid" ]]; then
        @ Console error: "Error: No PID"
        return 1
    fi

    @ "$_RECEIVER" debug: "Sending signal $1 to PID $proc_pid"
    @ Shell signal: "$1" to: "$proc_pid"
}

__Process__terminate() {
    local proc_pid
    proc_pid=$(_ivar pid)
    @ Shell terminate: "$proc_pid"
    _ivar_set status "terminated"
}

__Process__kill() {
    local proc_pid
    proc_pid=$(_ivar pid)
    @ Shell kill: "$proc_pid"
    _ivar_set status "killed"
}

__Process__output() {
    _ivar stdout
}

__Process__errors() {
    _ivar stderr
}

__Process__exitCode() {
    _ivar exitCode
}

__Process__succeeded() {
    local code=$(_ivar exitCode)
    if [[ "$code" == "0" ]]; then
        echo "true"
        return 0
        else
        echo "false"
        return 1
    fi
}

__Process__info() {
    local start end duration
    @ Console print: "Command: $(_ivar command)"
    @ Console print: "PID: $(_ivar pid)"
    @ Console print: "Status: $(_ivar status)"
    @ Console print: "Exit Code: $(_ivar exitCode)"
    start=$(_ivar startTime)
    @ Console print: "Started: $(@ Time formatISO: "$start")"
    end=$(_ivar endTime)
    if [[ -n "$end" ]]; then
        @ Console print: "Ended: $(@ Time formatISO: "$end")"
        duration=$(@ Time from: "$start" to: "$end")
        @ Console print: "Duration: ${duration}s"
    fi
}

__Process__class__exec_() {
  local command="$1"
  @ Shell execAll: "$command"; return
}

__Process__class__run_() {
  local command="$1"
  @ Shell run: "$command"; return
}

__Process__class__spawn_() {
  local command="$1"
  @ Shell spawn: "$command"; return
}

__Process__class__waitPid_() {
  local pid="$1"
  @ Shell wait: "$pid"; return
}

__Process__class__isRunningPid_() {
  local pid="$1"
  @ Shell isAlive: "$pid"; return
}

__Process__class__killPid_() {
  local pid="$1"
  @ Shell terminate: "$pid"; return
}

__Process__help() {
  echo "=== Process Management ==="
  echo ""
  echo "Instance Methods (for managed processes):"
  echo " proc=\$(@ Process for: \"command\") - Create process wrapper"
  echo " @ \$proc run - Run blocking, capture output"
  echo " @ \$proc start - Run in background"
  echo " @ \$proc wait - Wait for background completion"
  echo " @ \$proc isRunning - Check if still running"
  echo " @ \$proc terminate - Send SIGTERM"
  echo " @ \$proc kill - Send SIGKILL"
  echo " @ \$proc output - Get stdout"
  echo " @ \$proc errors - Get stderr"
  echo " @ \$proc exitCode - Get exit code"
  echo " @ \$proc succeeded - Check if exit code is 0"
  echo " @ \$proc info - Show process info"
  echo ""
  echo "Class Methods (for quick execution):"
  echo " @ Process exec: \" cmd \" - Run, return stdout"
  echo " @ Process run: \" cmd \" - Run, return exit code"
  echo " @ Process spawn: \" cmd \" - Run in background, return PID"
  echo " @ Process waitPid: \$pid - Wait for PID"
  echo " @ Process isRunningPid: \$pid - Check if PID is running"
  echo " @ Process killPid: \$pid - Kill PID"
  echo ""
  echo "Examples:"
  echo " # Quick execution"
  echo " files=\$(@ Process exec: \"ls -la\")"
  echo ""
  echo " # Managed process"
  echo " proc=\$(@ Process for: \"curl -s https://api.example.com\")"
  echo " @ \$proc run"
  echo " if @ \$proc succeeded; then"
  echo " echo \" Response: \$(@ \$proc output)\""
  echo " fi"
}
