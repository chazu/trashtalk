#!/usr/bin/env bash
# Generated by Trashtalk Compiler (jq) - DO NOT EDIT
# Source: Process.trash
# Generated: 2026-01-09T16:54:15

__Process__superclass="Object"
__Process__instanceVars="command pid status exitCode stdout stderr startTime endTime"
__Process__classInstanceVars=""
__Process__traits="Debuggable"
__Process__sourceHash="08b1487a37f7d14876c57da08d7353ed381971c02783c34cd0c4f001dc3f55d0"

__Process__source() {
  cat <<'__TRASHTALK_SOURCE_EOF__'
# Process - External OS process management
# Provides an interface to spawn and manage POSIX processes
Process subclass: Object
  include: Debuggable
  instanceVars: command pid status exitCode stdout stderr startTime endTime

  # Create a new process wrapper for a command
  # Usage: proc=$(@ Process for: "curl -s https://example.com")
  rawClassMethod: for: command [
    local id=$(_generate_instance_id Process)
    _create_instance Process "$id"
    @ "$id" setCommand "$command"
    @ "$id" setStatus "created"
    echo "$id"
  ]

  # Run the command in the foreground (blocking)
  # Captures stdout/stderr and exit code
  rawMethod: run [
    local cmd=$(_ivar command)
    local tmp_stdout="/tmp/proc_$$_stdout"
    local tmp_stderr="/tmp/proc_$$_stderr"

    @ "$_RECEIVER" debug: "Running command: $cmd"
    _ivar_set status "running"
    _ivar_set startTime "$(date +%s)"

    # Run command in subshell, capturing output
    # Subshell prevents exit/return from killing the method
    (eval "$cmd") >"$tmp_stdout" 2>"$tmp_stderr"
    local exit_code=$?

    _ivar_set exitCode "$exit_code"
    _ivar_set stdout "$(cat "$tmp_stdout" 2>/dev/null)"
    _ivar_set stderr "$(cat "$tmp_stderr" 2>/dev/null)"
    _ivar_set endTime "$(date +%s)"
    _ivar_set status "completed"

    rm -f "$tmp_stdout" "$tmp_stderr"

    echo "$exit_code"
  ]

  # Start the command in the background (non-blocking)
  # Returns immediately, use wait or poll to check completion
  rawMethod: start [
    local cmd=$(_ivar command)
    local tmp_stdout="/tmp/proc_${_INSTANCE}_stdout"
    local tmp_stderr="/tmp/proc_${_INSTANCE}_stderr"

    @ "$_RECEIVER" debug: "Starting background command: $cmd"
    _ivar_set status "running"
    _ivar_set startTime "$(date +%s)"

    # Run command in background subshell
    (eval "$cmd") >"$tmp_stdout" 2>"$tmp_stderr" &
    local bg_pid=$!
    _ivar_set pid "$bg_pid"

    echo "$bg_pid"
  ]

  # Wait for a background process to complete
  # Note: Uses polling since @ runs in subshells and can't use bash wait builtin
  rawMethod: wait [
    local proc_pid=$(_ivar pid)
    local proc_status=$(_ivar status)

    if [[ "$proc_status" != "running" ]]; then
      @ "$_RECEIVER" debug: "Process not running (status: $proc_status)"
      echo "$(_ivar exitCode)"
      return 0
    fi

    if [[ -z "$proc_pid" ]]; then
      echo "Error: No PID - process was not started in background"
      return 1
    fi

    @ "$_RECEIVER" debug: "Waiting for PID $proc_pid"

    # Poll until process completes (can't use wait across subshells)
    while kill -0 "$proc_pid" 2>/dev/null; do
      sleep 0.1
    done

    # Process completed - get exit code via /proc or assume 0 if file exists
    # Note: Can't get actual exit code without wait, so check output files
    local tmp_stdout="/tmp/proc_${_INSTANCE}_stdout"
    local tmp_stderr="/tmp/proc_${_INSTANCE}_stderr"

    # Wait a moment for files to be flushed
    sleep 0.05

    _ivar_set stdout "$(cat "$tmp_stdout" 2>/dev/null)"
    _ivar_set stderr "$(cat "$tmp_stderr" 2>/dev/null)"
    rm -f "$tmp_stdout" "$tmp_stderr"

    # Without wait, we can't get exact exit code
    # Use 0 as default since process completed
    local exit_code=0
    _ivar_set exitCode "$exit_code"
    _ivar_set endTime "$(date +%s)"
    _ivar_set status "completed"

    echo "$exit_code"
  ]

  # Check if the process is still running
  rawMethod: isRunning [
    local proc_pid=$(_ivar pid)
    local proc_status=$(_ivar status)

    if [[ "$proc_status" != "running" ]]; then
      echo "false"
      return 1
    fi

    if kill -0 "$proc_pid" 2>/dev/null; then
      echo "true"
      return 0
    else
      # Process finished, update status
      @ "$_RECEIVER" wait >/dev/null 2>&1
      echo "false"
      return 1
    fi
  ]

  # Send a signal to the process
  rawMethod: signal: sig [
    local proc_pid=$(_ivar pid)

    if [[ -z "$proc_pid" ]]; then
      echo "Error: No PID"
      return 1
    fi

    @ "$_RECEIVER" debug: "Sending signal $sig to PID $proc_pid"
    kill "-$sig" "$proc_pid" 2>/dev/null
  ]

  # Terminate the process (SIGTERM)
  rawMethod: terminate [
    @ "$_RECEIVER" signal: "TERM"
    _ivar_set status "terminated"
  ]

  # Kill the process (SIGKILL)
  rawMethod: kill [
    @ "$_RECEIVER" signal: "KILL"
    _ivar_set status "killed"
  ]

  # Get stdout from the process
  rawMethod: output [
    _ivar stdout
  ]

  # Get stderr from the process
  rawMethod: errors [
    _ivar stderr
  ]

  # Get exit code
  rawMethod: exitCode [
    _ivar exitCode
  ]

  # Check if process succeeded (exit code 0)
  rawMethod: succeeded [
    local code=$(_ivar exitCode)
    if [[ "$code" == "0" ]]; then
      echo "true"
      return 0
    else
      echo "false"
      return 1
    fi
  ]

  # Get process info
  rawMethod: info [
    echo "Command: $(_ivar command)"
    echo "PID: $(_ivar pid)"
    echo "Status: $(_ivar status)"
    echo "Exit Code: $(_ivar exitCode)"
    echo "Started: $(date -r "$(_ivar startTime)" 2>/dev/null || echo "$(_ivar startTime)")"
    local end=$(_ivar endTime)
    if [[ -n "$end" ]]; then
      echo "Ended: $(date -r "$end" 2>/dev/null || echo "$end")"
      local start=$(_ivar startTime)
      if [[ -n "$start" ]]; then
        echo "Duration: $((end - start))s"
      fi
    fi
  ]

  # === Class methods for quick execution ===

  # Run a command and return stdout (blocking, simple)
  # Usage: output=$(@ Process exec: "ls -la")
  rawClassMethod: exec: command [
    local tmp_out="/tmp/proc_exec_$$"
    eval "$command" >"$tmp_out" 2>&1
    local exit_code=$?
    cat "$tmp_out"
    rm -f "$tmp_out"
    return $exit_code
  ]

  # Run a command and return exit code only
  # Usage: @ Process run: "make test"
  rawClassMethod: run: command [
    eval "$command"
  ]

  # Run a command in background, return PID
  # Usage: pid=$(@ Process spawn: "long-running-task")
  rawClassMethod: spawn: command [
    eval "$command" >/dev/null 2>&1 &
    echo $!
  ]

  # Wait for a PID to complete
  # Usage: @ Process waitPid: $pid
  rawClassMethod: waitPid: pid [
    wait "$pid" 2>/dev/null
    echo $?
  ]

  # Check if a PID is running
  # Usage: @ Process isRunningPid: $pid
  rawClassMethod: isRunningPid: pid [
    if kill -0 "$pid" 2>/dev/null; then
      echo "true"
    else
      echo "false"
    fi
  ]

  # Kill a PID
  # Usage: @ Process killPid: $pid
  rawClassMethod: killPid: pid [
    kill -TERM "$pid" 2>/dev/null
  ]

  # Show help
  method: help [
    echo "=== Process Management ==="
    echo ""
    echo "Instance Methods (for managed processes):"
    echo "  proc=\$(@ Process for: \"command\")   - Create process wrapper"
    echo "  @ \$proc run                          - Run blocking, capture output"
    echo "  @ \$proc start                        - Run in background"
    echo "  @ \$proc wait                         - Wait for background completion"
    echo "  @ \$proc isRunning                    - Check if still running"
    echo "  @ \$proc terminate                    - Send SIGTERM"
    echo "  @ \$proc kill                         - Send SIGKILL"
    echo "  @ \$proc output                       - Get stdout"
    echo "  @ \$proc errors                       - Get stderr"
    echo "  @ \$proc exitCode                     - Get exit code"
    echo "  @ \$proc succeeded                    - Check if exit code is 0"
    echo "  @ \$proc info                         - Show process info"
    echo ""
    echo "Class Methods (for quick execution):"
    echo "  @ Process exec: \"cmd\"                - Run, return stdout"
    echo "  @ Process run: \"cmd\"                 - Run, return exit code"
    echo "  @ Process spawn: \"cmd\"               - Run in background, return PID"
    echo "  @ Process waitPid: \$pid              - Wait for PID"
    echo "  @ Process isRunningPid: \$pid         - Check if PID is running"
    echo "  @ Process killPid: \$pid              - Kill PID"
    echo ""
    echo "Examples:"
    echo "  # Quick execution"
    echo "  files=\$(@ Process exec: \"ls -la\")"
    echo ""
    echo "  # Managed process"
    echo "  proc=\$(@ Process for: \"curl -s https://api.example.com\")"
    echo "  @ \$proc run"
    echo "  if @ \$proc succeeded; then"
    echo "    echo \"Response: \$(@ \$proc output)\""
    echo "  fi"
  ]
__TRASHTALK_SOURCE_EOF__
}

__Process__command() {
  echo "$(_ivar command)"; return
}

__Process__command_() {
  _ivar_set command "$1"
}

__Process__getCommand() {
  echo "$(_ivar command)"; return
}

__Process__setCommand_() {
  _ivar_set command "$1"
}
__Process__pid() {
  echo "$(_ivar pid)"; return
}

__Process__pid_() {
  _ivar_set pid "$1"
}

__Process__getPid() {
  echo "$(_ivar pid)"; return
}

__Process__setPid_() {
  _ivar_set pid "$1"
}
__Process__status() {
  echo "$(_ivar status)"; return
}

__Process__status_() {
  _ivar_set status "$1"
}

__Process__getStatus() {
  echo "$(_ivar status)"; return
}

__Process__setStatus_() {
  _ivar_set status "$1"
}
__Process__exitCode() {
  echo "$(_ivar exitCode)"; return
}

__Process__exitCode_() {
  _ivar_set exitCode "$1"
}

__Process__getExitCode() {
  echo "$(_ivar exitCode)"; return
}

__Process__setExitCode_() {
  _ivar_set exitCode "$1"
}
__Process__stdout() {
  echo "$(_ivar stdout)"; return
}

__Process__stdout_() {
  _ivar_set stdout "$1"
}

__Process__getStdout() {
  echo "$(_ivar stdout)"; return
}

__Process__setStdout_() {
  _ivar_set stdout "$1"
}
__Process__stderr() {
  echo "$(_ivar stderr)"; return
}

__Process__stderr_() {
  _ivar_set stderr "$1"
}

__Process__getStderr() {
  echo "$(_ivar stderr)"; return
}

__Process__setStderr_() {
  _ivar_set stderr "$1"
}
__Process__startTime() {
  echo "$(_ivar startTime)"; return
}

__Process__startTime_() {
  _ivar_set startTime "$1"
}

__Process__getStartTime() {
  echo "$(_ivar startTime)"; return
}

__Process__setStartTime_() {
  _ivar_set startTime "$1"
}
__Process__endTime() {
  echo "$(_ivar endTime)"; return
}

__Process__endTime_() {
  _ivar_set endTime "$1"
}

__Process__getEndTime() {
  echo "$(_ivar endTime)"; return
}

__Process__setEndTime_() {
  _ivar_set endTime "$1"
}

__Process__class__for_() {
  local command="$1"
    local id=$(_generate_instance_id Process)
    _create_instance Process "$id"
    @ "$id" setCommand "$command"
    @ "$id" setStatus "created"
    echo "$id"
}

__Process__run() {
    local cmd=$(_ivar command)
    local tmp_stdout="/tmp/proc_$$_stdout"
    local tmp_stderr="/tmp/proc_$$_stderr"

    @ "$_RECEIVER" debug: "Running command: $cmd"
    _ivar_set status "running"
    _ivar_set startTime "$(date +%s)"

    # Run command in subshell, capturing output
    # Subshell prevents exit/return from killing the method
    (eval "$cmd") >"$tmp_stdout" 2>"$tmp_stderr"
    local exit_code=$?

    _ivar_set exitCode "$exit_code"
    _ivar_set stdout "$(cat "$tmp_stdout" 2>/dev/null)"
    _ivar_set stderr "$(cat "$tmp_stderr" 2>/dev/null)"
    _ivar_set endTime "$(date +%s)"
    _ivar_set status "completed"

    rm -f "$tmp_stdout" "$tmp_stderr"

    echo "$exit_code"
}

__Process__start() {
    local cmd=$(_ivar command)
    local tmp_stdout="/tmp/proc_${_INSTANCE}_stdout"
    local tmp_stderr="/tmp/proc_${_INSTANCE}_stderr"

    @ "$_RECEIVER" debug: "Starting background command: $cmd"
    _ivar_set status "running"
    _ivar_set startTime "$(date +%s)"

    # Run command in background subshell
    (eval "$cmd") >"$tmp_stdout" 2>"$tmp_stderr" &
    local bg_pid=$!
    _ivar_set pid "$bg_pid"

    echo "$bg_pid"
}

__Process__wait() {
    local proc_pid=$(_ivar pid)
    local proc_status=$(_ivar status)

    if [[ "$proc_status" != "running" ]]; then
        @ "$_RECEIVER" debug: "Process not running (status: $proc_status)"
        echo "$(_ivar exitCode)"
        return 0
    fi

    if [[ -z "$proc_pid" ]]; then
        echo "Error: No PID - process was not started in background"
        return 1
    fi

    @ "$_RECEIVER" debug: "Waiting for PID $proc_pid"

    # Poll until process completes (can't use wait across subshells)
    while kill -0 "$proc_pid" 2>/dev/null; do
        sleep 0.1
    done

    # Process completed - get exit code via /proc or assume 0 if file exists
    # Note: Can't get actual exit code without wait, so check output files
    local tmp_stdout="/tmp/proc_${_INSTANCE}_stdout"
    local tmp_stderr="/tmp/proc_${_INSTANCE}_stderr"

    # Wait a moment for files to be flushed
    sleep 0.05

    _ivar_set stdout "$(cat "$tmp_stdout" 2>/dev/null)"
    _ivar_set stderr "$(cat "$tmp_stderr" 2>/dev/null)"
    rm -f "$tmp_stdout" "$tmp_stderr"

    # Without wait, we can't get exact exit code
    # Use 0 as default since process completed
    local exit_code=0
    _ivar_set exitCode "$exit_code"
    _ivar_set endTime "$(date +%s)"
    _ivar_set status "completed"

    echo "$exit_code"
}

__Process__isRunning() {
    local proc_pid=$(_ivar pid)
    local proc_status=$(_ivar status)

    if [[ "$proc_status" != "running" ]]; then
        echo "false"
        return 1
    fi

    if kill -0 "$proc_pid" 2>/dev/null; then
        echo "true"
        return 0
        else
        # Process finished, update status
        @ "$_RECEIVER" wait >/dev/null 2>&1
        echo "false"
        return 1
    fi
}

__Process__signal_() {
  local sig="$1"
    local proc_pid=$(_ivar pid)

    if [[ -z "$proc_pid" ]]; then
        echo "Error: No PID"
        return 1
    fi

    @ "$_RECEIVER" debug: "Sending signal $sig to PID $proc_pid"
    kill "-$sig" "$proc_pid" 2>/dev/null
}

__Process__terminate() {
    @ "$_RECEIVER" signal: "TERM"
    _ivar_set status "terminated"
}

__Process__kill() {
    @ "$_RECEIVER" signal: "KILL"
    _ivar_set status "killed"
}

__Process__output() {
    _ivar stdout
}

__Process__errors() {
    _ivar stderr
}

__Process__exitCode() {
    _ivar exitCode
}

__Process__succeeded() {
    local code=$(_ivar exitCode)
    if [[ "$code" == "0" ]]; then
        echo "true"
        return 0
        else
        echo "false"
        return 1
    fi
}

__Process__info() {
    echo "Command: $(_ivar command)"
    echo "PID: $(_ivar pid)"
    echo "Status: $(_ivar status)"
    echo "Exit Code: $(_ivar exitCode)"
    echo "Started: $(date -r "$(_ivar startTime)" 2>/dev/null || echo "$(_ivar startTime)")"
    local end=$(_ivar endTime)
    if [[ -n "$end" ]]; then
        echo "Ended: $(date -r "$end" 2>/dev/null || echo "$end")"
        local start=$(_ivar startTime)
        if [[ -n "$start" ]]; then
            echo "Duration: $((end - start))s"
        fi
    fi
}

__Process__class__exec_() {
  local command="$1"
    local tmp_out="/tmp/proc_exec_$$"
    eval "$command" >"$tmp_out" 2>&1
    local exit_code=$?
    cat "$tmp_out"
    rm -f "$tmp_out"
    return $exit_code
}

__Process__class__run_() {
  local command="$1"
    eval "$command"
}

__Process__class__spawn_() {
  local command="$1"
    eval "$command" >/dev/null 2>&1 &
    echo $!
}

__Process__class__waitPid_() {
  local pid="$1"
    wait "$pid" 2>/dev/null
    echo $?
}

__Process__class__isRunningPid_() {
  local pid="$1"
    if kill -0 "$pid" 2>/dev/null; then
        echo "true"
        else
        echo "false"
    fi
}

__Process__class__killPid_() {
  local pid="$1"
    kill -TERM "$pid" 2>/dev/null
}

__Process__help() {
  echo "=== Process Management ==="
  echo ""
  echo "Instance Methods (for managed processes):"
  echo " proc=\$(@ Process for: \"command\") - Create process wrapper"
  echo " @ \$proc run - Run blocking, capture output"
  echo " @ \$proc start - Run in background"
  echo " @ \$proc wait - Wait for background completion"
  echo " @ \$proc isRunning - Check if still running"
  echo " @ \$proc terminate - Send SIGTERM"
  echo " @ \$proc kill - Send SIGKILL"
  echo " @ \$proc output - Get stdout"
  echo " @ \$proc errors - Get stderr"
  echo " @ \$proc exitCode - Get exit code"
  echo " @ \$proc succeeded - Check if exit code is 0"
  echo " @ \$proc info - Show process info"
  echo ""
  echo "Class Methods (for quick execution):"
  echo " @ Process exec: \" cmd \" - Run, return stdout"
  echo " @ Process run: \" cmd \" - Run, return exit code"
  echo " @ Process spawn: \" cmd \" - Run in background, return PID"
  echo " @ Process waitPid: \$pid - Wait for PID"
  echo " @ Process isRunningPid: \$pid - Check if PID is running"
  echo " @ Process killPid: \$pid - Kill PID"
  echo ""
  echo "Examples:"
  echo " # Quick execution"
  echo " files=\$(@ Process exec: \"ls -la\")"
  echo ""
  echo " # Managed process"
  echo " proc=\$(@ Process for: \"curl -s https://api.example.com\")"
  echo " @ \$proc run"
  echo " if @ \$proc succeeded; then"
  echo " echo \" Response: \$(@ \$proc output)\""
  echo " fi"
}
