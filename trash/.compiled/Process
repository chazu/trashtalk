#!/bin/bash
# Generated by Trashtalk Compiler (jq) - DO NOT EDIT
# Source: Process.trash
# Generated: 2025-12-16T22:01:31

__Process__superclass="Object"
__Process__instanceVars=""
__Process__traits="Debuggable"

__Process___initTuplespace() {
  if ! TRASH_DEBUG=0 @ Tuplespace count >/dev/null 2>&1; then
  @ "$_RECEIVER" debug "Initializing tuplespace for process management"
  TRASH_DEBUG=0 @ Tuplespace init >/dev/null
  fi
}

__Process__spawn() {
  local object_name="$1"
    local process_id="proc_$(uuidgen 2>/dev/null || echo "$$_$(date +%s)")"

    @ "$_RECEIVER" debug "Spawning process $process_id for object $object_name"
    @ "$_RECEIVER" _initTuplespace

    # Register process in tuplespace
    TRASH_DEBUG=0 @ Tuplespace put_args "process" \
        "id" "$process_id" \
        "object" "$object_name" \
        "status" "starting" \
        "created" "$(date +%s)" \
        "pid" "" >/dev/null

    # Start the process message loop in background with all output suppressed
    (@ "$_RECEIVER" _messageLoop_object "$process_id" "$object_name") >/dev/null 2>&1 &
    local bg_pid=$!

    # Update process with actual PID and running status
    TRASH_DEBUG=0 @ Tuplespace take_key_value "process" "id" "$process_id" >/dev/null
    TRASH_DEBUG=0 @ Tuplespace put_args "process" \
        "id" "$process_id" \
        "object" "$object_name" \
        "status" "running" \
        "created" "$(date +%s)" \
        "pid" "$bg_pid" >/dev/null

    # Emit process started event
    TRASH_DEBUG=0 @ Tuplespace putEvent_data "process_started" "$process_id" >/dev/null

    echo "$process_id"
}

__Process___messageLoop_object() {
  local process_id="$1"
  local object_name="$2"
    # Completely suppress all output in background process
    exec >/dev/null 2>&1

    # Set up signal handling for graceful shutdown
    trap "@ '$_RECEIVER' _cleanupInternal '$process_id'; exit 0" TERM INT

    while true; do
        # Wait for messages directed to this process with timeout
        local message_tuple
        message_tuple=$(TRASH_DEBUG=0 @ Tuplespace wait_key_value_timeout "message" "target" "$process_id" 1 2>/dev/null || true)

        if [[ -n "$message_tuple" ]]; then
            # Extract message details
            local message_id sender payload message_type
            message_id=$(echo "$message_tuple" | TRASH_DEBUG=0 @ Tuplespace field_name - "ID" 2>/dev/null | tail -1 || true)
            sender=$(echo "$message_tuple" | TRASH_DEBUG=0 @ Tuplespace field_name - "sender" 2>/dev/null | tail -1 || true)
            payload=$(echo "$message_tuple" | TRASH_DEBUG=0 @ Tuplespace field_name - "payload" 2>/dev/null | tail -1 || true)
            message_type=$(echo "$message_tuple" | TRASH_DEBUG=0 @ Tuplespace field_name - "type" 2>/dev/null | tail -1 || true)

            # Remove the message from the queue
            TRASH_DEBUG=0 @ Tuplespace take_key_value "message" "ID" "$message_id" >/dev/null 2>&1 || true

            case "$message_type" in
                "terminate")
                break
            ;;
                "message" | *)
                # Execute the message in the context of the object
                local result exit_code
                result=$(TRASH_DEBUG=0 @ "$object_name" $payload 2>&1 || true)
                exit_code=$?

                # Send response back via tuplespace
                TRASH_DEBUG=0 @ Tuplespace put_args "response" \
                    "request_id" "$message_id" \
                    "sender" "$process_id" \
                    "target" "$sender" \
                    "result" "$result" \
                    "exit_code" "$exit_code" \
                    "timestamp" "$(date +%s)" >/dev/null 2>&1 || true
            ;;
            esac
        fi

        # Check for shutdown signals
        local shutdown_signal
        shutdown_signal=$(TRASH_DEBUG=0 @ Tuplespace get_key_value "signal" "target" "$process_id" 2>/dev/null || true)
        if [[ -n "$shutdown_signal" ]]; then
            TRASH_DEBUG=0 @ Tuplespace take_key_value "signal" "target" "$process_id" >/dev/null 2>&1 || true
            break
        fi

        # Add a small sleep to prevent busy waiting
        sleep 0.1
    done

    # Cleanup and exit
    @ "$_RECEIVER" _cleanupInternal "$process_id"
}

__Process__sendTo_message() {
  local process_id="$1"
  local message="$2"
    @ "$_RECEIVER" debug "Sending message to process $process_id: $message"
    @ "$_RECEIVER" _initTuplespace

    # Check if process exists and is running (suppress debug output)
    local process_tuple
    process_tuple=$(TRASH_DEBUG=0 @ Tuplespace get_key_value "process" "id" "$process_id" 2>/dev/null)
    if [[ -z "$process_tuple" ]]; then
        echo "Error: Process $process_id not found"
        return 1
    fi

    local status
    status=$(echo "$process_tuple" | TRASH_DEBUG=0 @ Tuplespace field_name - "status" 2>/dev/null | tail -1)
    if [[ "$status" != "running" ]]; then
        echo "Error: Process $process_id is not running (status: $status)"
        return 1
    fi

    # Generate unique message ID
    local message_id="msg_$(uuidgen 2>/dev/null || echo "$$_$(date +%s.%N)")"

    # Put message in tuplespace (suppress debug output)
    TRASH_DEBUG=0 @ Tuplespace put_args "message" \
        "ID" "$message_id" \
        "target" "$process_id" \
        "sender" "$$" \
        "payload" "$message" \
        "type" "message" \
        "timestamp" "$(date +%s)" >/dev/null 2>&1

    echo "$message_id"
}

__Process__getFrom_timeout() {
  local process_id="$1"
  local timeout="$2"
    timeout="${timeout:-10}" # Default 10 second timeout

    @ "$_RECEIVER" debug "Getting result from process $process_id (timeout: ${timeout}s)"
    @ "$_RECEIVER" _initTuplespace

    # Check if process exists (suppress debug output)
    local process_tuple
    process_tuple=$(TRASH_DEBUG=0 @ Tuplespace get_key_value "process" "id" "$process_id" 2>/dev/null)
    if [[ -z "$process_tuple" ]]; then
        echo "Error: Process $process_id not found"
        return 1
    fi

    # Wait for response from the process (suppress debug output)
    local response_tuple
    response_tuple=$(TRASH_DEBUG=0 @ Tuplespace wait_key_value_timeout "response" "sender" "$process_id" "$timeout" 2>/dev/null)

    if [[ -z "$response_tuple" ]]; then
        echo "Error: Timeout waiting for response from process $process_id"
        return 1
    fi

    # Extract and return the result (suppress debug output)
    local result exit_code response_id
    result=$(echo "$response_tuple" | TRASH_DEBUG=0 @ Tuplespace field_name - "result" 2>/dev/null | tail -1)
    exit_code=$(echo "$response_tuple" | TRASH_DEBUG=0 @ Tuplespace field_name - "exit_code" 2>/dev/null | tail -1)
    response_id=$(echo "$response_tuple" | TRASH_DEBUG=0 @ Tuplespace field_name - "ID" 2>/dev/null | tail -1)

    # Remove the response from tuplespace
    TRASH_DEBUG=0 @ Tuplespace take_key_value "response" "ID" "$response_id" >/dev/null 2>&1

    echo "$result"
    return "${exit_code:-0}"
}

__Process__terminate() {
  local process_id="$1"
    @ "$_RECEIVER" debug "Terminating process $process_id"
    @ "$_RECEIVER" _initTuplespace

    # Check if process exists
    local process_tuple=$(TRASH_DEBUG=0 @ Tuplespace get_key_value "process" "id" "$process_id")
    if [[ -z "$process_tuple" ]]; then
        echo "Error: Process $process_id not found"
        return 1
    fi

    local pid=$(echo "$process_tuple" | TRASH_DEBUG=0 @ Tuplespace field_name - "pid")
    local status=$(echo "$process_tuple" | TRASH_DEBUG=0 @ Tuplespace field_name - "status")

    if [[ "$status" != "running" ]]; then
        echo "Process $process_id is not running (status: $status)"
        @ "$_RECEIVER" cleanup "$process_id"
        return 0
    fi

    # Send termination message
    TRASH_DEBUG=0 @ Tuplespace put_args "message" \
        "target" "$process_id" \
        "sender" "$$" \
        "payload" "terminate" \
        "type" "terminate" \
        "timestamp" "$(date +%s)"

    # Wait for graceful shutdown
    local wait_count=0
    while [[ $wait_count -lt 5 ]]; do
        if ! kill -0 "$pid" 2>/dev/null; then
            @ "$_RECEIVER" debug "Process $process_id terminated gracefully"
            @ "$_RECEIVER" cleanup "$process_id"
            return 0
        fi
        sleep 1
        ((wait_count++))
    done

    # Force kill if still running
    if kill -0 "$pid" 2>/dev/null; then
        @ "$_RECEIVER" debug "Force killing process $process_id (PID: $pid)"
        kill -TERM "$pid" 2>/dev/null
        sleep 1
        if kill -0 "$pid" 2>/dev/null; then
            kill -KILL "$pid" 2>/dev/null
        fi
    fi

    @ "$_RECEIVER" cleanup "$process_id"
}

__Process__cleanup() {
  local process_id="$1"
    @ "$_RECEIVER" debug "Cleaning up process $process_id"
    @ "$_RECEIVER" _initTuplespace

    # Remove process from tuplespace
    TRASH_DEBUG=0 @ Tuplespace take_key_value "process" "id" "$process_id" >/dev/null

    # Clean up any remaining messages for this process
    TRASH_DEBUG=0 @ Tuplespace take_key_value "message" "target" "$process_id" >/dev/null 2>&1

    # Clean up any remaining responses from this process
    TRASH_DEBUG=0 @ Tuplespace take_key_value "response" "sender" "$process_id" >/dev/null 2>&1

    # Emit process stopped event
    TRASH_DEBUG=0 @ Tuplespace putEvent_data "process_stopped" "$process_id"

    @ "$_RECEIVER" debug "Process $process_id cleanup complete"
}

__Process___cleanupInternal() {
  local process_id="$1"
    @ "$_RECEIVER" debug "Internal cleanup for process $process_id"

    # Update process status to stopped
    TRASH_DEBUG=0 @ Tuplespace take_key_value "process" "id" "$process_id" >/dev/null
    TRASH_DEBUG=0 @ Tuplespace put_args "process" \
        "id" "$process_id" \
        "status" "stopped" \
        "stopped" "$(date +%s)"

    # Emit process stopped event
    TRASH_DEBUG=0 @ Tuplespace putEvent_data "process_stopped" "$process_id"
}

__Process__listProcesses() {
    @ "$_RECEIVER" debug "Listing all processes"
    @ "$_RECEIVER" _initTuplespace

    TRASH_DEBUG=0 @ Tuplespace get_key_value "process" "" "" | while IFS= read -r line; do
        if [[ "$line" =~ ^ID: ]]; then
            local process_id=$(echo "$line" | sed 's/^ID: //')
            local process_tuple=$(TRASH_DEBUG=0 @ Tuplespace get_key_value "process" "id" "$process_id")

            if [[ -n "$process_tuple" ]]; then
                local object_name=$(echo "$process_tuple" | TRASH_DEBUG=0 @ Tuplespace field_name - "object")
                local status=$(echo "$process_tuple" | TRASH_DEBUG=0 @ Tuplespace field_name - "status")
                local pid=$(echo "$process_tuple" | TRASH_DEBUG=0 @ Tuplespace field_name - "pid")

                if [[ "$status" == "running" ]]; then
                    # Verify process is actually running
                    if kill -0 "$pid" 2>/dev/null; then
                        echo "$process_id: $object_name (PID: $pid, status: $status)"
                        else
                        # Process died, clean it up
                        @ "$_RECEIVER" debug "Found dead process $process_id, cleaning up"
                        @ "$_RECEIVER" cleanup "$process_id"
                    fi
                    else
                    echo "$process_id: $object_name (status: $status)"
                fi
            fi
        fi
    done
}

__Process__listRunning() {
    @ "$_RECEIVER" debug "Listing running processes"
    @ "$_RECEIVER" _initTuplespace

    TRASH_DEBUG=0 @ Tuplespace get_key_value "process" "status" "running" | while IFS= read -r line; do
        if [[ "$line" =~ ^ID: ]]; then
            local process_id=$(echo "$line" | sed 's/^ID: //')
            local process_tuple=$(TRASH_DEBUG=0 @ Tuplespace get_key_value "process" "id" "$process_id")

            if [[ -n "$process_tuple" ]]; then
                local object_name=$(echo "$process_tuple" | TRASH_DEBUG=0 @ Tuplespace field_name - "object")
                local pid=$(echo "$process_tuple" | TRASH_DEBUG=0 @ Tuplespace field_name - "pid")

                # Verify process is actually running
                if kill -0 "$pid" 2>/dev/null; then
                    echo "$process_id: $object_name (PID: $pid)"
                    else
                    # Process died, clean it up
                    @ "$_RECEIVER" cleanup "$process_id"
                fi
            fi
        fi
    done
}

__Process__status() {
  local process_id="$1"
    if [[ -z "$process_id" ]]; then
        echo "Usage: @ Process status <process_id>"
        return 1
    fi

    @ "$_RECEIVER" debug "Getting status for process $process_id"
    @ "$_RECEIVER" _initTuplespace

    # Get process tuple (suppress debug output)
    local process_tuple
    process_tuple=$(TRASH_DEBUG=0 @ Tuplespace get_key_value "process" "id" "$process_id" 2>/dev/null)
    if [[ -z "$process_tuple" ]]; then
        echo "Process $process_id not found"
        return 1
    fi

    # Extract fields (suppress debug output)
    local object_name status_val pid created
    object_name=$(echo "$process_tuple" | TRASH_DEBUG=0 @ Tuplespace field_name - "object" 2>/dev/null | tail -1)
    status_val=$(echo "$process_tuple" | TRASH_DEBUG=0 @ Tuplespace field_name - "status" 2>/dev/null | tail -1)
    pid=$(echo "$process_tuple" | TRASH_DEBUG=0 @ Tuplespace field_name - "pid" 2>/dev/null | tail -1)
    created=$(echo "$process_tuple" | TRASH_DEBUG=0 @ Tuplespace field_name - "created" 2>/dev/null | tail -1)

    echo "Process ID: $process_id"
    echo "Object: $object_name"
    echo "Status: $status_val"
    echo "PID: $pid"
    echo "Created: $(date -r "$created" 2>/dev/null || echo "$created")"

    if [[ "$status_val" == "running" ]]; then
        if kill -0 "$pid" 2>/dev/null; then
            echo "Process is alive"
            else
            echo "Process appears dead (cleaning up)"
            @ "$_RECEIVER" cleanup "$process_id"
        fi
    fi
}

__Process__cleanupAll() {
    @ "$_RECEIVER" debug "Cleaning up all dead processes"
    @ "$_RECEIVER" _initTuplespace

    local cleaned=0
    TRASH_DEBUG=0 @ Tuplespace get_key_value "process" "status" "running" | while IFS= read -r line; do
        if [[ "$line" =~ ^ID: ]]; then
            local process_id=$(echo "$line" | sed 's/^ID: //')
            local process_tuple=$(TRASH_DEBUG=0 @ Tuplespace get_key_value "process" "id" "$process_id")

            if [[ -n "$process_tuple" ]]; then
                local pid=$(echo "$process_tuple" | TRASH_DEBUG=0 @ Tuplespace field_name - "pid")

                if ! kill -0 "$pid" 2>/dev/null; then
                    @ "$_RECEIVER" debug "Cleaning up dead process: $process_id"
                    @ "$_RECEIVER" cleanup "$process_id"
                    ((cleaned++))
                fi
            fi
        fi
    done

    echo "Cleaned up $cleaned dead processes"
}

__Process__stats() {
    @ "$_RECEIVER" debug "Getting process statistics"
    @ "$_RECEIVER" _initTuplespace

    local total running messages responses
    total=$(TRASH_DEBUG=0 @ Tuplespace count "process")
    running=$(TRASH_DEBUG=0 @ Tuplespace count "process" | grep -c "running" || echo "0")
    messages=$(TRASH_DEBUG=0 @ Tuplespace count "message")
    responses=$(TRASH_DEBUG=0 @ Tuplespace count "response")

    echo "=== Process System Statistics ==="
    echo "Total processes: $total"
    echo "Running processes: $running"
    echo "Pending messages: $messages"
    echo "Pending responses: $responses"
    echo "Tuplespace location: $(TRASH_DEBUG=0 @ Tuplespace info | grep "Directory:" | cut -d: -f2 | xargs)"
}

__Process__help() {
  echo "=== Process Management Commands ==="
  echo "Basic Operations:"
  echo " @ Process spawn <object> - Spawn new process"
  echo " @ Process sendTo <id> message: <msg> - Send message to process"
  echo " @ Process getFrom <id> timeout: [timeout] - Get response from process"
  echo " @ Process terminate <id> - Terminate process"
  echo ""
  echo "Process Management:"
  echo " @ Process listProcesses - List all processes"
  echo " @ Process listRunning - List running processes only"
  echo " @ Process status <id> - Get process status"
  echo " @ Process cleanupAll - Clean up dead processes"
  echo ""
  echo "System Information:"
  echo " @ Process stats - Show system statistics"
  echo " @ Process help - Show this help"
  echo ""
  echo "Examples:"
  echo " process_id=\$(@ Process spawn Tool)"
  echo " @ Process sendTo \$process_id message: install"
  echo " result=\$(@ Process getFrom \$process_id timeout: 10)"
  echo " @ Process terminate \$process_id"
}
