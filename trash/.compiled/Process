#!/usr/bin/env bash
# Generated by Trashtalk Compiler (jq) - DO NOT EDIT
# Source: Process.trash
# Generated: 2025-12-22T01:32:18

__Process__superclass="Object"
__Process__instanceVars="command pid status exitCode stdout stderr startTime endTime"
__Process__classInstanceVars=""
__Process__traits="Debuggable"

__Process__class__for() {
  local command="$1"
    local id=$(_generate_instance_id Process)
    _create_instance Process "$id"
    @ "$id" setCommand "$command"
    @ "$id" setStatus "created"
    echo "$id"
}

__Process__run() {
    local cmd=$(_ivar command)
    local tmp_stdout="/tmp/proc_$$_stdout"
    local tmp_stderr="/tmp/proc_$$_stderr"

    @ "$_RECEIVER" debug "Running command: $cmd"
    _ivar_set status "running"
    _ivar_set startTime "$(date +%s)"

    # Run command, capturing output
    eval "$cmd" >"$tmp_stdout" 2>"$tmp_stderr"
    local exit_code=$?

    _ivar_set exitCode "$exit_code"
    _ivar_set stdout "$(cat "$tmp_stdout" 2>/dev/null)"
    _ivar_set stderr "$(cat "$tmp_stderr" 2>/dev/null)"
    _ivar_set endTime "$(date +%s)"
    _ivar_set status "completed"

    rm -f "$tmp_stdout" "$tmp_stderr"

    echo "$exit_code"
}

__Process__start() {
    local cmd=$(_ivar command)
    local tmp_stdout="/tmp/proc_${_INSTANCE}_stdout"
    local tmp_stderr="/tmp/proc_${_INSTANCE}_stderr"

    @ "$_RECEIVER" debug "Starting background command: $cmd"
    _ivar_set status "running"
    _ivar_set startTime "$(date +%s)"

    # Run command in background
    eval "$cmd" >"$tmp_stdout" 2>"$tmp_stderr" &
    local bg_pid=$!
    _ivar_set pid "$bg_pid"

    echo "$bg_pid"
}

__Process__wait() {
    local proc_pid=$(_ivar pid)
    local proc_status=$(_ivar status)

    if [[ "$proc_status" != "running" ]]; then
        @ "$_RECEIVER" debug "Process not running (status: $proc_status)"
        echo "$(_ivar exitCode)"
        return 0
    fi

    if [[ -z "$proc_pid" ]]; then
        echo "Error: No PID - process was not started in background"
        return 1
    fi

    @ "$_RECEIVER" debug "Waiting for PID $proc_pid"
    wait "$proc_pid" 2>/dev/null
    local exit_code=$?

    # Capture output
    local tmp_stdout="/tmp/proc_${_INSTANCE}_stdout"
    local tmp_stderr="/tmp/proc_${_INSTANCE}_stderr"
    _ivar_set stdout "$(cat "$tmp_stdout" 2>/dev/null)"
    _ivar_set stderr "$(cat "$tmp_stderr" 2>/dev/null)"
    rm -f "$tmp_stdout" "$tmp_stderr"

    _ivar_set exitCode "$exit_code"
    _ivar_set endTime "$(date +%s)"
    _ivar_set status "completed"

    echo "$exit_code"
}

__Process__isRunning() {
    local proc_pid=$(_ivar pid)
    local proc_status=$(_ivar status)

    if [[ "$proc_status" != "running" ]]; then
        echo "false"
        return 1
    fi

    if kill -0 "$proc_pid" 2>/dev/null; then
        echo "true"
        return 0
        else
        # Process finished, update status
        @ "$_RECEIVER" wait >/dev/null 2>&1
        echo "false"
        return 1
    fi
}

__Process__signal() {
  local sig="$1"
    local proc_pid=$(_ivar pid)

    if [[ -z "$proc_pid" ]]; then
        echo "Error: No PID"
        return 1
    fi

    @ "$_RECEIVER" debug "Sending signal $sig to PID $proc_pid"
    kill "-$sig" "$proc_pid" 2>/dev/null
}

__Process__terminate() {
    @ "$_RECEIVER" signal: "TERM"
    _ivar_set status "terminated"
}

__Process__kill() {
    @ "$_RECEIVER" signal: "KILL"
    _ivar_set status "killed"
}

__Process__output() {
    _ivar stdout
}

__Process__errors() {
    _ivar stderr
}

__Process__exitCode() {
    _ivar exitCode
}

__Process__succeeded() {
    local code=$(_ivar exitCode)
    if [[ "$code" == "0" ]]; then
        echo "true"
        return 0
        else
        echo "false"
        return 1
    fi
}

__Process__info() {
    echo "Command: $(_ivar command)"
    echo "PID: $(_ivar pid)"
    echo "Status: $(_ivar status)"
    echo "Exit Code: $(_ivar exitCode)"
    echo "Started: $(date -r "$(_ivar startTime)" 2>/dev/null || echo "$(_ivar startTime)")"
    local end=$(_ivar endTime)
    if [[ -n "$end" ]]; then
        echo "Ended: $(date -r "$end" 2>/dev/null || echo "$end")"
        local start=$(_ivar startTime)
        if [[ -n "$start" ]]; then
            echo "Duration: $((end - start))s"
        fi
    fi
}

__Process__class__exec() {
  local command="$1"
    local tmp_out="/tmp/proc_exec_$$"
    eval "$command" >"$tmp_out" 2>&1
    local exit_code=$?
    cat "$tmp_out"
    rm -f "$tmp_out"
    return $exit_code
}

__Process__class__run() {
  local command="$1"
    eval "$command"
}

__Process__class__spawn() {
  local command="$1"
    eval "$command" >/dev/null 2>&1 &
    echo $!
}

__Process__class__waitPid() {
  local pid="$1"
    wait "$pid" 2>/dev/null
    echo $?
}

__Process__class__isRunningPid() {
  local pid="$1"
    if kill -0 "$pid" 2>/dev/null; then
        echo "true"
        else
        echo "false"
    fi
}

__Process__class__killPid() {
  local pid="$1"
    kill -TERM "$pid" 2>/dev/null
}

__Process__help() {
  echo "=== Process Management ==="
  echo ""
  echo "Instance Methods (for managed processes):"
  echo " proc=\$(@ Process for: \"command\") - Create process wrapper"
  echo " @ \$proc run - Run blocking, capture output"
  echo " @ \$proc start - Run in background"
  echo " @ \$proc wait - Wait for background completion"
  echo " @ \$proc isRunning - Check if still running"
  echo " @ \$proc terminate - Send SIGTERM"
  echo " @ \$proc kill - Send SIGKILL"
  echo " @ \$proc output - Get stdout"
  echo " @ \$proc errors - Get stderr"
  echo " @ \$proc exitCode - Get exit code"
  echo " @ \$proc succeeded - Check if exit code is 0"
  echo " @ \$proc info - Show process info"
  echo ""
  echo "Class Methods (for quick execution):"
  echo " @ Process exec: \" cmd \" - Run, return stdout"
  echo " @ Process run: \" cmd \" - Run, return exit code"
  echo " @ Process spawn: \" cmd \" - Run in background, return PID"
  echo " @ Process waitPid: \$pid - Wait for PID"
  echo " @ Process isRunningPid: \$pid - Check if PID is running"
  echo " @ Process killPid: \$pid - Kill PID"
  echo ""
  echo "Examples:"
  echo " # Quick execution"
  echo " files=\$(@ Process exec: \"ls -la\")"
  echo ""
  echo " # Managed process"
  echo " proc=\$(@ Process for: \"curl -s https://api.example.com\")"
  echo " @ \$proc run"
  echo " if @ \$proc succeeded; then"
  echo " echo \" Response: \$(@ \$proc output)\""
  echo " fi"
}
