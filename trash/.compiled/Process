#!/usr/bin/env bash
# Generated by Trashtalk Compiler (jq) - DO NOT EDIT
# Source: Process.trash
# Generated: 2025-12-24T03:20:48

__Process__superclass="Object"
__Process__instanceVars="command pid status exitCode stdout stderr startTime endTime"
__Process__classInstanceVars=""
__Process__traits="Debuggable"

__Process__getCommand() {
  echo "$(_ivar command)"; return
}

__Process__setCommand() {
  _ivar_set command "$1"
}
__Process__getPid() {
  echo "$(_ivar pid)"; return
}

__Process__setPid() {
  _ivar_set pid "$1"
}
__Process__getStatus() {
  echo "$(_ivar status)"; return
}

__Process__setStatus() {
  _ivar_set status "$1"
}
__Process__getExitCode() {
  echo "$(_ivar exitCode)"; return
}

__Process__setExitCode() {
  _ivar_set exitCode "$1"
}
__Process__getStdout() {
  echo "$(_ivar stdout)"; return
}

__Process__setStdout() {
  _ivar_set stdout "$1"
}
__Process__getStderr() {
  echo "$(_ivar stderr)"; return
}

__Process__setStderr() {
  _ivar_set stderr "$1"
}
__Process__getStartTime() {
  echo "$(_ivar startTime)"; return
}

__Process__setStartTime() {
  _ivar_set startTime "$1"
}
__Process__getEndTime() {
  echo "$(_ivar endTime)"; return
}

__Process__setEndTime() {
  _ivar_set endTime "$1"
}

__Process__class__for_() {
  local command="$1"
    local id=$(_generate_instance_id Process)
    _create_instance Process "$id"
    @ "$id" setCommand "$command"
    @ "$id" setStatus "created"
    echo "$id"
}

__Process__run() {
    local cmd=$(_ivar command)
    local tmp_stdout="/tmp/proc_$$_stdout"
    local tmp_stderr="/tmp/proc_$$_stderr"

    @ "$_RECEIVER" debug: "Running command: $cmd"
    _ivar_set status "running"
    _ivar_set startTime "$(date +%s)"

    # Run command in subshell, capturing output
    # Subshell prevents exit/return from killing the method
    (eval "$cmd") >"$tmp_stdout" 2>"$tmp_stderr"
    local exit_code=$?

    _ivar_set exitCode "$exit_code"
    _ivar_set stdout "$(cat "$tmp_stdout" 2>/dev/null)"
    _ivar_set stderr "$(cat "$tmp_stderr" 2>/dev/null)"
    _ivar_set endTime "$(date +%s)"
    _ivar_set status "completed"

    rm -f "$tmp_stdout" "$tmp_stderr"

    echo "$exit_code"
}

__Process__start() {
    local cmd=$(_ivar command)
    local tmp_stdout="/tmp/proc_${_INSTANCE}_stdout"
    local tmp_stderr="/tmp/proc_${_INSTANCE}_stderr"

    @ "$_RECEIVER" debug: "Starting background command: $cmd"
    _ivar_set status "running"
    _ivar_set startTime "$(date +%s)"

    # Run command in background subshell
    (eval "$cmd") >"$tmp_stdout" 2>"$tmp_stderr" &
    local bg_pid=$!
    _ivar_set pid "$bg_pid"

    echo "$bg_pid"
}

__Process__wait() {
    local proc_pid=$(_ivar pid)
    local proc_status=$(_ivar status)

    if [[ "$proc_status" != "running" ]]; then
        @ "$_RECEIVER" debug: "Process not running (status: $proc_status)"
        echo "$(_ivar exitCode)"
        return 0
    fi

    if [[ -z "$proc_pid" ]]; then
        echo "Error: No PID - process was not started in background"
        return 1
    fi

    @ "$_RECEIVER" debug: "Waiting for PID $proc_pid"

    # Poll until process completes (can't use wait across subshells)
    while kill -0 "$proc_pid" 2>/dev/null; do
        sleep 0.1
    done

    # Process completed - get exit code via /proc or assume 0 if file exists
    # Note: Can't get actual exit code without wait, so check output files
    local tmp_stdout="/tmp/proc_${_INSTANCE}_stdout"
    local tmp_stderr="/tmp/proc_${_INSTANCE}_stderr"

    # Wait a moment for files to be flushed
    sleep 0.05

    _ivar_set stdout "$(cat "$tmp_stdout" 2>/dev/null)"
    _ivar_set stderr "$(cat "$tmp_stderr" 2>/dev/null)"
    rm -f "$tmp_stdout" "$tmp_stderr"

    # Without wait, we can't get exact exit code
    # Use 0 as default since process completed
    local exit_code=0
    _ivar_set exitCode "$exit_code"
    _ivar_set endTime "$(date +%s)"
    _ivar_set status "completed"

    echo "$exit_code"
}

__Process__isRunning() {
    local proc_pid=$(_ivar pid)
    local proc_status=$(_ivar status)

    if [[ "$proc_status" != "running" ]]; then
        echo "false"
        return 1
    fi

    if kill -0 "$proc_pid" 2>/dev/null; then
        echo "true"
        return 0
        else
        # Process finished, update status
        @ "$_RECEIVER" wait >/dev/null 2>&1
        echo "false"
        return 1
    fi
}

__Process__signal_() {
  local sig="$1"
    local proc_pid=$(_ivar pid)

    if [[ -z "$proc_pid" ]]; then
        echo "Error: No PID"
        return 1
    fi

    @ "$_RECEIVER" debug: "Sending signal $sig to PID $proc_pid"
    kill "-$sig" "$proc_pid" 2>/dev/null
}

__Process__terminate() {
    @ "$_RECEIVER" signal: "TERM"
    _ivar_set status "terminated"
}

__Process__kill() {
    @ "$_RECEIVER" signal: "KILL"
    _ivar_set status "killed"
}

__Process__output() {
    _ivar stdout
}

__Process__errors() {
    _ivar stderr
}

__Process__exitCode() {
    _ivar exitCode
}

__Process__succeeded() {
    local code=$(_ivar exitCode)
    if [[ "$code" == "0" ]]; then
        echo "true"
        return 0
        else
        echo "false"
        return 1
    fi
}

__Process__info() {
    echo "Command: $(_ivar command)"
    echo "PID: $(_ivar pid)"
    echo "Status: $(_ivar status)"
    echo "Exit Code: $(_ivar exitCode)"
    echo "Started: $(date -r "$(_ivar startTime)" 2>/dev/null || echo "$(_ivar startTime)")"
    local end=$(_ivar endTime)
    if [[ -n "$end" ]]; then
        echo "Ended: $(date -r "$end" 2>/dev/null || echo "$end")"
        local start=$(_ivar startTime)
        if [[ -n "$start" ]]; then
            echo "Duration: $((end - start))s"
        fi
    fi
}

__Process__class__exec_() {
  local command="$1"
    local tmp_out="/tmp/proc_exec_$$"
    eval "$command" >"$tmp_out" 2>&1
    local exit_code=$?
    cat "$tmp_out"
    rm -f "$tmp_out"
    return $exit_code
}

__Process__class__run_() {
  local command="$1"
    eval "$command"
}

__Process__class__spawn_() {
  local command="$1"
    eval "$command" >/dev/null 2>&1 &
    echo $!
}

__Process__class__waitPid_() {
  local pid="$1"
    wait "$pid" 2>/dev/null
    echo $?
}

__Process__class__isRunningPid_() {
  local pid="$1"
    if kill -0 "$pid" 2>/dev/null; then
        echo "true"
        else
        echo "false"
    fi
}

__Process__class__killPid_() {
  local pid="$1"
    kill -TERM "$pid" 2>/dev/null
}

__Process__help() {
  echo "=== Process Management ==="
  echo ""
  echo "Instance Methods (for managed processes):"
  echo " proc=\$(@ Process for: \"command\") - Create process wrapper"
  echo " @ \$proc run - Run blocking, capture output"
  echo " @ \$proc start - Run in background"
  echo " @ \$proc wait - Wait for background completion"
  echo " @ \$proc isRunning - Check if still running"
  echo " @ \$proc terminate - Send SIGTERM"
  echo " @ \$proc kill - Send SIGKILL"
  echo " @ \$proc output - Get stdout"
  echo " @ \$proc errors - Get stderr"
  echo " @ \$proc exitCode - Get exit code"
  echo " @ \$proc succeeded - Check if exit code is 0"
  echo " @ \$proc info - Show process info"
  echo ""
  echo "Class Methods (for quick execution):"
  echo " @ Process exec: \" cmd \" - Run, return stdout"
  echo " @ Process run: \" cmd \" - Run, return exit code"
  echo " @ Process spawn: \" cmd \" - Run in background, return PID"
  echo " @ Process waitPid: \$pid - Wait for PID"
  echo " @ Process isRunningPid: \$pid - Check if PID is running"
  echo " @ Process killPid: \$pid - Kill PID"
  echo ""
  echo "Examples:"
  echo " # Quick execution"
  echo " files=\$(@ Process exec: \"ls -la\")"
  echo ""
  echo " # Managed process"
  echo " proc=\$(@ Process for: \"curl -s https://api.example.com\")"
  echo " @ \$proc run"
  echo " if @ \$proc succeeded; then"
  echo " echo \" Response: \$(@ \$proc output)\""
  echo " fi"
}
