#!/usr/bin/env bash
# Generated by Trashtalk Compiler (jq) - DO NOT EDIT
# Source: Process.trash
# Generated: 2026-01-12T19:23:14

__Process__superclass="Object"
__Process__instanceVars="command pid status exitCode stdout stderr startTime endTime"
__Process__classInstanceVars=""
__Process__traits="Debuggable"
__Process__sourceHash="e05affa592a2029941db851398faaf3b69816351d0f866759be3aa185f7d27e1"

__Process__source() {
  cat <<'__TRASHTALK_SOURCE_EOF__'
# Process - External OS process management
# Provides an interface to spawn and manage POSIX processes
# Built on Shell primitives - no raw bash required.
Process subclass: Object
  include: Debuggable
  instanceVars: command pid status exitCode stdout stderr startTime endTime

  # Create a new process wrapper for a command
  # Usage: proc=$(@ Process for: "curl -s https://example.com")
  classMethod: for: command [
    | id |
    id := @ Runtime generateId: "Process"
    @ Runtime create: "Process" id: id
    @ $id setCommand: command
    @ $id setStatus: "created"
    ^ id
  ]

  # Run the command in the foreground (blocking)
  # Captures stdout/stderr and exit code
  method: run [
    | cmd result exitCodeVal stdoutVal stderrVal |
    cmd := $(_ivar command)

    @ self debug: "Running command: $cmd"
    status := "running"
    startTime := $(@ Time now)

    # Use Shell execFull to capture stdout, stderr, and exit code
    result := $(@ Shell execFull: "$cmd")

    # Parse JSON result using jq
    stdoutVal := $(@ Tools::Jq get: "stdout" from: "$result")
    stderrVal := $(@ Tools::Jq get: "stderr" from: "$result")
    exitCodeVal := $(@ Tools::Jq get: "exitCode" from: "$result")

    exitCode := "$exitCodeVal"
    stdout := "$stdoutVal"
    stderr := "$stderrVal"
    endTime := $(@ Time now)
    status := "completed"

    ^ exitCodeVal
  ]

  # Start the command in the background (non-blocking)
  # Returns immediately, use wait or poll to check completion
  method: start [
    | cmd instance tmpStdout tmpStderr bgPid |
    cmd := $(_ivar command)
    instance := $(@ Runtime instance)

    tmpStdout := "/tmp/proc_${instance}_stdout"
    tmpStderr := "/tmp/proc_${instance}_stderr"

    @ self debug: "Starting background command: $cmd"
    status := "running"
    startTime := $(@ Time now)

    # Use Shell spawn with separate stdout/stderr files
    bgPid := $(@ Shell spawn: "$cmd" stdoutTo: "$tmpStdout" stderrTo: "$tmpStderr")
    pid := "$bgPid"

    ^ bgPid
  ]

  # Wait for a background process to complete
  primitiveMethod: wait [
    local procPid procStatus instance tmpStdout tmpStderr exitCodeVal stdoutVal stderrVal
    procPid=$(_ivar pid)
    procStatus=$(_ivar status)

    if [[ "$procStatus" != "running" ]]; then
      @ "$_RECEIVER" debug: "Process not running (status: $procStatus)"
      echo "$(_ivar exitCode)"
      return
    fi

    if [[ -z "$procPid" ]]; then
      @ Console error: "Error: No PID - process was not started in background"
      echo "1"
      return
    fi

    @ "$_RECEIVER" debug: "Waiting for PID $procPid"

    # Poll until process completes
    while @ Shell isAlive: "$procPid" | grep -q "true"; do
      @ Time sleep: "0.1"
    done

    # Process completed - read captured output
    instance=$(@ Runtime instance)
    tmpStdout="/tmp/proc_${instance}_stdout"
    tmpStderr="/tmp/proc_${instance}_stderr"

    # Wait a moment for files to be flushed
    @ Time sleep: "0.05"

    stdoutVal=$(@ File read: "$tmpStdout")
    stderrVal=$(@ File read: "$tmpStderr")
    @ File delete: "$tmpStdout"
    @ File delete: "$tmpStderr"

    _ivar_set stdout "$stdoutVal"
    _ivar_set stderr "$stderrVal"

    # Without wait syscall, we can't get exact exit code
    exitCodeVal="0"
    _ivar_set exitCode "$exitCodeVal"
    _ivar_set endTime "$(@ Time now)"
    _ivar_set status "completed"

    echo "$exitCodeVal"
  ]

  # Check if the process is still running
  primitiveMethod: isRunning [
    local procPid procStatus isAlive
    procPid=$(_ivar pid)
    procStatus=$(_ivar status)

    if [[ "$procStatus" != "running" ]]; then
      echo "false"
      return
    fi

    isAlive=$(@ Shell isAlive: "$procPid")
    if [[ "$isAlive" == "true" ]]; then
      echo "true"
      return
    fi

    # Process finished, update status
    @ "$_RECEIVER" wait
    echo "false"
  ]

  # Send a signal to the process
  primitiveMethod: signal: sig [
    local procPid="$1"
    procPid=$(_ivar pid)

    if [[ -z "$procPid" ]]; then
      @ Console error: "Error: No PID"
      echo ""
      return
    fi

    @ "$_RECEIVER" debug: "Sending signal $1 to PID $procPid"
    @ Shell signal: "$1" to: "$procPid"
  ]

  # Terminate the process (SIGTERM)
  method: terminate [
    | procPid |
    procPid := $(_ivar pid)
    @ Shell terminate: "$procPid"
    status := "terminated"
  ]

  # Kill the process (SIGKILL)
  method: kill [
    | procPid |
    procPid := $(_ivar pid)
    @ Shell kill: "$procPid"
    status := "killed"
  ]

  # Get stdout from the process
  method: output [
    ^ $(_ivar stdout)
  ]

  # Get stderr from the process
  method: errors [
    ^ $(_ivar stderr)
  ]

  # Get exit code
  method: exitCode [
    ^ $(_ivar exitCode)
  ]

  # Check if process succeeded (exit code 0)
  primitiveMethod: succeeded [
    local code
    code=$(_ivar exitCode)
    if [[ "$code" == "0" ]]; then
      echo "true"
    else
      echo "false"
    fi
  ]

  # Get process info
  primitiveMethod: info [
    local start endTimeVal duration
    @ Console print: "Command: $(_ivar command)"
    @ Console print: "PID: $(_ivar pid)"
    @ Console print: "Status: $(_ivar status)"
    @ Console print: "Exit Code: $(_ivar exitCode)"
    start=$(_ivar startTime)
    @ Console print: "Started: $(@ Time formatISO: "$start")"
    endTimeVal=$(_ivar endTime)
    if [[ -n "$endTimeVal" ]]; then
      @ Console print: "Ended: $(@ Time formatISO: "$endTimeVal")"
      duration=$(@ Time from: "$start" to: "$endTimeVal")
      @ Console print: "Duration: ${duration}s"
    fi
  ]

  # === Class methods for quick execution ===

  # Run a command and return stdout (blocking, simple)
  # Usage: output=$(@ Process exec: "ls -la")
  classMethod: exec: command [
    ^ @ Shell execAll: command
  ]

  # Run a command and return exit code only
  # Usage: @ Process run: "make test"
  classMethod: run: command [
    ^ @ Shell run: command
  ]

  # Run a command in background, return PID
  # Usage: pid=$(@ Process spawn: "long-running-task")
  classMethod: spawn: command [
    ^ @ Shell spawn: command
  ]

  # Wait for a PID to complete
  # Usage: @ Process waitPid: $pid
  classMethod: waitPid: pid [
    ^ @ Shell wait: pid
  ]

  # Check if a PID is running
  # Usage: @ Process isRunningPid: $pid
  classMethod: isRunningPid: pid [
    ^ @ Shell isAlive: pid
  ]

  # Kill a PID
  # Usage: @ Process killPid: $pid
  classMethod: killPid: pid [
    ^ @ Shell terminate: pid
  ]

  # Show help
  method: help [
    @ Console print: "=== Process Management ==="
    @ Console print: ""
    @ Console print: "Instance Methods (for managed processes):"
    @ Console print: "  proc=\$(@ Process for: \"command\")   - Create process wrapper"
    @ Console print: "  @ \$proc run                          - Run blocking, capture output"
    @ Console print: "  @ \$proc start                        - Run in background"
    @ Console print: "  @ \$proc wait                         - Wait for background completion"
    @ Console print: "  @ \$proc isRunning                    - Check if still running"
    @ Console print: "  @ \$proc terminate                    - Send SIGTERM"
    @ Console print: "  @ \$proc kill                         - Send SIGKILL"
    @ Console print: "  @ \$proc output                       - Get stdout"
    @ Console print: "  @ \$proc errors                       - Get stderr"
    @ Console print: "  @ \$proc exitCode                     - Get exit code"
    @ Console print: "  @ \$proc succeeded                    - Check if exit code is 0"
    @ Console print: "  @ \$proc info                         - Show process info"
  ]
__TRASHTALK_SOURCE_EOF__
}

__Process__command() {
  echo "$(_ivar command)"; return
}

__Process__command_() {
  _ivar_set command "$1"
}

__Process__getCommand() {
  echo "$(_ivar command)"; return
}

__Process__setCommand_() {
  _ivar_set command "$1"
}
__Process__pid() {
  echo "$(_ivar pid)"; return
}

__Process__pid_() {
  _ivar_set pid "$1"
}

__Process__getPid() {
  echo "$(_ivar pid)"; return
}

__Process__setPid_() {
  _ivar_set pid "$1"
}
__Process__status() {
  echo "$(_ivar status)"; return
}

__Process__status_() {
  _ivar_set status "$1"
}

__Process__getStatus() {
  echo "$(_ivar status)"; return
}

__Process__setStatus_() {
  _ivar_set status "$1"
}
__Process__exitCode() {
  echo "$(_ivar exitCode)"; return
}

__Process__exitCode_() {
  _ivar_set exitCode "$1"
}

__Process__getExitCode() {
  echo "$(_ivar exitCode)"; return
}

__Process__setExitCode_() {
  _ivar_set exitCode "$1"
}
__Process__stdout() {
  echo "$(_ivar stdout)"; return
}

__Process__stdout_() {
  _ivar_set stdout "$1"
}

__Process__getStdout() {
  echo "$(_ivar stdout)"; return
}

__Process__setStdout_() {
  _ivar_set stdout "$1"
}
__Process__stderr() {
  echo "$(_ivar stderr)"; return
}

__Process__stderr_() {
  _ivar_set stderr "$1"
}

__Process__getStderr() {
  echo "$(_ivar stderr)"; return
}

__Process__setStderr_() {
  _ivar_set stderr "$1"
}
__Process__startTime() {
  echo "$(_ivar startTime)"; return
}

__Process__startTime_() {
  _ivar_set startTime "$1"
}

__Process__getStartTime() {
  echo "$(_ivar startTime)"; return
}

__Process__setStartTime_() {
  _ivar_set startTime "$1"
}
__Process__endTime() {
  echo "$(_ivar endTime)"; return
}

__Process__endTime_() {
  _ivar_set endTime "$1"
}

__Process__getEndTime() {
  echo "$(_ivar endTime)"; return
}

__Process__setEndTime_() {
  _ivar_set endTime "$1"
}

__Process__class__for_() {
  local command="$1"
  local id
  id="$(@ Runtime generateId: "Process")"
  @ Runtime create: "Process" id: "$id"
  @ "$id" setCommand: "$command"
  @ "$id" setStatus: "created"
  echo "$id"; return
}

__Process__run() {
  local cmd result exitCodeVal stdoutVal stderrVal
  cmd="$(_ivar command)"
  @ "$_RECEIVER" debug: "Running command: $cmd"
  _ivar_set status "running"
  _ivar_set startTime "$(@ Time now)"
  result="$(@ Shell execFull: "$cmd")"
  stdoutVal="$(@ Tools::Jq get: "stdout" from: "$result")"
  stderrVal="$(@ Tools::Jq get: "stderr" from: "$result")"
  exitCodeVal="$(@ Tools::Jq get: "exitCode" from: "$result")"
  _ivar_set exitCode "$exitCodeVal"
  _ivar_set stdout "$stdoutVal"
  _ivar_set stderr "$stderrVal"
  _ivar_set endTime "$(@ Time now)"
  _ivar_set status "completed"
  echo "$exitCodeVal"; return
}

__Process__start() {
  local cmd instance tmpStdout tmpStderr bgPid
  cmd="$(_ivar command)"
  instance="$(@ Runtime instance)"
  tmpStdout="/tmp/proc_${instance}_stdout"
  tmpStderr="/tmp/proc_${instance}_stderr"
  @ "$_RECEIVER" debug: "Starting background command: $cmd"
  _ivar_set status "running"
  _ivar_set startTime "$(@ Time now)"
  bgPid="$(@ Shell spawn: "$cmd" stdoutTo: "$tmpStdout" stderrTo: "$tmpStderr")"
  _ivar_set pid "$bgPid"
  echo "$bgPid"; return
}

__Process__wait() {
    local procPid procStatus instance tmpStdout tmpStderr exitCodeVal stdoutVal stderrVal
    procPid=$(_ivar pid)
    procStatus=$(_ivar status)

    if [[ "$procStatus" != "running" ]]; then
        @ "$_RECEIVER" debug: "Process not running (status: $procStatus)"
        echo "$(_ivar exitCode)"
        return
    fi

    if [[ -z "$procPid" ]]; then
        @ Console error: "Error: No PID - process was not started in background"
        echo "1"
        return
    fi

    @ "$_RECEIVER" debug: "Waiting for PID $procPid"

    # Poll until process completes
    while @ Shell isAlive: "$procPid" | grep -q "true"; do
        @ Time sleep: "0.1"
    done

    # Process completed - read captured output
    instance=$(@ Runtime instance)
    tmpStdout="/tmp/proc_${instance}_stdout"
    tmpStderr="/tmp/proc_${instance}_stderr"

    # Wait a moment for files to be flushed
    @ Time sleep: "0.05"

    stdoutVal=$(@ File read: "$tmpStdout")
    stderrVal=$(@ File read: "$tmpStderr")
    @ File delete: "$tmpStdout"
    @ File delete: "$tmpStderr"

    _ivar_set stdout "$stdoutVal"
    _ivar_set stderr "$stderrVal"

    # Without wait syscall, we can't get exact exit code
    exitCodeVal="0"
    _ivar_set exitCode "$exitCodeVal"
    _ivar_set endTime "$(@ Time now)"
    _ivar_set status "completed"

    echo "$exitCodeVal"
}

__Process__isRunning() {
    local procPid procStatus isAlive
    procPid=$(_ivar pid)
    procStatus=$(_ivar status)

    if [[ "$procStatus" != "running" ]]; then
        echo "false"
        return
    fi

    isAlive=$(@ Shell isAlive: "$procPid")
    if [[ "$isAlive" == "true" ]]; then
        echo "true"
        return
    fi

    # Process finished, update status
    @ "$_RECEIVER" wait
    echo "false"
}

__Process__signal_() {
  local sig="$1"
    local procPid="$1"
    procPid=$(_ivar pid)

    if [[ -z "$procPid" ]]; then
        @ Console error: "Error: No PID"
        echo ""
        return
    fi

    @ "$_RECEIVER" debug: "Sending signal $1 to PID $procPid"
    @ Shell signal: "$1" to: "$procPid"
}

__Process__terminate() {
  local procPid
  procPid="$(_ivar pid)"
  @ Shell terminate: "$procPid"
  _ivar_set status "terminated"
}

__Process__kill() {
  local procPid
  procPid="$(_ivar pid)"
  @ Shell kill: "$procPid"
  _ivar_set status "killed"
}

__Process__output() {
  echo $(_ivar stdout)
}

__Process__errors() {
  echo $(_ivar stderr)
}

__Process__exitCode() {
  echo $(_ivar exitCode)
}

__Process__succeeded() {
    local code
    code=$(_ivar exitCode)
    if [[ "$code" == "0" ]]; then
        echo "true"
        else
        echo "false"
    fi
}

__Process__info() {
    local start endTimeVal duration
    @ Console print: "Command: $(_ivar command)"
    @ Console print: "PID: $(_ivar pid)"
    @ Console print: "Status: $(_ivar status)"
    @ Console print: "Exit Code: $(_ivar exitCode)"
    start=$(_ivar startTime)
    @ Console print: "Started: $(@ Time formatISO: "$start")"
    endTimeVal=$(_ivar endTime)
    if [[ -n "$endTimeVal" ]]; then
        @ Console print: "Ended: $(@ Time formatISO: "$endTimeVal")"
        duration=$(@ Time from: "$start" to: "$endTimeVal")
        @ Console print: "Duration: ${duration}s"
    fi
}

__Process__class__exec_() {
  local command="$1"
  @ Shell execAll: "$command"; return
}

__Process__class__run_() {
  local command="$1"
  @ Shell run: "$command"; return
}

__Process__class__spawn_() {
  local command="$1"
  @ Shell spawn: "$command"; return
}

__Process__class__waitPid_() {
  local pid="$1"
  @ Shell wait: "$pid"; return
}

__Process__class__isRunningPid_() {
  local pid="$1"
  @ Shell isAlive: "$pid"; return
}

__Process__class__killPid_() {
  local pid="$1"
  @ Shell terminate: "$pid"; return
}

__Process__help() {
  @ Console print: "=== Process Management ==="
  @ Console print: ""
  @ Console print: "Instance Methods (for managed processes):"
  @ Console print: "  proc=\$(@ Process for: \"command\")   - Create process wrapper"
  @ Console print: "  @ \$proc run                          - Run blocking, capture output"
  @ Console print: "  @ \$proc start                        - Run in background"
  @ Console print: "  @ \$proc wait                         - Wait for background completion"
  @ Console print: "  @ \$proc isRunning                    - Check if still running"
  @ Console print: "  @ \$proc terminate                    - Send SIGTERM"
  @ Console print: "  @ \$proc kill                         - Send SIGKILL"
  @ Console print: "  @ \$proc output                       - Get stdout"
  @ Console print: "  @ \$proc errors                       - Get stderr"
  @ Console print: "  @ \$proc exitCode                     - Get exit code"
  @ Console print: "  @ \$proc succeeded                    - Check if exit code is 0"
  @ Console print: "  @ \$proc info                         - Show process info"
}
