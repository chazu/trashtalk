#!/usr/bin/env bash
# Generated by Trashtalk Compiler (jq) - DO NOT EDIT
# Source: Transcript.trash
# Generated: 2026-01-13T14:09:31

__Yutani__Transcript__superclass="Yutani::Application"
__Yutani__Transcript__instanceVars="outputView: inputField: layout: history:"
__Yutani__Transcript__classInstanceVars=""
__Yutani__Transcript__traits=""
__Yutani__Transcript__sourceHash="208587c20b0485fd3f6f596bd30b237a78c1889b339c3dea71ce2084fca474a5"
__Yutani__Transcript__package="Yutani"
__Yutani__Transcript__qualifiedName="Yutani::Transcript"

__Yutani__Transcript__source() {
  cat <<'__TRASHTALK_SOURCE_EOF__'
package: Yutani

Transcript subclass: Yutani::Application
  instanceVars: outputView:'' inputField:'' layout:'' history:''

  # Override setup to build the UI
  # Uses globals for event handler references (bash-specific pattern)
  rawMethod: setup [
    pragma: bashOnly
    local _layout _outputView _inputField initialText

    # Store self in global for event handlers
    __TRANSCRIPT_SELF="$_RECEIVER"

    # Create layout
    _layout=$(@ "$_RECEIVER" createVerticalLayout)
    _ivar_set layout "$_layout"

    # Create output view with initial text
    initialText="Trashtalk Transcript
Type code and press Enter to evaluate. Ctrl+C to exit.
"
    _outputView=$(@ "$_RECEIVER" createTextView: "Output" text: "$initialText")
    _ivar_set outputView "$_outputView"
    _ivar_set history "$initialText"

    # Create input field
    _inputField=$(@ "$_RECEIVER" createInputField: ">" placeholder: "Enter Trashtalk code...")
    _ivar_set inputField "$_inputField"

    # Add widgets to layout
    @ "$_layout" addChild: "$_outputView"
    @ "$_layout" addChild: "$_inputField" fixedSize: 3 focus: true

    # Set root
    @ "$_RECEIVER" setRoot: "$_layout"

    # Register event handlers using global reference
    @ "$_inputField" onSubmitDo: '@ "$__TRANSCRIPT_SELF" evaluateInput: "$__TEXT"'
    @ "$_RECEIVER" onKeyDo: '@ "$__TRANSCRIPT_SELF" handleKey: "$__EVENT"'
  ]

  # Handle key events (uses bash case statement)
  rawMethod: handleKey: event [
    pragma: bashOnly
    local event="$1" keyName _inputField

    keyName=$(@ "$event" keyName)
    _inputField="$(_ivar inputField)"

    case "$keyName" in
      KEY_CTRL_C|KEY_CTRL_D)
        @ "$_RECEIVER" stop
        ;;
      KEY_CTRL_L)
        @ "$_RECEIVER" clearOutput
        ;;
      KEY_TAB)
        @ "$_inputField" focus
        ;;
      KEY_ESC)
        @ "$_inputField" clear
        @ "$_inputField" focus
        ;;
    esac
  ]

  # Evaluate input text (uses bash control flow and multi-line string building)
  rawMethod: evaluateInput: text [
    pragma: bashOnly
    local text="$1" result _inputField newText

    if [[ -z "$text" ]]; then
      return
    fi

    _inputField="$(_ivar inputField)"

    # Evaluate the code
    result=$(@ Trash eval: "$text" 2>&1)

    # Build output
    newText="> ${text}
${result}

"

    # Append to output
    @ "$_RECEIVER" appendOutput: "$newText"

    # Clear and refocus input
    @ "$_inputField" clear
    @ "$_inputField" focus
  ]

  # Append text to output
  method: appendOutput: text [
    | currentHistory |
    currentHistory := "${history}${text}".
    history := currentHistory.
    @ outputView setText: currentHistory
  ]

  # Clear output
  method: clearOutput [
    history := ''.
    @ outputView clear
  ]
__TRASHTALK_SOURCE_EOF__
}

__Yutani__Transcript__outputView() {
  echo "$(_ivar outputView)"; return
}

__Yutani__Transcript__outputView_() {
  _ivar_set outputView "$1"
}

__Yutani__Transcript__getOutputView() {
  echo "$(_ivar outputView)"; return
}

__Yutani__Transcript__setOutputView_() {
  _ivar_set outputView "$1"
}
__Yutani__Transcript__inputField() {
  echo "$(_ivar inputField)"; return
}

__Yutani__Transcript__inputField_() {
  _ivar_set inputField "$1"
}

__Yutani__Transcript__getInputField() {
  echo "$(_ivar inputField)"; return
}

__Yutani__Transcript__setInputField_() {
  _ivar_set inputField "$1"
}
__Yutani__Transcript__layout() {
  echo "$(_ivar layout)"; return
}

__Yutani__Transcript__layout_() {
  _ivar_set layout "$1"
}

__Yutani__Transcript__getLayout() {
  echo "$(_ivar layout)"; return
}

__Yutani__Transcript__setLayout_() {
  _ivar_set layout "$1"
}
__Yutani__Transcript__history() {
  echo "$(_ivar history)"; return
}

__Yutani__Transcript__history_() {
  _ivar_set history "$1"
}

__Yutani__Transcript__getHistory() {
  echo "$(_ivar history)"; return
}

__Yutani__Transcript__setHistory_() {
  _ivar_set history "$1"
}

declare -g __Yutani__Transcript__setup__bashOnly=1
__Yutani__Transcript__setup() {
    local _layout _outputView _inputField initialText

    # Store self in global for event handlers
    __TRANSCRIPT_SELF="$_RECEIVER"

    # Create layout
    _layout=$(@ "$_RECEIVER" createVerticalLayout)
    _ivar_set layout "$_layout"

    # Create output view with initial text
    initialText="Trashtalk Transcript
    Type code and press Enter to evaluate. Ctrl+C to exit.
    "
    _outputView=$(@ "$_RECEIVER" createTextView: "Output" text: "$initialText")
    _ivar_set outputView "$_outputView"
    _ivar_set history "$initialText"

    # Create input field
    _inputField=$(@ "$_RECEIVER" createInputField: ">" placeholder: "Enter Trashtalk code...")
    _ivar_set inputField "$_inputField"

    # Add widgets to layout
    @ "$_layout" addChild: "$_outputView"
    @ "$_layout" addChild: "$_inputField" fixedSize: 3 focus: true

    # Set root
    @ "$_RECEIVER" setRoot: "$_layout"

    # Register event handlers using global reference
    @ "$_inputField" onSubmitDo: '@ "$__TRANSCRIPT_SELF" evaluateInput: "$__TEXT"'
    @ "$_RECEIVER" onKeyDo: '@ "$__TRANSCRIPT_SELF" handleKey: "$__EVENT"'
}

declare -g __Yutani__Transcript__handleKey___bashOnly=1
__Yutani__Transcript__handleKey_() {
  local event="$1"
    local event="$1" keyName _inputField

    keyName=$(@ "$event" keyName)
    _inputField="$(_ivar inputField)"

    case "$keyName" in
        KEY_CTRL_C | KEY_CTRL_D)
        @ "$_RECEIVER" stop
    ;;
        KEY_CTRL_L)
        @ "$_RECEIVER" clearOutput
    ;;
        KEY_TAB)
        @ "$_inputField" focus
    ;;
        KEY_ESC)
        @ "$_inputField" clear
        @ "$_inputField" focus
    ;;
    esac
}

declare -g __Yutani__Transcript__evaluateInput___bashOnly=1
__Yutani__Transcript__evaluateInput_() {
  local text="$1"
    local text="$1" result _inputField newText

    if [[ -z "$text" ]]; then
        return
    fi

    _inputField="$(_ivar inputField)"

    # Evaluate the code
    result=$(@ Trash eval: "$text" 2>&1)

    # Build output
    newText="> ${text}
    ${result}

    "

    # Append to output
    @ "$_RECEIVER" appendOutput: "$newText"

    # Clear and refocus input
    @ "$_inputField" clear
    @ "$_inputField" focus
}

__Yutani__Transcript__appendOutput_() {
  local text="$1"
  local currentHistory
  currentHistory="$(_ivar history)${text}"
  _ivar_set history "$currentHistory"
  @ "$(_ivar outputView)" setText: "$currentHistory"
}

__Yutani__Transcript__clearOutput() {
  _ivar_set history ""
  @ "$(_ivar outputView)" clear
}
