# Process - External OS process management
# Provides an interface to spawn and manage POSIX processes
Process subclass: Object
  include: Debuggable
  instanceVars: command pid status exitCode stdout stderr startTime endTime

  # Create a new process wrapper for a command
  # Usage: proc=$(@ Process for: "curl -s https://example.com")
  rawClassMethod: for: command [
    local id=$(_generate_instance_id Process)
    _create_instance Process "$id"
    @ "$id" setCommand "$command"
    @ "$id" setStatus "created"
    echo "$id"
  ]

  # Run the command in the foreground (blocking)
  # Captures stdout/stderr and exit code
  rawMethod: run [
    local cmd=$(_ivar command)
    local tmp_stdout="/tmp/proc_$$_stdout"
    local tmp_stderr="/tmp/proc_$$_stderr"

    @ "$_RECEIVER" debug: "Running command: $cmd"
    _ivar_set status "running"
    _ivar_set startTime "$(date +%s)"

    # Run command in subshell, capturing output
    # Subshell prevents exit/return from killing the method
    (eval "$cmd") >"$tmp_stdout" 2>"$tmp_stderr"
    local exit_code=$?

    _ivar_set exitCode "$exit_code"
    _ivar_set stdout "$(cat "$tmp_stdout" 2>/dev/null)"
    _ivar_set stderr "$(cat "$tmp_stderr" 2>/dev/null)"
    _ivar_set endTime "$(date +%s)"
    _ivar_set status "completed"

    rm -f "$tmp_stdout" "$tmp_stderr"

    echo "$exit_code"
  ]

  # Start the command in the background (non-blocking)
  # Returns immediately, use wait or poll to check completion
  rawMethod: start [
    local cmd=$(_ivar command)
    local tmp_stdout="/tmp/proc_${_INSTANCE}_stdout"
    local tmp_stderr="/tmp/proc_${_INSTANCE}_stderr"

    @ "$_RECEIVER" debug: "Starting background command: $cmd"
    _ivar_set status "running"
    _ivar_set startTime "$(date +%s)"

    # Run command in background subshell
    (eval "$cmd") >"$tmp_stdout" 2>"$tmp_stderr" &
    local bg_pid=$!
    _ivar_set pid "$bg_pid"

    echo "$bg_pid"
  ]

  # Wait for a background process to complete
  # Note: Uses polling since @ runs in subshells and can't use bash wait builtin
  rawMethod: wait [
    local proc_pid=$(_ivar pid)
    local proc_status=$(_ivar status)

    if [[ "$proc_status" != "running" ]]; then
      @ "$_RECEIVER" debug: "Process not running (status: $proc_status)"
      echo "$(_ivar exitCode)"
      return 0
    fi

    if [[ -z "$proc_pid" ]]; then
      echo "Error: No PID - process was not started in background"
      return 1
    fi

    @ "$_RECEIVER" debug: "Waiting for PID $proc_pid"

    # Poll until process completes (can't use wait across subshells)
    while kill -0 "$proc_pid" 2>/dev/null; do
      sleep 0.1
    done

    # Process completed - get exit code via /proc or assume 0 if file exists
    # Note: Can't get actual exit code without wait, so check output files
    local tmp_stdout="/tmp/proc_${_INSTANCE}_stdout"
    local tmp_stderr="/tmp/proc_${_INSTANCE}_stderr"

    # Wait a moment for files to be flushed
    sleep 0.05

    _ivar_set stdout "$(cat "$tmp_stdout" 2>/dev/null)"
    _ivar_set stderr "$(cat "$tmp_stderr" 2>/dev/null)"
    rm -f "$tmp_stdout" "$tmp_stderr"

    # Without wait, we can't get exact exit code
    # Use 0 as default since process completed
    local exit_code=0
    _ivar_set exitCode "$exit_code"
    _ivar_set endTime "$(date +%s)"
    _ivar_set status "completed"

    echo "$exit_code"
  ]

  # Check if the process is still running
  rawMethod: isRunning [
    local proc_pid=$(_ivar pid)
    local proc_status=$(_ivar status)

    if [[ "$proc_status" != "running" ]]; then
      echo "false"
      return 1
    fi

    if kill -0 "$proc_pid" 2>/dev/null; then
      echo "true"
      return 0
    else
      # Process finished, update status
      @ "$_RECEIVER" wait >/dev/null 2>&1
      echo "false"
      return 1
    fi
  ]

  # Send a signal to the process
  rawMethod: signal: sig [
    local proc_pid=$(_ivar pid)

    if [[ -z "$proc_pid" ]]; then
      echo "Error: No PID"
      return 1
    fi

    @ "$_RECEIVER" debug: "Sending signal $sig to PID $proc_pid"
    kill "-$sig" "$proc_pid" 2>/dev/null
  ]

  # Terminate the process (SIGTERM)
  rawMethod: terminate [
    @ "$_RECEIVER" signal: "TERM"
    _ivar_set status "terminated"
  ]

  # Kill the process (SIGKILL)
  rawMethod: kill [
    @ "$_RECEIVER" signal: "KILL"
    _ivar_set status "killed"
  ]

  # Get stdout from the process
  rawMethod: output [
    _ivar stdout
  ]

  # Get stderr from the process
  rawMethod: errors [
    _ivar stderr
  ]

  # Get exit code
  rawMethod: exitCode [
    _ivar exitCode
  ]

  # Check if process succeeded (exit code 0)
  rawMethod: succeeded [
    local code=$(_ivar exitCode)
    if [[ "$code" == "0" ]]; then
      echo "true"
      return 0
    else
      echo "false"
      return 1
    fi
  ]

  # Get process info
  rawMethod: info [
    echo "Command: $(_ivar command)"
    echo "PID: $(_ivar pid)"
    echo "Status: $(_ivar status)"
    echo "Exit Code: $(_ivar exitCode)"
    echo "Started: $(date -r "$(_ivar startTime)" 2>/dev/null || echo "$(_ivar startTime)")"
    local end=$(_ivar endTime)
    if [[ -n "$end" ]]; then
      echo "Ended: $(date -r "$end" 2>/dev/null || echo "$end")"
      local start=$(_ivar startTime)
      if [[ -n "$start" ]]; then
        echo "Duration: $((end - start))s"
      fi
    fi
  ]

  # === Class methods for quick execution ===

  # Run a command and return stdout (blocking, simple)
  # Usage: output=$(@ Process exec: "ls -la")
  rawClassMethod: exec: command [
    local tmp_out="/tmp/proc_exec_$$"
    eval "$command" >"$tmp_out" 2>&1
    local exit_code=$?
    cat "$tmp_out"
    rm -f "$tmp_out"
    return $exit_code
  ]

  # Run a command and return exit code only
  # Usage: @ Process run: "make test"
  rawClassMethod: run: command [
    eval "$command"
  ]

  # Run a command in background, return PID
  # Usage: pid=$(@ Process spawn: "long-running-task")
  rawClassMethod: spawn: command [
    eval "$command" >/dev/null 2>&1 &
    echo $!
  ]

  # Wait for a PID to complete
  # Usage: @ Process waitPid: $pid
  rawClassMethod: waitPid: pid [
    wait "$pid" 2>/dev/null
    echo $?
  ]

  # Check if a PID is running
  # Usage: @ Process isRunningPid: $pid
  rawClassMethod: isRunningPid: pid [
    if kill -0 "$pid" 2>/dev/null; then
      echo "true"
    else
      echo "false"
    fi
  ]

  # Kill a PID
  # Usage: @ Process killPid: $pid
  rawClassMethod: killPid: pid [
    kill -TERM "$pid" 2>/dev/null
  ]

  # Show help
  method: help [
    echo "=== Process Management ==="
    echo ""
    echo "Instance Methods (for managed processes):"
    echo "  proc=\$(@ Process for: \"command\")   - Create process wrapper"
    echo "  @ \$proc run                          - Run blocking, capture output"
    echo "  @ \$proc start                        - Run in background"
    echo "  @ \$proc wait                         - Wait for background completion"
    echo "  @ \$proc isRunning                    - Check if still running"
    echo "  @ \$proc terminate                    - Send SIGTERM"
    echo "  @ \$proc kill                         - Send SIGKILL"
    echo "  @ \$proc output                       - Get stdout"
    echo "  @ \$proc errors                       - Get stderr"
    echo "  @ \$proc exitCode                     - Get exit code"
    echo "  @ \$proc succeeded                    - Check if exit code is 0"
    echo "  @ \$proc info                         - Show process info"
    echo ""
    echo "Class Methods (for quick execution):"
    echo "  @ Process exec: \"cmd\"                - Run, return stdout"
    echo "  @ Process run: \"cmd\"                 - Run, return exit code"
    echo "  @ Process spawn: \"cmd\"               - Run in background, return PID"
    echo "  @ Process waitPid: \$pid              - Wait for PID"
    echo "  @ Process isRunningPid: \$pid         - Check if PID is running"
    echo "  @ Process killPid: \$pid              - Kill PID"
    echo ""
    echo "Examples:"
    echo "  # Quick execution"
    echo "  files=\$(@ Process exec: \"ls -la\")"
    echo ""
    echo "  # Managed process"
    echo "  proc=\$(@ Process for: \"curl -s https://api.example.com\")"
    echo "  @ \$proc run"
    echo "  if @ \$proc succeeded; then"
    echo "    echo \"Response: \$(@ \$proc output)\""
    echo "  fi"
  ]
