#!/usr/bin/env bash
# Generated by Trashtalk Compiler (jq) - DO NOT EDIT
# Source: File.trash
# Generated: 2026-01-12T21:18:03

__File__superclass="Object"
__File__instanceVars="path"
__File__classInstanceVars=""
__File__traits=""
__File__sourceHash="edd1b7f94e980de7797bc0e5792a8db71ef126bc0bcd91676e6ac98fb0486e0d"
__File__primitiveClass="1"

__File__source() {
  cat <<'__TRASHTALK_SOURCE_EOF__'
# File - File system operations
# Provides an interface for reading, writing, and managing files
File subclass: Object
  pragma: primitiveClass
  instanceVars: path

  # Create a File object for a given path
  # Usage: file=$(@ File at: "/tmp/foo.txt")
  classMethod: at: filepath [
    local id=$(_generate_instance_id File)
    _create_instance File "$id"
    @ "$id" setPath "$filepath"
    echo "$id"
  ]

  # Create a temporary file with optional prefix
  # Usage: file=$(@ File temp)
  # Usage: file=$(@ File tempWithPrefix: "st-inspect-")
  classMethod: temp [
    local tmpfile
    tmpfile=$(mktemp)
    local id=$(_generate_instance_id File)
    _create_instance File "$id"
    @ "$id" setPath "$tmpfile"
    echo "$id"
  ]

  classMethod: tempWithPrefix: prefix [
    local tmpfile
    tmpfile=$(mktemp -t "${prefix}XXXXXX")
    local id=$(_generate_instance_id File)
    _create_instance File "$id"
    @ "$id" setPath "$tmpfile"
    echo "$id"
  ]

  # Create a named pipe (FIFO)
  # Usage: fifo=$(@ File mkfifo: "/tmp/myfifo")
  classMethod: mkfifo: filepath [
    mkfifo "$filepath" 2>/dev/null
    local id=$(_generate_instance_id File)
    _create_instance File "$id"
    @ "$id" setPath "$filepath"
    echo "$id"
  ]

  # Get the file path
  method: path [
    _ivar path
  ]

  # Check if file exists
  method: exists [
    [[ -e "$(_ivar path)" ]] && echo "true" || echo "false"
  ]

  # Check if it's a regular file
  method: isFile [
    [[ -f "$(_ivar path)" ]] && echo "true" || echo "false"
  ]

  # Check if it's a directory
  method: isDirectory [
    [[ -d "$(_ivar path)" ]] && echo "true" || echo "false"
  ]

  # Check if it's a FIFO
  method: isFifo [
    [[ -p "$(_ivar path)" ]] && echo "true" || echo "false"
  ]

  # Read entire file contents
  method: read [
    cat "$(_ivar path)" 2>/dev/null
  ]

  # Read file as lines (one per line)
  method: readLines [
    local p=$(_ivar path)
    [[ -f "$p" ]] && cat "$p" || echo ""
  ]

  # Write contents to file (overwrites)
  method: write: contents [
    local p=$(_ivar path)
    printf '%s' "$contents" > "$p"
  ]

  # Write contents with newline
  method: writeLine: contents [
    local p=$(_ivar path)
    printf '%s\n' "$contents" > "$p"
  ]

  # Append contents to file
  method: append: contents [
    local p=$(_ivar path)
    printf '%s' "$contents" >> "$p"
  ]

  # Append contents with newline
  method: appendLine: contents [
    local p=$(_ivar path)
    printf '%s\n' "$contents" >> "$p"
  ]

  # Delete the file
  method: delete [
    local p=$(_ivar path)
    rm -f "$p"
  ]

  # Get file size in bytes
  method: size [
    local p=$(_ivar path)
    if [[ -f "$p" ]]; then
      stat -f%z "$p" 2>/dev/null || stat -c%s "$p" 2>/dev/null || echo "0"
    else
      echo "0"
    fi
  ]

  # Get parent directory
  method: directory [
    local p=$(_ivar path)
    dirname "$p"
  ]

  # Get basename (filename without directory)
  method: basename [
    local p=$(_ivar path)
    basename "$p"
  ]

  # Get file extension
  method: extension [
    local p=$(_ivar path)
    local base
    base=$(basename "$p")
    if [[ "$base" == *.* ]]; then
      echo "${base##*.}"
    else
      echo ""
    fi
  ]

  # Get filename without extension
  method: stem [
    local p=$(_ivar path)
    local base
    base=$(basename "$p")
    echo "${base%.*}"
  ]

  # Copy file to destination
  method: copyTo: destPath [
    local p=$(_ivar path)
    cp "$p" "$destPath"
  ]

  # Move/rename file
  method: moveTo: destPath [
    local p=$(_ivar path)
    mv "$p" "$destPath"
    _ivar_set path "$destPath"
  ]

  # Touch file (create empty or update timestamp)
  method: touch [
    local p=$(_ivar path)
    touch "$p"
  ]

  # Get modification time as unix timestamp
  method: modificationTime [
    local p=$(_ivar path)
    if [[ -e "$p" ]]; then
      stat -f%m "$p" 2>/dev/null || stat -c%Y "$p" 2>/dev/null || echo "0"
    else
      echo "0"
    fi
  ]

  # Print file info
  method: info [
    local p=$(_ivar path)
    echo "Path: $p"
    echo "Exists: $(@ "$_RECEIVER" exists)"
    if [[ -e "$p" ]]; then
      echo "Size: $(@ "$_RECEIVER" size) bytes"
      echo "Type: $(file -b "$p" 2>/dev/null || echo "unknown")"
    fi
  ]

  # String representation
  method: printString [
    local p=$(_ivar path)
    echo "<File $p>"
  ]

  # ========================================
  # Class Methods for File Tests
  # ========================================
  # These enable pure DSL code to test files without [[ ]]
  # Usage: (@ File exists: myPath) ifTrue: [ ... ]

  # Test if path exists (file, directory, symlink, etc.)
  classMethod: exists: path [
    [[ -e "$path" ]] && echo "true" || echo "false"
  ]

  # Test if path is a regular file
  classMethod: isFile: path [
    [[ -f "$path" ]] && echo "true" || echo "false"
  ]

  # Test if path is a directory
  classMethod: isDirectory: path [
    [[ -d "$path" ]] && echo "true" || echo "false"
  ]

  # Test if path is a symbolic link
  classMethod: isSymlink: path [
    [[ -L "$path" ]] && echo "true" || echo "false"
  ]

  # Test if path is a named pipe (FIFO)
  classMethod: isFifo: path [
    [[ -p "$path" ]] && echo "true" || echo "false"
  ]

  # Test if path is a socket
  classMethod: isSocket: path [
    [[ -S "$path" ]] && echo "true" || echo "false"
  ]

  # Test if path is a block device
  classMethod: isBlockDevice: path [
    [[ -b "$path" ]] && echo "true" || echo "false"
  ]

  # Test if path is a character device
  classMethod: isCharDevice: path [
    [[ -c "$path" ]] && echo "true" || echo "false"
  ]

  # Test if file is readable
  classMethod: isReadable: path [
    [[ -r "$path" ]] && echo "true" || echo "false"
  ]

  # Test if file is writable
  classMethod: isWritable: path [
    [[ -w "$path" ]] && echo "true" || echo "false"
  ]

  # Test if file is executable
  classMethod: isExecutable: path [
    [[ -x "$path" ]] && echo "true" || echo "false"
  ]

  # Test if file is empty (zero size)
  classMethod: isEmpty: path [
    [[ ! -s "$path" ]] && echo "true" || echo "false"
  ]

  # Test if file is not empty (has content)
  classMethod: notEmpty: path [
    [[ -s "$path" ]] && echo "true" || echo "false"
  ]

  # Test if file1 is newer than file2
  classMethod: isNewer: path1 than: path2 [
    [[ "$path1" -nt "$path2" ]] && echo "true" || echo "false"
  ]

  # Test if file1 is older than file2
  classMethod: isOlder: path1 than: path2 [
    [[ "$path1" -ot "$path2" ]] && echo "true" || echo "false"
  ]

  # Test if two paths refer to the same file (same inode)
  classMethod: isSame: path1 as: path2 [
    [[ "$path1" -ef "$path2" ]] && echo "true" || echo "false"
  ]

  # ========================================
  # Class Methods for Quick Operations
  # ========================================

  # Quick read
  classMethod: read: filepath [
    cat "$filepath" 2>/dev/null
  ]

  # Quick write
  classMethod: write: contents to: filepath [
    printf '%s' "$contents" > "$filepath"
  ]

  # Quick delete
  classMethod: delete: filepath [
    rm -f "$filepath"
  ]

  # Show help
  method: help [
    echo "=== File Operations ==="
    echo ""
    echo "Creating File objects:"
    echo "  file=\$(@ File at: \"/path/to/file\")   - Reference existing/new file"
    echo "  file=\$(@ File temp)                   - Create temp file"
    echo "  file=\$(@ File tempWithPrefix: \"st-\") - Temp with prefix"
    echo "  fifo=\$(@ File mkfifo: \"/tmp/pipe\")   - Create named pipe"
    echo ""
    echo "Reading:"
    echo "  @ \$file read                          - Read entire contents"
    echo "  @ \$file readLines                     - Read as lines"
    echo ""
    echo "Writing:"
    echo "  @ \$file write: \"content\"              - Write (overwrite)"
    echo "  @ \$file writeLine: \"content\"          - Write with newline"
    echo "  @ \$file append: \"more\"                - Append"
    echo "  @ \$file appendLine: \"more\"            - Append with newline"
    echo ""
    echo "Queries:"
    echo "  @ \$file exists                        - Check existence"
    echo "  @ \$file isFile / isDirectory / isFifo - Type checks"
    echo "  @ \$file size                          - Size in bytes"
    echo "  @ \$file path / directory / basename   - Path info"
    echo "  @ \$file extension / stem              - Filename parts"
    echo "  @ \$file modificationTime              - Unix timestamp"
    echo ""
    echo "Operations:"
    echo "  @ \$file delete                        - Remove file"
    echo "  @ \$file copyTo: \"/dest\"               - Copy"
    echo "  @ \$file moveTo: \"/dest\"               - Move/rename"
    echo "  @ \$file touch                         - Create/update timestamp"
    echo ""
    echo "Quick class methods:"
    echo "  @ File read: \"/path\"                  - Read file directly"
    echo "  @ File write: \"x\" to: \"/path\"         - Write directly"
    echo "  @ File exists: \"/path\"                - Check directly"
    echo "  @ File delete: \"/path\"                - Delete directly"
  ]
__TRASHTALK_SOURCE_EOF__
}

__File__path() {
  echo "$(_ivar path)"; return
}

__File__path_() {
  _ivar_set path "$1"
}

__File__getPath() {
  echo "$(_ivar path)"; return
}

__File__setPath_() {
  _ivar_set path "$1"
}

__File__class__at_() {
  local filepath="$1"
    local id=$(_generate_instance_id File)
    _create_instance File "$id"
    @ "$id" setPath "$filepath"
    echo "$id"
}

__File__class__temp() {
    local tmpfile
    tmpfile=$(mktemp)
    local id=$(_generate_instance_id File)
    _create_instance File "$id"
    @ "$id" setPath "$tmpfile"
    echo "$id"
}

__File__class__tempWithPrefix_() {
  local prefix="$1"
    local tmpfile
    tmpfile=$(mktemp -t "${prefix}XXXXXX")
    local id=$(_generate_instance_id File)
    _create_instance File "$id"
    @ "$id" setPath "$tmpfile"
    echo "$id"
}

__File__class__mkfifo_() {
  local filepath="$1"
    mkfifo "$filepath" 2>/dev/null
    local id=$(_generate_instance_id File)
    _create_instance File "$id"
    @ "$id" setPath "$filepath"
    echo "$id"
}

__File__path() {
    _ivar path
}

__File__exists() {
    [[ -e "$(_ivar path)" ]] && echo "true" || echo "false"
}

__File__isFile() {
    [[ -f "$(_ivar path)" ]] && echo "true" || echo "false"
}

__File__isDirectory() {
    [[ -d "$(_ivar path)" ]] && echo "true" || echo "false"
}

__File__isFifo() {
    [[ -p "$(_ivar path)" ]] && echo "true" || echo "false"
}

__File__read() {
    cat "$(_ivar path)" 2>/dev/null
}

__File__readLines() {
    local p=$(_ivar path)
    [[ -f "$p" ]] && cat "$p" || echo ""
}

__File__write_() {
  local contents="$1"
    local p=$(_ivar path)
    printf '%s' "$contents" >"$p"
}

__File__writeLine_() {
  local contents="$1"
    local p=$(_ivar path)
    printf '%s\n' "$contents" >"$p"
}

__File__append_() {
  local contents="$1"
    local p=$(_ivar path)
    printf '%s' "$contents" >>"$p"
}

__File__appendLine_() {
  local contents="$1"
    local p=$(_ivar path)
    printf '%s\n' "$contents" >>"$p"
}

__File__delete() {
    local p=$(_ivar path)
    rm -f "$p"
}

__File__size() {
    local p=$(_ivar path)
    if [[ -f "$p" ]]; then
        stat -f %z "$p" 2>/dev/null || stat -c %s "$p" 2>/dev/null || echo "0"
        else
        echo "0"
    fi
}

__File__directory() {
    local p=$(_ivar path)
    dirname "$p"
}

__File__basename() {
    local p=$(_ivar path)
    basename "$p"
}

__File__extension() {
    local p=$(_ivar path)
    local base
    base=$(basename "$p")
    if [[ "$base" == *.* ]]; then
        echo "${base##*.}"
        else
        echo ""
    fi
}

__File__stem() {
    local p=$(_ivar path)
    local base
    base=$(basename "$p")
    echo "${base%.*}"
}

__File__copyTo_() {
  local destPath="$1"
    local p=$(_ivar path)
    cp "$p" "$destPath"
}

__File__moveTo_() {
  local destPath="$1"
    local p=$(_ivar path)
    mv "$p" "$destPath"
    _ivar_set path "$destPath"
}

__File__touch() {
    local p=$(_ivar path)
    touch "$p"
}

__File__modificationTime() {
    local p=$(_ivar path)
    if [[ -e "$p" ]]; then
        stat -f %m "$p" 2>/dev/null || stat -c %Y "$p" 2>/dev/null || echo "0"
        else
        echo "0"
    fi
}

__File__info() {
    local p=$(_ivar path)
    echo "Path: $p"
    echo "Exists: $(@ "$_RECEIVER" exists)"
    if [[ -e "$p" ]]; then
        echo "Size: $(@ "$_RECEIVER" size) bytes"
        echo "Type: $(file -b "$p" 2>/dev/null || echo "unknown")"
    fi
}

__File__printString() {
    local p=$(_ivar path)
    echo "<File $p>"
}

__File__class__exists_() {
  local path="$1"
    [[ -e "$path" ]] && echo "true" || echo "false"
}

__File__class__isFile_() {
  local path="$1"
    [[ -f "$path" ]] && echo "true" || echo "false"
}

__File__class__isDirectory_() {
  local path="$1"
    [[ -d "$path" ]] && echo "true" || echo "false"
}

__File__class__isSymlink_() {
  local path="$1"
    [[ -L "$path" ]] && echo "true" || echo "false"
}

__File__class__isFifo_() {
  local path="$1"
    [[ -p "$path" ]] && echo "true" || echo "false"
}

__File__class__isSocket_() {
  local path="$1"
    [[ -S "$path" ]] && echo "true" || echo "false"
}

__File__class__isBlockDevice_() {
  local path="$1"
    [[ -b "$path" ]] && echo "true" || echo "false"
}

__File__class__isCharDevice_() {
  local path="$1"
    [[ -c "$path" ]] && echo "true" || echo "false"
}

__File__class__isReadable_() {
  local path="$1"
    [[ -r "$path" ]] && echo "true" || echo "false"
}

__File__class__isWritable_() {
  local path="$1"
    [[ -w "$path" ]] && echo "true" || echo "false"
}

__File__class__isExecutable_() {
  local path="$1"
    [[ -x "$path" ]] && echo "true" || echo "false"
}

__File__class__isEmpty_() {
  local path="$1"
    [[ ! -s "$path" ]] && echo "true" || echo "false"
}

__File__class__notEmpty_() {
  local path="$1"
    [[ -s "$path" ]] && echo "true" || echo "false"
}

__File__class__isNewer_than_() {
  local path1="$1"
  local path2="$2"
    [[ "$path1" -nt "$path2" ]] && echo "true" || echo "false"
}

__File__class__isOlder_than_() {
  local path1="$1"
  local path2="$2"
    [[ "$path1" -ot "$path2" ]] && echo "true" || echo "false"
}

__File__class__isSame_as_() {
  local path1="$1"
  local path2="$2"
    [[ "$path1" -ef "$path2" ]] && echo "true" || echo "false"
}

__File__class__read_() {
  local filepath="$1"
    cat "$filepath" 2>/dev/null
}

__File__class__write_to_() {
  local contents="$1"
  local filepath="$2"
    printf '%s' "$contents" >"$filepath"
}

__File__class__delete_() {
  local filepath="$1"
    rm -f "$filepath"
}

__File__help() {
    echo "=== File Operations ==="
    echo ""
    echo "Creating File objects:"
    echo " file=\$(@ File at: \"/path/to/file\") - Reference existing/new file"
    echo " file=\$(@ File temp) - Create temp file"
    echo " file=\$(@ File tempWithPrefix: \"st-\") - Temp with prefix"
    echo " fifo=\$(@ File mkfifo: \"/tmp/pipe\") - Create named pipe"
    echo ""
    echo "Reading:"
    echo " @ \$file read - Read entire contents"
    echo " @ \$file readLines - Read as lines"
    echo ""
    echo "Writing:"
    echo " @ \$file write: \" content \" - Write (overwrite)"
    echo " @ \$file writeLine: \" content \" - Write with newline"
    echo " @ \$file append: \" more \" - Append"
    echo " @ \$file appendLine: \" more \" - Append with newline"
    echo ""
    echo "Queries:"
    echo " @ \$file exists - Check existence"
    echo " @ \$file isFile / isDirectory / isFifo - Type checks"
    echo " @ \$file size - Size in bytes"
    echo " @ \$file path / directory / basename - Path info"
    echo " @ \$file extension / stem - Filename parts"
    echo " @ \$file modificationTime - Unix timestamp"
    echo ""
    echo "Operations:"
    echo " @ \$file delete - Remove file"
    echo " @ \$file copyTo: \" /dest \" - Copy"
    echo " @ \$file moveTo: \" /dest \" - Move/rename"
    echo " @ \$file touch - Create/update timestamp"
    echo ""
    echo "Quick class methods:"
    echo " @ File read: \" /path \" - Read file directly"
    echo " @ File write: \" x \" to: \" /path \" - Write directly"
    echo " @ File exists: \" /path \" - Check directly"
    echo " @ File delete: \" /path \" - Delete directly"
}
