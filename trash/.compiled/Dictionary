#!/usr/bin/env bash
# Generated by Trashtalk Compiler (jq) - DO NOT EDIT
# Source: Dictionary.trash
# Generated: 2026-01-13T18:55:15

__Dictionary__superclass="Object"
__Dictionary__instanceVars="items:{}"
__Dictionary__classInstanceVars=""
__Dictionary__traits="Debuggable"
__Dictionary__sourceHash="ce501b695d231265295aa7d99021e31a06ec76fdc623159f739e8ba7a692b97f"

__Dictionary__source() {
  cat <<'__TRASHTALK_SOURCE_EOF__'
# Dictionary - Collection object for key-value pairs
Dictionary subclass: Object
  include: Debuggable
  instanceVars: items:'{}'

  # Create a new dictionary
  classMethod: new [
    | id |
    id := @ Runtime generateId: "Dictionary"
    @ Runtime create: "Dictionary" id: id
    ^ id
  ]

  # Accessor for items ivar (raw JSON)
  method: getItems [
    ^ items
  ]

  # Setter for items ivar
  method: setItems: newItems [
    items := newItems
  ]

  # Private helper - get the raw items JSON object
  method: _getItemsObject [
    ^ items
  ]

  # Get value at key
  # Usage: @ dict at: 'name'
  method: at: key [
    ^ items objectAt: key
  ]

  # Set value at key
  # Usage: @ dict at: 'name' put: 'Alice'
  method: at: key put: value [
    items := items objectAt: key put: value
    ^ value
  ]

  # Check if key exists
  # Usage: @ dict includesKey: 'name'
  method: includesKey: key [
    ^ items objectHasKey: key
  ]

  # Remove key-value pair and return old value
  # Usage: @ dict removeAt: 'name'
  method: removeAt: key [
    | oldValue |
    oldValue := items objectAt: key
    items := items objectRemoveKey: key
    ^ oldValue
  ]

  # Get all keys as JSON array
  # Usage: keysArray := @ dict keys  # Returns JSON array like ["key1","key2"]
  method: keys [
    ^ items objectKeys
  ]

  # Get all values as JSON array
  # Usage: valuesArray := @ dict values  # Returns JSON array like ["val1","val2"]
  method: values [
    ^ items objectValues
  ]

  # Get dictionary size (number of keys)
  method: size [
    ^ items objectLength
  ]

  # Check if dictionary is empty
  method: isEmpty [
    ^ items objectIsEmpty
  ]

  # Print dictionary contents
  method: show [
    (items objectIsEmpty) ifTrue: [^ '(empty dictionary)'] ifFalse: [^ items]
  ]

  # Create dictionary from pairs
  # Usage: @ dict withPairs: 'name:Alice age:30'
  method: withPairs: pairs [
    pragma: primitive
    local pairs="$1"
    local items pair key value
    items="{}"
    for pair in $pairs; do
      key="${pair%%:*}"
      value="${pair#*:}"
      items=$(echo "$items" | jq -c --arg k "$key" --arg v "$value" '.[$k] = $v')
    done
    _ivar_set items "$items"
    echo "$_RECEIVER"
  ]

  # Iterate over each key-value pair, calling block with key and value
  # Usage: @ dict do: [:key :value | @ Console print: key , ' = ' , value]
  method: do: aBlock [
    pragma: bashOnly
    | keysArray i len key value |
    keysArray := items objectKeys.
    len := keysArray arrayLength.
    i := 0.
    [i < len] whileTrue: [
      key := keysArray arrayAt: i.
      value := items objectAt: key.
      @ aBlock valueWith: key and: value.
      i := i + 1
    ]
  ]

  # Iterate over keys only
  # Usage: @ dict keysDo: [:key | @ Console print: 'Key: ' , key]
  method: keysDo: aBlock [
    pragma: bashOnly
    | keysArray i len key |
    keysArray := items objectKeys.
    len := keysArray arrayLength.
    i := 0.
    [i < len] whileTrue: [
      key := keysArray arrayAt: i.
      @ aBlock valueWith: key.
      i := i + 1
    ]
  ]

  # Iterate over values only
  # Usage: @ dict valuesDo: [:value | @ Console print: 'Value: ' , value]
  method: valuesDo: aBlock [
    pragma: bashOnly
    | valuesArray i len value |
    valuesArray := items objectValues.
    len := valuesArray arrayLength.
    i := 0.
    [i < len] whileTrue: [
      value := valuesArray arrayAt: i.
      @ aBlock valueWith: value.
      i := i + 1
    ]
  ]

  # Map values through a block, returning new dictionary with same keys
  # Usage: doubled := @ dict collect: [:v | v * 2]
  method: collect: aBlock [
    pragma: bashOnly
    | keysArray i len key value result newDict |
    keysArray := items objectKeys.
    len := keysArray arrayLength.
    newDict := @ Dictionary new.
    i := 0.
    [i < len] whileTrue: [
      key := keysArray arrayAt: i.
      value := items objectAt: key.
      result := @ aBlock valueWith: value.
      @ newDict at: key put: result.
      i := i + 1
    ].
    ^ newDict
  ]

  # Select key-value pairs where block returns true
  # Usage: evens := @ dict select: [:k :v | (v % 2) == 0]
  method: select: aBlock [
    pragma: bashOnly
    | keysArray i len key value result newDict |
    keysArray := items objectKeys.
    len := keysArray arrayLength.
    newDict := @ Dictionary new.
    i := 0.
    [i < len] whileTrue: [
      key := keysArray arrayAt: i.
      value := items objectAt: key.
      result := @ aBlock valueWith: key and: value.
      result notEmpty ifTrue: [
        @ newDict at: key put: value
      ].
      i := i + 1
    ].
    ^ newDict
  ]

  # Merge another dictionary into this one (modifies self)
  # Usage: @ dict merge: otherDict
  method: merge: other [
    pragma: bashOnly
    | otherKeys i len key value |
    otherKeys := (@ other getItems) objectKeys.
    len := otherKeys arrayLength.
    i := 0.
    [i < len] whileTrue: [
      key := otherKeys arrayAt: i.
      value := @ other at: key.
      @ self at: key put: value.
      i := i + 1
    ].
    ^ self
  ]

  # Get value at key, or default if missing
  # Usage: @ dict at: 'missing' ifAbsent: 'default'
  # pragma: bashOnly (Go codegen bug with boolean conditionals)
  method: at: key ifAbsent: default [
    pragma: bashOnly
    (items objectHasKey: key) ifTrue: [^ items objectAt: key] ifFalse: [^ default]
  ]

  # Clear all entries
  method: clear [
    @ self setItems: '{}'
    ^ self
  ]

  # Return as JSON string (compact format)
  method: asJson [
    ^ items
  ]

  # Create dictionary from JSON string
  # pragma: bashOnly (Go codegen issue with class methods returning objects)
  classMethod: fromJson: json [
    pragma: bashOnly
    | dict |
    dict := (@ Dictionary new)
    @ dict setItems: json
    ^ dict
  ]
__TRASHTALK_SOURCE_EOF__
}

__Dictionary__items() {
  echo "$(_ivar items)"; return
}

__Dictionary__items_() {
  _ivar_set items "$1"
}

__Dictionary__getItems() {
  echo "$(_ivar items)"; return
}

__Dictionary__setItems_() {
  _ivar_set items "$1"
}

__Dictionary__class__new() {
  local id
  id="$(@ Runtime generateId: "Dictionary")"
  @ Runtime create: "Dictionary" id: "$id"
  echo "$id"; return
}

__Dictionary__getItems() {
  echo "$(_ivar items)"; return
}

__Dictionary__setItems_() {
  local newItems="$1"
  _ivar_set items "$newItems"
}

__Dictionary___getItemsObject() {
  echo "$(_ivar items)"; return
}

__Dictionary__at_() {
  local key="$1"
  echo "$(echo "$(_ivar items)" | jq -r --arg k "$key" '.[$k] // empty')"; return
}

__Dictionary__at_put_() {
  local key="$1"
  local value="$2"
  _ivar_set items "$(echo "$(_ivar items)" | jq -c --arg k "$key" --arg v "$value" '.[$k] = $v')"
  echo "$value"; return
}

__Dictionary__includesKey_() {
  local key="$1"
  echo "$(echo "$(_ivar items)" | jq --arg k "$key" 'has($k)')"; return
}

__Dictionary__removeAt_() {
  local key="$1"
  local oldValue
  oldValue="$(echo "$(_ivar items)" | jq -r --arg k "$key" '.[$k] // empty')"
  _ivar_set items "$(echo "$(_ivar items)" | jq -c --arg k "$key" 'del(.[$k])')"
  echo "$oldValue"; return
}

__Dictionary__keys() {
  echo "$(echo "$(_ivar items)" | jq -c 'keys')"; return
}

__Dictionary__values() {
  echo "$(echo "$(_ivar items)" | jq -c '[.[]]')"; return
}

__Dictionary__size() {
  echo "$(echo "$(_ivar items)" | jq 'length')"; return
}

__Dictionary__isEmpty() {
  echo "$(echo "$(_ivar items)" | jq 'length == 0')"; return
}

__Dictionary__show() {
  if [[ "$(echo "$(_ivar items)" | jq 'length == 0')" == "true" ]]; then echo "(empty dictionary)"; return; else echo "$(_ivar items)"; return; fi
}

__Dictionary__withPairs_() {
  local pairs="$1"
    local pairs="$1"
    local items pair key value
    items="{}"
    for pair in $pairs; do
        key="${pair%%:*}"
        value="${pair#*:}"
        items=$(echo "$items" | jq -c --arg k "$key" --arg v "$value" '.[$k] = $v')
    done
    _ivar_set items "$items"
    echo "$_RECEIVER"
}

declare -g __Dictionary__do___bashOnly=1
__Dictionary__do_() {
  local aBlock="$1"
  local keysArray i len key value
  keysArray="$(echo "$(_ivar items)" | jq -c 'keys')"
  len="$(echo "$keysArray" | jq 'length')"
  i="0"
  while (( $i < $len )); do key="$(echo "$keysArray" | jq -r --argjson i "$i" '.[$i] // empty')"; value="$(echo "$(_ivar items)" | jq -r --arg k "$key" '.[$k] // empty')"; @ "$aBlock" valueWith: "$key" and: "$value"; (( i = ($i + 1) )); done
}

declare -g __Dictionary__keysDo___bashOnly=1
__Dictionary__keysDo_() {
  local aBlock="$1"
  local keysArray i len key
  keysArray="$(echo "$(_ivar items)" | jq -c 'keys')"
  len="$(echo "$keysArray" | jq 'length')"
  i="0"
  while (( $i < $len )); do key="$(echo "$keysArray" | jq -r --argjson i "$i" '.[$i] // empty')"; @ "$aBlock" valueWith: "$key"; (( i = ($i + 1) )); done
}

declare -g __Dictionary__valuesDo___bashOnly=1
__Dictionary__valuesDo_() {
  local aBlock="$1"
  local valuesArray i len value
  valuesArray="$(echo "$(_ivar items)" | jq -c '[.[]]')"
  len="$(echo "$valuesArray" | jq 'length')"
  i="0"
  while (( $i < $len )); do value="$(echo "$valuesArray" | jq -r --argjson i "$i" '.[$i] // empty')"; @ "$aBlock" valueWith: "$value"; (( i = ($i + 1) )); done
}

declare -g __Dictionary__collect___bashOnly=1
__Dictionary__collect_() {
  local aBlock="$1"
  local keysArray i len key value result newDict
  keysArray="$(echo "$(_ivar items)" | jq -c 'keys')"
  len="$(echo "$keysArray" | jq 'length')"
  newDict="$(@ Dictionary new)"
  i="0"
  while (( $i < $len )); do key="$(echo "$keysArray" | jq -r --argjson i "$i" '.[$i] // empty')"; value="$(echo "$(_ivar items)" | jq -r --arg k "$key" '.[$k] // empty')"; result="$(@ "$aBlock" valueWith: "$value")"; @ "$newDict" at: "$key" put: "$result"; (( i = ($i + 1) )); done
  echo "$newDict"; return
}

declare -g __Dictionary__select___bashOnly=1
__Dictionary__select_() {
  local aBlock="$1"
  local keysArray i len key value result newDict
  keysArray="$(echo "$(_ivar items)" | jq -c 'keys')"
  len="$(echo "$keysArray" | jq 'length')"
  newDict="$(@ Dictionary new)"
  i="0"
  while (( $i < $len )); do key="$(echo "$keysArray" | jq -r --argjson i "$i" '.[$i] // empty')"; value="$(echo "$(_ivar items)" | jq -r --arg k "$key" '.[$k] // empty')"; result="$(@ "$aBlock" valueWith: "$key" and: "$value")"; if [[ -n "$result" ]]; then @ "$newDict" at: "$key" put: "$value"; fi; (( i = ($i + 1) )); done
  echo "$newDict"; return
}

declare -g __Dictionary__merge___bashOnly=1
__Dictionary__merge_() {
  local other="$1"
  local otherKeys i len key value
  otherKeys="$(echo @ "$other" getItems | jq -c 'keys')"
  len="$(echo "$otherKeys" | jq 'length')"
  i="0"
  while (( $i < $len )); do key="$(echo "$otherKeys" | jq -r --argjson i "$i" '.[$i] // empty')"; value="$(@ "$other" at: "$key")"; @ "$_RECEIVER" at: "$key" put: "$value"; (( i = ($i + 1) )); done
  echo ""$_RECEIVER""; return
}

declare -g __Dictionary__at_ifAbsent___bashOnly=1
__Dictionary__at_ifAbsent_() {
  local key="$1"
  local default="$2"
  if [[ "$(echo "$(_ivar items)" | jq --arg k "$key" 'has($k)')" == "true" ]]; then echo "$(echo "$(_ivar items)" | jq -r --arg k "$key" '.[$k] // empty')"; return; else echo "$default"; return; fi
}

__Dictionary__clear() {
  @ "$_RECEIVER" setItems: '{}'
  echo ""$_RECEIVER""; return
}

__Dictionary__asJson() {
  echo "$(_ivar items)"; return
}

declare -g __Dictionary__class__fromJson___bashOnly=1
__Dictionary__class__fromJson_() {
  local json="$1"
  local dict
  dict="$(@ Dictionary new)"
  @ "$dict" setItems: "$json"
  echo "$dict"; return
}
