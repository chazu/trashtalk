#!/usr/bin/env bash
# Generated by Trashtalk Compiler (procyon) - DO NOT EDIT
# Source: FIFO.trash
# Generated: 2026-01-12T11:15:30

__FIFO__superclass="Object"
__FIFO__instanceVars="path: keeperPid: writerPid: readerPid:"
__FIFO__classInstanceVars=""
__FIFO__traits=""
__FIFO__sourceHash="8084f393d2db64698d7eb0e9ce2ce6722967b96434b4a7194ace131efceccf83"

__FIFO__source() {
  cat <<'__TRASHTALK_SOURCE_EOF__'
# FIFO - Named pipe abstraction
# Encapsulates creation, access, and cleanup of POSIX named pipes (FIFOs)
FIFO subclass: Object
  pragma: primitiveClass
  instanceVars: path:'' keeperPid:'' writerPid:'' readerPid:''

  # Create a FIFO instance for a given path (does not create the pipe yet)
  primitiveClassMethod: at: aPath [
    local id
    id=$(_generate_instance_id FIFO)
    _create_instance FIFO "$id"
    @ "$id" _setPath: "$aPath"
    echo "$id"
  ]

  # Create the named pipe on disk
  primitiveMethod: create [
    local p
    p="$(_ivar path)"
    rm -f "$p" 2>/dev/null
    mkfifo "$p"
  ]

  # Check if the pipe exists on disk
  primitiveMethod: exists [
    local p
    p="$(_ivar path)"
    if [[ -p "$p" ]]; then
      echo "true"
    else
      echo "false"
    fi
  ]

  # Remove the pipe from disk
  primitiveMethod: remove [
    local p
    p="$(_ivar path)"
    rm -f "$p" 2>/dev/null
  ]

  # Open the FIFO read-write to prevent blocking
  # Spawns a background process that holds the FIFO open
  primitiveMethod: open [
    local p keeper_pid pidfile
    p="$(_ivar path)"
    pidfile="/tmp/fifo_keeper_${_INSTANCE}.pid"

    # Spawn a detached process that ignores SIGINT (Ctrl+C immune)
    # The keeper opens the FIFO read-write and sleeps forever
    # trap '' INT makes it ignore interrupt signals
    /bin/bash -c 'trap "" INT; echo $$ > "$2"; exec 3<>"$1"; while true; do sleep 86400; done' _ "$p" "$pidfile" </dev/null >/dev/null 2>&1 &

    sleep 0.1
    keeper_pid=$(cat "$pidfile" 2>/dev/null)
    rm -f "$pidfile"

    _ivar_set keeperPid "$keeper_pid"
  ]

  # Close the FIFO (kills the keeper process)
  primitiveMethod: close [
    local keeper_pid
    keeper_pid="$(_ivar keeperPid)"
    if [[ -n "$keeper_pid" ]]; then
      kill "$keeper_pid" 2>/dev/null
      _ivar_set keeperPid ""
    fi
  ]

  # Write a line to the FIFO
  primitiveMethod: writeLine: text [
    local p text="$1"
    p="$(_ivar path)"
    echo "$text" > "$p"
  ]

  # Read a line from the FIFO
  primitiveMethod: readLine [
    local p line
    p="$(_ivar path)"
    if read -r line < "$p"; then
      echo "$line"
    fi
  ]

  # Read a line with timeout (seconds)
  primitiveMethod: readLineTimeout: seconds [
    local p line seconds="$1"
    p="$(_ivar path)"
    if read -t "$seconds" -r line < "$p" 2>/dev/null; then
      echo "$line"
    fi
  ]

  # Read lines continuously, calling handler for each
  # The current line is available in $__FIFO_LINE
  # Exits when the writer closes the FIFO
  primitiveMethod: readLinesDo: handler [
    local p
    p="$(_ivar path)"

    while IFS='' read -r __FIFO_LINE; do
      eval "$1"
    done < "$p"
  ]

  # =========================================================================
  # Async Writer API
  # =========================================================================

  # Start a command that writes to this FIFO in the background
  # The command's stdout is redirected to the FIFO
  primitiveMethod: startWriter: cmd [
    local p cmd="$1" pidfile writer_pid
    p="$(_ivar path)"
    pidfile="/tmp/fifo_writer_${_INSTANCE}.pid"

    # Spawn the command writing to the FIFO
    # Uses trap to ignore SIGINT so Ctrl+C doesn't kill it
    # Opens FIFO read-write (<>) to avoid blocking on open
    /bin/bash -c 'trap "" INT; echo $$ > "$2"; exec 1<>"$3"; eval "$1"' _ "$cmd" "$pidfile" "$p" </dev/null 2>&1 &

    sleep 0.1
    writer_pid=$(cat "$pidfile" 2>/dev/null)
    rm -f "$pidfile"

    _ivar_set writerPid "$writer_pid"
  ]

  # Stop the writer process
  primitiveMethod: stopWriter [
    local writer_pid
    writer_pid="$(_ivar writerPid)"
    if [[ -n "$writer_pid" ]]; then
      kill "$writer_pid" 2>/dev/null
      kill -9 "$writer_pid" 2>/dev/null
      _ivar_set writerPid ""
    fi
  ]

  # =========================================================================
  # Async Reader API
  # =========================================================================

  # Start a background reader that calls handler for each line
  # The current line is available in $__FIFO_LINE
  primitiveMethod: startReader: handler [
    local p handler="$1" pidfile reader_pid
    p="$(_ivar path)"
    pidfile="/tmp/fifo_reader_${_INSTANCE}.pid"

    # Spawn a reader loop in the background
    # Uses trap to ignore SIGINT so Ctrl+C doesn't kill it
    # Opens FIFO read-write (<>) to avoid blocking on open
    /bin/bash -c 'trap "" INT; echo $$ > "$2"; exec 0<>"$3"; while IFS= read -r __FIFO_LINE; do eval "$1"; done' _ "$handler" "$pidfile" "$p" </dev/null 2>&1 &

    sleep 0.1
    reader_pid=$(cat "$pidfile" 2>/dev/null)
    rm -f "$pidfile"

    _ivar_set readerPid "$reader_pid"
  ]

  # Stop the reader process
  primitiveMethod: stopReader [
    local reader_pid
    reader_pid="$(_ivar readerPid)"
    if [[ -n "$reader_pid" ]]; then
      kill "$reader_pid" 2>/dev/null
      kill -9 "$reader_pid" 2>/dev/null
      _ivar_set readerPid ""
    fi
  ]

  # Private setter
  primitiveMethod: _setPath: aPath [
    _ivar_set path "$1"
  ]
__TRASHTALK_SOURCE_EOF__
}

__FIFO__path() {
  echo "$(_ivar path)"; return
}

__FIFO__path_() {
  _ivar_set path "$1"
}

__FIFO__keeperPid() {
  echo "$(_ivar keeperPid)"; return
}

__FIFO__keeperPid_() {
  _ivar_set keeperPid "$1"
}

__FIFO__writerPid() {
  echo "$(_ivar writerPid)"; return
}

__FIFO__writerPid_() {
  _ivar_set writerPid "$1"
}

__FIFO__readerPid() {
  echo "$(_ivar readerPid)"; return
}

__FIFO__readerPid_() {
  _ivar_set readerPid "$1"
}

__FIFO__class__at_() {
  local aPath="$1"
  local id
  id=$(_generate_instance_id FIFO)
  _create_instance FIFO "$id"
  @ "$id" _setPath: "$aPath"
  echo "$id"
}

__FIFO__create() {
  local p
  p="$(_ivar path)"
  rm -f "$p" 2 > /dev/null
  mkfifo "$p"
}

__FIFO__exists() {
  local p
  p="$(_ivar path)"
  if [[ -p "$p" ]] ; then
  echo "true"
  else
  echo "false"
  fi
}

__FIFO__remove() {
  local p
  p="$(_ivar path)"
  rm -f "$p" 2 > /dev/null
}

__FIFO__open() {
  local p keeper_pid pidfile
  p="$(_ivar path)"
  pidfile="/tmp/fifo_keeper_${_INSTANCE}.pid"
  # Spawn a detached process that ignores SIGINT (Ctrl+C immune)
  # The keeper opens the FIFO read-write and sleeps forever
  # trap '' INT makes it ignore interrupt signals
  /bin/bash -c 'trap "" INT; echo $$ > "$2"; exec 3<>"$1"; while true; do sleep 86400; done' _ "$p" "$pidfile" </dev/null > /dev/null 2 >& 1 &
  sleep 0.1
  keeper_pid=$(cat "$pidfile" 2>/dev/null)
  rm -f "$pidfile"
  _ivar_set keeperPid "$keeper_pid"
}

__FIFO__close() {
  local keeper_pid
  keeper_pid="$(_ivar keeperPid)"
  if [[ -n "$keeper_pid" ]] ; then
  kill "$keeper_pid" 2 > /dev/null
  _ivar_set keeperPid ""
  fi
}

__FIFO__writeLine_() {
  local text="$1"
  local p text="$1"
  p="$(_ivar path)"
  echo "$text" > "$p"
}

__FIFO__readLine() {
  local p line
  p="$(_ivar path)"
  if read -r line < "$p" ; then
  echo "$line"
  fi
}

__FIFO__readLineTimeout_() {
  local seconds="$1"
  local p line seconds="$1"
  p="$(_ivar path)"
  if read -t "$seconds" -r line < "$p" 2 > /dev/null ; then
  echo "$line"
  fi
}

__FIFO__readLinesDo_() {
  local handler="$1"
  local p
  p="$(_ivar path)"
  while IFS='' read -r __FIFO_LINE ; do
  eval "$1"
  done < "$p"
}

__FIFO__startWriter_() {
  local cmd="$1"
  local p cmd="$1" pidfile writer_pid
  p="$(_ivar path)"
  pidfile="/tmp/fifo_writer_${_INSTANCE}.pid"
  # Spawn the command writing to the FIFO
  # Uses trap to ignore SIGINT so Ctrl+C doesn't kill it
  # Opens FIFO read-write (<>) to avoid blocking on open
  /bin/bash -c 'trap "" INT; echo $$ > "$2"; exec 1<>"$3"; eval "$1"' _ "$cmd" "$pidfile" "$p" </dev/null 2 >& 1 &
  sleep 0.1
  writer_pid=$(cat "$pidfile" 2>/dev/null)
  rm -f "$pidfile"
  _ivar_set writerPid "$writer_pid"
}

__FIFO__stopWriter() {
  local writer_pid
  writer_pid="$(_ivar writerPid)"
  if [[ -n "$writer_pid" ]] ; then
  kill "$writer_pid" 2 > /dev/null
  kill -9 "$writer_pid" 2 > /dev/null
  _ivar_set writerPid ""
  fi
}

__FIFO__startReader_() {
  local handler="$1"
  local p handler="$1" pidfile reader_pid
  p="$(_ivar path)"
  pidfile="/tmp/fifo_reader_${_INSTANCE}.pid"
  # Spawn a reader loop in the background
  # Uses trap to ignore SIGINT so Ctrl+C doesn't kill it
  # Opens FIFO read-write (<>) to avoid blocking on open
  /bin/bash -c 'trap "" INT; echo $$ > "$2"; exec 0<>"$3"; while IFS= read -r __FIFO_LINE; do eval "$1"; done' _ "$handler" "$pidfile" "$p" </dev/null 2 >& 1 &
  sleep 0.1
  reader_pid=$(cat "$pidfile" 2>/dev/null)
  rm -f "$pidfile"
  _ivar_set readerPid "$reader_pid"
}

__FIFO__stopReader() {
  local reader_pid
  reader_pid="$(_ivar readerPid)"
  if [[ -n "$reader_pid" ]] ; then
  kill "$reader_pid" 2 > /dev/null
  kill -9 "$reader_pid" 2 > /dev/null
  _ivar_set readerPid ""
  fi
}

__FIFO___setPath_() {
  local aPath="$1"
  _ivar_set path "$1"
}

