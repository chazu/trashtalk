#!/usr/bin/env bash
# Generated by Trashtalk Compiler (procyon) - DO NOT EDIT
# Source: GrpcClient.trash
# Generated: 2026-01-09T20:22:09

__GrpcClient__superclass="Object"
__GrpcClient__instanceVars="address: useReflection:yes protoFile: poolConnections:no usePlaintext:yes"
__GrpcClient__classInstanceVars=""
__GrpcClient__traits=""
__GrpcClient__sourceHash="4cefb45b15f30111adcd3ff9c8b2488cfd2f4fc53030b9e84a4373f52bfe77c1"

__GrpcClient__source() {
  cat <<'__TRASHTALK_SOURCE_EOF__'
# GrpcClient - gRPC client with dual Bash/Procyon implementation
#
# Bash implementation uses grpcurl for unary calls.
# Streaming methods are marked procyonOnly and require native Procyon runtime.
#
# Usage:
#   client := @ GrpcClient connectTo: 'localhost:50051'.
#   response := @ $client call: 'myservice.Echo' with: '{"message":"hello"}'.
#
# With proto file:
#   client := @ GrpcClient connectTo: 'localhost:50051' withProto: 'service.proto'.

# Note: Using string 'yes'/'no' instead of boolean true/false because
# the _ivar function uses jq's // operator which treats false as empty.
GrpcClient subclass: Object
  instanceVars: address:'' useReflection:'yes' protoFile:'' poolConnections:'no' usePlaintext:'yes'

  # ==========================================================================
  # Class methods - Factory constructors
  # ==========================================================================

  rawClassMethod: connectTo: addr [
    local client
    client=$(@ GrpcClient new)
    @ "$client" _setAddress: "$addr"
    echo "$client"
  ]

  rawClassMethod: connectTo: addr withProto: proto [
    local client
    client=$(@ GrpcClient connectTo: "$addr")
    @ "$client" _setProtoFile: "$proto"
    @ "$client" _setUseReflection: 'no'
    echo "$client"
  ]

  # ==========================================================================
  # Unary RPC - Works in both Bash and Procyon
  # procyonNative: Bash uses grpcurl, Procyon uses native gRPC
  # ==========================================================================

  rawMethod: call: method with: jsonPayload [
    pragma: direct
    local addr proto result plaintext_flag
    addr="$(_ivar address)"
    proto="$(_ivar protoFile)"

    # Build plaintext flag
    if [[ "$(_ivar usePlaintext)" == "yes" ]]; then
      plaintext_flag="-plaintext"
    else
      plaintext_flag=""
    fi

    # Call grpcurl
    if [[ -n "$proto" ]]; then
      result=$(grpcurl $plaintext_flag -d "$2" -proto "$proto" "$addr" "$1" 2>&1)
    else
      # Reflection mode (server must have reflection enabled)
      result=$(grpcurl $plaintext_flag -d "$2" "$addr" "$1" 2>&1)
    fi

    if [[ $? -eq 0 ]]; then
      echo "$result"
    else
      _throw "GrpcError" "$result"
      return 1
    fi
  ]

  # Unary call with empty payload
  rawMethod: call: method [
    pragma: direct
    local addr proto result plaintext_flag
    addr="$(_ivar address)"
    proto="$(_ivar protoFile)"

    if [[ "$(_ivar usePlaintext)" == "yes" ]]; then
      plaintext_flag="-plaintext"
    else
      plaintext_flag=""
    fi

    if [[ -n "$proto" ]]; then
      result=$(grpcurl $plaintext_flag -d '{}' -proto "$proto" "$addr" "$1" 2>&1)
    else
      result=$(grpcurl $plaintext_flag -d '{}' "$addr" "$1" 2>&1)
    fi

    if [[ $? -eq 0 ]]; then
      echo "$result"
    else
      _throw "GrpcError" "$result"
      return 1
    fi
  ]

  # ==========================================================================
  # Server Streaming RPC - Procyon only
  # ==========================================================================

  rawMethod: serverStream: method with: payload handler: block [
    echo "Server streaming requires native Procyon runtime"
  ]

  # ==========================================================================
  # Client Streaming RPC - Procyon only
  # ==========================================================================

  rawMethod: clientStream: method handler: block [
    echo "Client streaming requires native Procyon runtime"
  ]

  # ==========================================================================
  # Bidirectional Streaming RPC - Procyon only
  # ==========================================================================

  rawMethod: bidiStream: method handler: block [
    echo "Bidirectional streaming requires native Procyon runtime"
  ]

  # ==========================================================================
  # List available services (reflection mode)
  # ==========================================================================

  rawMethod: listServices [
    pragma: direct
    local addr result plaintext_flag
    addr="$(_ivar address)"

    if [[ "$(_ivar usePlaintext)" == "yes" ]]; then
      plaintext_flag="-plaintext"
    else
      plaintext_flag=""
    fi

    result=$(grpcurl $plaintext_flag "$addr" list 2>&1)
    if [[ $? -eq 0 ]]; then
      echo "$result"
    else
      _throw "GrpcError" "$result"
      return 1
    fi
  ]

  # List methods for a service
  rawMethod: listMethods: service [
    pragma: direct
    local addr result plaintext_flag
    addr="$(_ivar address)"

    if [[ "$(_ivar usePlaintext)" == "yes" ]]; then
      plaintext_flag="-plaintext"
    else
      plaintext_flag=""
    fi

    result=$(grpcurl $plaintext_flag "$addr" list "$1" 2>&1)
    if [[ $? -eq 0 ]]; then
      echo "$result"
    else
      _throw "GrpcError" "$result"
      return 1
    fi
  ]

  # Describe a service or method
  rawMethod: describe: target [
    pragma: direct
    local addr result plaintext_flag
    addr="$(_ivar address)"

    if [[ "$(_ivar usePlaintext)" == "yes" ]]; then
      plaintext_flag="-plaintext"
    else
      plaintext_flag=""
    fi

    result=$(grpcurl $plaintext_flag "$addr" describe "$1" 2>&1)
    if [[ $? -eq 0 ]]; then
      echo "$result"
    else
      _throw "GrpcError" "$result"
      return 1
    fi
  ]

  # ==========================================================================
  # Configuration methods
  # ==========================================================================

  rawMethod: enablePooling [
    _ivar_set poolConnections 'yes'
  ]

  rawMethod: disablePooling [
    _ivar_set poolConnections 'no'
  ]

  rawMethod: enableTLS [
    _ivar_set usePlaintext 'no'
  ]

  rawMethod: enablePlaintext [
    _ivar_set usePlaintext 'yes'
  ]

  rawMethod: address [
    echo "$(_ivar address)"
  ]

  rawMethod: isUsingReflection [
    echo "$(_ivar useReflection)"
  ]

  rawMethod: isPoolingEnabled [
    echo "$(_ivar poolConnections)"
  ]

  # ==========================================================================
  # Private setters
  # ==========================================================================

  rawMethod: _setAddress: a [
    _ivar_set address "$1"
  ]

  rawMethod: _setProtoFile: p [
    _ivar_set protoFile "$1"
  ]

  rawMethod: _setUseReflection: r [
    _ivar_set useReflection "$1"
  ]
__TRASHTALK_SOURCE_EOF__
}

__GrpcClient__address() {
  echo "$(_ivar address)"; return
}

__GrpcClient__address_() {
  _ivar_set address "$1"
}

__GrpcClient__useReflection() {
  echo "$(_ivar useReflection)"; return
}

__GrpcClient__useReflection_() {
  _ivar_set useReflection "$1"
}

__GrpcClient__protoFile() {
  echo "$(_ivar protoFile)"; return
}

__GrpcClient__protoFile_() {
  _ivar_set protoFile "$1"
}

__GrpcClient__poolConnections() {
  echo "$(_ivar poolConnections)"; return
}

__GrpcClient__poolConnections_() {
  _ivar_set poolConnections "$1"
}

__GrpcClient__usePlaintext() {
  echo "$(_ivar usePlaintext)"; return
}

__GrpcClient__usePlaintext_() {
  _ivar_set usePlaintext "$1"
}

__GrpcClient__class__connectTo_() {
  local addr="$1"
  local client
  client=$(@ GrpcClient new)
  @ "$client" _setAddress: "$addr"
  echo "$client"
}

__GrpcClient__class__connectTo_withProto_() {
  local addr="$1"
  local proto="$2"
  local client
  client=$(@ GrpcClient connectTo: "$addr")
  @ "$client" _setProtoFile: "$proto"
  @ "$client" _setUseReflection: 'no'
  echo "$client"
}

__GrpcClient__call_with_() {
  local method="$1"
  local jsonPayload="$2"
  local addr proto result plaintext_flag
  addr="$(_ivar address)"
  proto="$(_ivar protoFile)"
  # Build plaintext flag
  if [[ "$(_ivar usePlaintext)" == "yes" ]] ; then
  plaintext_flag="-plaintext"
  else
  plaintext_flag=""
  fi
  # Call grpcurl
  if [[ -n "$proto" ]] ; then
  result=$(grpcurl $plaintext_flag -d "$2" -proto "$proto" "$addr" "$1" 2>&1)
  else
  # Reflection mode (server must have reflection enabled)
  result=$(grpcurl $plaintext_flag -d "$2" "$addr" "$1" 2>&1)
  fi
  if [[ $? -eq 0 ]] ; then
  echo "$result"
  else
  _throw "GrpcError" "$result"
  return 1
  fi
}

__GrpcClient__call_() {
  local method="$1"
  local addr proto result plaintext_flag
  addr="$(_ivar address)"
  proto="$(_ivar protoFile)"
  if [[ "$(_ivar usePlaintext)" == "yes" ]] ; then
  plaintext_flag="-plaintext"
  else
  plaintext_flag=""
  fi
  if [[ -n "$proto" ]] ; then
  result=$(grpcurl $plaintext_flag -d '{}' -proto "$proto" "$addr" "$1" 2>&1)
  else
  result=$(grpcurl $plaintext_flag -d '{}' "$addr" "$1" 2>&1)
  fi
  if [[ $? -eq 0 ]] ; then
  echo "$result"
  else
  _throw "GrpcError" "$result"
  return 1
  fi
}

__GrpcClient__serverStream_with_handler_() {
  local method="$1"
  local payload="$2"
  local block="$3"
  echo "Server streaming requires native Procyon runtime"
}

__GrpcClient__clientStream_handler_() {
  local method="$1"
  local block="$2"
  echo "Client streaming requires native Procyon runtime"
}

__GrpcClient__bidiStream_handler_() {
  local method="$1"
  local block="$2"
  echo "Bidirectional streaming requires native Procyon runtime"
}

__GrpcClient__listServices() {
  local addr result plaintext_flag
  addr="$(_ivar address)"
  if [[ "$(_ivar usePlaintext)" == "yes" ]] ; then
  plaintext_flag="-plaintext"
  else
  plaintext_flag=""
  fi
  result=$(grpcurl $plaintext_flag "$addr" list 2>&1)
  if [[ $? -eq 0 ]] ; then
  echo "$result"
  else
  _throw "GrpcError" "$result"
  return 1
  fi
}

__GrpcClient__listMethods_() {
  local service="$1"
  local addr result plaintext_flag
  addr="$(_ivar address)"
  if [[ "$(_ivar usePlaintext)" == "yes" ]] ; then
  plaintext_flag="-plaintext"
  else
  plaintext_flag=""
  fi
  result=$(grpcurl $plaintext_flag "$addr" list "$1" 2>&1)
  if [[ $? -eq 0 ]] ; then
  echo "$result"
  else
  _throw "GrpcError" "$result"
  return 1
  fi
}

__GrpcClient__describe_() {
  local target="$1"
  local addr result plaintext_flag
  addr="$(_ivar address)"
  if [[ "$(_ivar usePlaintext)" == "yes" ]] ; then
  plaintext_flag="-plaintext"
  else
  plaintext_flag=""
  fi
  result=$(grpcurl $plaintext_flag "$addr" describe "$1" 2>&1)
  if [[ $? -eq 0 ]] ; then
  echo "$result"
  else
  _throw "GrpcError" "$result"
  return 1
  fi
}

__GrpcClient__enablePooling() {
  _ivar_set poolConnections 'yes'
}

__GrpcClient__disablePooling() {
  _ivar_set poolConnections 'no'
}

__GrpcClient__enableTLS() {
  _ivar_set usePlaintext 'no'
}

__GrpcClient__enablePlaintext() {
  _ivar_set usePlaintext 'yes'
}

__GrpcClient__address() {
  echo "$(_ivar address)"
}

__GrpcClient__isUsingReflection() {
  echo "$(_ivar useReflection)"
}

__GrpcClient__isPoolingEnabled() {
  echo "$(_ivar poolConnections)"
}

__GrpcClient___setAddress_() {
  local a="$1"
  _ivar_set address "$1"
}

__GrpcClient___setProtoFile_() {
  local p="$1"
  _ivar_set protoFile "$1"
}

__GrpcClient___setUseReflection_() {
  local r="$1"
  _ivar_set useReflection "$1"
}

