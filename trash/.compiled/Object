#!/usr/bin/env bash
# Generated by Trashtalk Compiler (jq) - DO NOT EDIT
# Source: Object.trash
# Generated: 2026-01-12T21:18:51

__Object__superclass="nil"
__Object__instanceVars=""
__Object__classInstanceVars=""
__Object__traits=""
__Object__sourceHash="b809f6bf4364df253b3691a1633db5b94131f3a32b276bc47b03e526f8d01197"
__Object__primitiveClass="1"

__Object__source() {
  cat <<'__TRASHTALK_SOURCE_EOF__'
# Object - Base class for all Trashtalk objects
Object subclass: nil
  pragma: primitiveClass

  # Create a new instance of this class
  # Subclasses inherit this - no need to define your own unless custom init needed
  classMethod: new [
    local id
    # Use $_CLASS directly - it's already set by dispatcher to the calling class
    # Don't use @ Runtime class - that makes a nested send which changes $_CLASS
    id=$(@ Runtime generateId: "$_CLASS")
    @ Runtime create: "$_CLASS" id: "$id"
    echo "$id"
  ]

  # Return a canonical string representation of this object
  # Format: <ClassName instanceId>
  method: printString [
    echo "<${_CLASS} ${_INSTANCE}>"
  ]

  # Return the class name of this object
  method: class [
    echo "$_CLASS"
  ]

  # Return the instance ID of this object
  method: id [
    echo "$_INSTANCE"
  ]

  # Check if this object is an instance of a given class
  method: isKindOf: className [
    local current="$1"
    local my_class="$_CLASS"
    current="$my_class"
    while [[ -n "$current" ]]; do
      if [[ "$current" == "$1" ]]; then
        echo "true"
        return 0
      fi
      current=$(@ Runtime superclassOf: "$current")
    done
    echo "false"
  ]

  # Check if this object conforms to a protocol
  method: conformsTo: protocolName [
    local class="$_CLASS"
    _conforms_to "$class" "$1"
  ]

  # Delete this object from memory
  method: delete [
    local instance
    instance=$(@ Runtime instance)
    @ Runtime delete: "$instance"
  ]

  # Return a detailed inspection of this object
  # Shows class name, instance ID, and all instance variables with values
  method: inspect [
    local data class instance
    class="$_CLASS"
    instance="$_INSTANCE"
    data=$(@ Runtime dataFor: "$_RECEIVER")

    echo "a $class"
    echo "  id: $instance"

    if [[ -n "$data" && "$data" != "{}" ]]; then
      echo "$data" | jq -r 'to_entries | .[] | "  \(.key): \(.value)"'
    else
      @ Trash methodsFor: "$_RECEIVER"
    fi
  ]

  # Write inspection output to a file
  method: inspectTo: filepath [
    local output filepath="$1"
    output=$(@ "$_RECEIVER" inspect)
    @ File write: "$output" to: "$filepath"
    echo "$filepath"
  ]

  # Return this object's data as JSON
  method: asJson [
    @ Runtime dataFor: "$_RECEIVER"
  ]

  # Edit this class's source file and recompile if changed
  classMethod: edit [
    local class source_file trait_source file_to_edit editor
    class="$_CLASS"
    source_file="$TRASHDIR/${class}.trash"
    trait_source="$TRASHDIR/traits/${class}.trash"
    file_to_edit=""

    # Find source file
    if [[ -f "$source_file" ]]; then
      file_to_edit="$source_file"
    elif [[ -f "$trait_source" ]]; then
      file_to_edit="$trait_source"
    else
      @ Console error: "Error: No source file found for $class"
      return 1
    fi

    # Get modification time before editing
    local before_mtime after_mtime
    before_mtime=$(@ File modificationTime: "$file_to_edit")

    # Open in editor
    editor=$(@ Env editor)
    "$editor" "$file_to_edit" </dev/tty >/dev/tty

    # Check if modified and recompile
    after_mtime=$(@ File modificationTime: "$file_to_edit")

    if [[ "$before_mtime" != "$after_mtime" ]]; then
      @ Console print: "File modified, compiling..."
      @ Trash compileAndReload: "$class"
    else
      @ Console print: "No changes detected"
    fi
  ]
__TRASHTALK_SOURCE_EOF__
}

__Object__class__new() {
    local id
    # Use $_CLASS directly - it's already set by dispatcher to the calling class
    # Don't use @ Runtime class - that makes a nested send which changes $_CLASS
    id=$(@ Runtime generateId: "$_CLASS")
    @ Runtime create: "$_CLASS" id: "$id"
    echo "$id"
}

__Object__printString() {
    echo "<${_CLASS} ${_INSTANCE}>"
}

__Object__class() {
    echo "$_CLASS"
}

__Object__id() {
    echo "$_INSTANCE"
}

__Object__isKindOf_() {
  local className="$1"
    local current="$1"
    local my_class="$_CLASS"
    current="$my_class"
    while [[ -n "$current" ]]; do
        if [[ "$current" == "$1" ]]; then
            echo "true"
            return 0
        fi
        current=$(@ Runtime superclassOf: "$current")
    done
    echo "false"
}

__Object__conformsTo_() {
  local protocolName="$1"
    local class="$_CLASS"
    _conforms_to "$class" "$1"
}

__Object__delete() {
    local instance
    instance=$(@ Runtime instance)
    @ Runtime delete: "$instance"
}

__Object__inspect() {
    local data class instance
    class="$_CLASS"
    instance="$_INSTANCE"
    data=$(@ Runtime dataFor: "$_RECEIVER")

    echo "a $class"
    echo " id: $instance"

    if [[ -n "$data" && "$data" != "{}" ]]; then
        echo "$data" | jq -r 'to_entries | .[] | " \(.key): \(.value)"'
        else
        @ Trash methodsFor: "$_RECEIVER"
    fi
}

__Object__inspectTo_() {
  local filepath="$1"
    local output filepath="$1"
    output=$(@ "$_RECEIVER" inspect)
    @ File write: "$output" to: "$filepath"
    echo "$filepath"
}

__Object__asJson() {
    @ Runtime dataFor: "$_RECEIVER"
}

__Object__class__edit() {
    local class source_file trait_source file_to_edit editor
    class="$_CLASS"
    source_file="$TRASHDIR/${class}.trash"
    trait_source="$TRASHDIR/traits/${class}.trash"
    file_to_edit=""

    # Find source file
    if [[ -f "$source_file" ]]; then
    file_to_edit="$source_file"
        elif [[ -f "$trait_source" ]]; then
        file_to_edit="$trait_source"
            else
            @ Console error: "Error: No source file found for $class"
            return 1
        fi

        # Get modification time before editing
        local before_mtime after_mtime
        before_mtime=$(@ File modificationTime: "$file_to_edit")

        # Open in editor
        editor=$(@ Env editor)
        "$editor" "$file_to_edit" </dev/tty >/dev/tty

        # Check if modified and recompile
        after_mtime=$(@ File modificationTime: "$file_to_edit")

        if [[ "$before_mtime" != "$after_mtime" ]]; then
            @ Console print: "File modified, compiling..."
            @ Trash compileAndReload: "$class"
            else
            @ Console print: "No changes detected"
        fi
}
