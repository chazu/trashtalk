#!/usr/bin/env bash
# Generated by Trashtalk Compiler (jq) - DO NOT EDIT
# Source: Object.trash
# Generated: 2026-01-12T00:41:19

__Object__superclass="nil"
__Object__instanceVars=""
__Object__classInstanceVars=""
__Object__traits=""
__Object__sourceHash="c13fc7a445076891d8e864079502af410a8756e9d8c7400efd8d8b0a32176532"

__Object__source() {
  cat <<'__TRASHTALK_SOURCE_EOF__'
Object subclass: nil

  # Create a new instance of this class
  # Subclasses inherit this - no need to define your own unless custom init needed
  rawClassMethod: new [
    local id
    # Use $_CLASS directly - it's already set by dispatcher to the calling class
    # Don't use @ Runtime class - that makes a nested send which changes $_CLASS
    id=$(@ Runtime generateId: "$_CLASS")
    @ Runtime create: "$_CLASS" id: "$id"
    echo "$id"
  ]

  # Return a canonical string representation of this object
  # Format: <ClassName instanceId>
  rawMethod: printString [
    echo "<${_CLASS} ${_INSTANCE}>"
  ]

  # Return the class name of this object
  rawMethod: class [
    echo "$_CLASS"
  ]

  # Return the instance ID of this object
  rawMethod: id [
    echo "$_INSTANCE"
  ]

  # Check if this object is an instance of a given class
  rawMethod: isKindOf: className [
    local current
    current=$(@ Runtime class)
    while [[ -n "$current" ]]; do
      if [[ "$current" == "$1" ]]; then
        echo "true"
        return 0
      fi
      current=$(@ Runtime superclassOf: "$current")
    done
    echo "false"
  ]

  # Check if this object conforms to a protocol
  rawMethod: conformsTo: protocolName [
    local class
    class=$(@ Runtime class)
    _conforms_to "$class" "$1"
  ]

  # Delete this object from memory
  rawMethod: delete [
    local instance
    instance=$(@ Runtime instance)
    @ Runtime delete: "$instance"
  ]

  # Return a detailed inspection of this object
  # Shows class name, instance ID, and all instance variables with values
  rawMethod: inspect [
    local data class instance
    class="$_CLASS"
    instance="$_INSTANCE"
    data=$(@ Runtime dataFor: "$_RECEIVER")

    echo "a $class"
    echo "  id: $instance"

    if [[ -n "$data" && "$data" != "{}" ]]; then
      echo "$data" | jq -r 'to_entries | .[] | "  \(.key): \(.value)"'
    else
      @ Trash methodsFor "$_RECEIVER"
    fi
  ]

  # Write inspection output to a file
  # Usage: @ $obj inspectTo: "/tmp/inspect.txt"
  rawMethod: inspectTo: filepath [
    @ Shell exec: "@ \"$_RECEIVER\" inspect" outputTo: "$1"
    echo "$1"
  ]

  # Return this object's data as JSON
  method: asJson [
    ^ @ Runtime dataFor: self
  ]

  # Edit this class's source file and recompile if changed
  # Usage: @ Counter edit
  rawClassMethod: edit [
    local class source_file trait_source file_to_edit editor
    class=$(@ Runtime class)
    source_file="$TRASHDIR/${class}.trash"
    trait_source="$TRASHDIR/traits/${class}.trash"
    file_to_edit=""

    # Find source file
    if [[ -f "$source_file" ]]; then
      file_to_edit="$source_file"
    elif [[ -f "$trait_source" ]]; then
      file_to_edit="$trait_source"
    else
      @ Console error: "Error: No source file found for $class"
      return 1
    fi

    # Get modification time before editing
    local before_mtime after_mtime
    before_mtime=$(@ File modificationTime: "$file_to_edit")

    # Open in editor
    editor=$(@ Env editor)
    "$editor" "$file_to_edit" </dev/tty >/dev/tty

    # Check if modified and recompile
    after_mtime=$(@ File modificationTime: "$file_to_edit")

    if [[ "$before_mtime" != "$after_mtime" ]]; then
      @ Console print: "File modified, compiling..."
      @ Trash compileAndReload "$class"
    else
      @ Console print: "No changes detected"
    fi
  ]
__TRASHTALK_SOURCE_EOF__
}

__Object__class__new() {
    local id
    # Use $_CLASS directly - it's already set by dispatcher to the calling class
    # Don't use @ Runtime class - that makes a nested send which changes $_CLASS
    id=$(@ Runtime generateId: "$_CLASS")
    @ Runtime create: "$_CLASS" id: "$id"
    echo "$id"
}

__Object__printString() {
    echo "<${_CLASS} ${_INSTANCE}>"
}

__Object__class() {
    echo "$_CLASS"
}

__Object__id() {
    echo "$_INSTANCE"
}

__Object__isKindOf_() {
  local className="$1"
    local current
    current=$(@ Runtime class)
    while [[ -n "$current" ]]; do
        if [[ "$current" == "$1" ]]; then
            echo "true"
            return 0
        fi
        current=$(@ Runtime superclassOf: "$current")
    done
    echo "false"
}

__Object__conformsTo_() {
  local protocolName="$1"
    local class
    class=$(@ Runtime class)
    _conforms_to "$class" "$1"
}

__Object__delete() {
    local instance
    instance=$(@ Runtime instance)
    @ Runtime delete: "$instance"
}

__Object__inspect() {
    local data class instance
    class="$_CLASS"
    instance="$_INSTANCE"
    data=$(@ Runtime dataFor: "$_RECEIVER")

    echo "a $class"
    echo " id: $instance"

    if [[ -n "$data" && "$data" != "{}" ]]; then
        echo "$data" | jq -r 'to_entries | .[] | " \(.key): \(.value)"'
        else
        @ Trash methodsFor "$_RECEIVER"
    fi
}

__Object__inspectTo_() {
  local filepath="$1"
    @ Shell exec: "@ \" $_RECEIVER \" inspect" outputTo: "$1"
    echo "$1"
}

__Object__asJson() {
  @ Runtime dataFor: "$_RECEIVER"; return
}

__Object__class__edit() {
    local class source_file trait_source file_to_edit editor
    class=$(@ Runtime class)
    source_file="$TRASHDIR/${class}.trash"
    trait_source="$TRASHDIR/traits/${class}.trash"
    file_to_edit=""

    # Find source file
    if [[ -f "$source_file" ]]; then
    file_to_edit="$source_file"
        elif [[ -f "$trait_source" ]]; then
        file_to_edit="$trait_source"
            else
            @ Console error: "Error: No source file found for $class"
            return 1
        fi

        # Get modification time before editing
        local before_mtime after_mtime
        before_mtime=$(@ File modificationTime: "$file_to_edit")

        # Open in editor
        editor=$(@ Env editor)
        "$editor" "$file_to_edit" </dev/tty >/dev/tty

        # Check if modified and recompile
        after_mtime=$(@ File modificationTime: "$file_to_edit")

        if [[ "$before_mtime" != "$after_mtime" ]]; then
            @ Console print: "File modified, compiling..."
            @ Trash compileAndReload "$class"
            else
            @ Console print: "No changes detected"
        fi
}
