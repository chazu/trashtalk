#!/usr/bin/env bash
# Generated by Trashtalk Compiler (procyon) - DO NOT EDIT
# Source: Object.trash
# Generated: 2026-01-12T15:06:13

__Object__superclass="nil"
__Object__instanceVars=""
__Object__classInstanceVars=""
__Object__traits=""
__Object__sourceHash="c38fcdc8b6b2567fb5e174d8a47659ab1041536bb6f100ec764f22f1154baa10"

__Object__source() {
  cat <<'__TRASHTALK_SOURCE_EOF__'
# Object - Base class for all Trashtalk objects
Object subclass: nil

  # Create a new instance of this class
  # Subclasses inherit this - no need to define your own unless custom init needed
  primitiveClassMethod: new [
    local id
    # Use $_CLASS directly - it's already set by dispatcher to the calling class
    # Don't use @ Runtime class - that makes a nested send which changes $_CLASS
    id=$(@ Runtime generateId: "$_CLASS")
    @ Runtime create: "$_CLASS" id: "$id"
    echo "$id"
  ]

  # Return a canonical string representation of this object
  # Format: <ClassName instanceId>
  primitiveMethod: printString [
    echo "<${_CLASS} ${_INSTANCE}>"
  ]

  # Return the class name of this object
  primitiveMethod: class [
    echo "$_CLASS"
  ]

  # Return the instance ID of this object
  primitiveMethod: id [
    echo "$_INSTANCE"
  ]

  # Check if this object is an instance of a given class
  primitiveMethod: isKindOf: className [
    local current="$1"
    local my_class="$_CLASS"
    current="$my_class"
    while [[ -n "$current" ]]; do
      if [[ "$current" == "$1" ]]; then
        echo "true"
        return 0
      fi
      current=$(@ Runtime superclassOf: "$current")
    done
    echo "false"
  ]

  # Check if this object conforms to a protocol
  primitiveMethod: conformsTo: protocolName [
    local class="$_CLASS"
    _conforms_to "$class" "$1"
  ]

  # Delete this object from memory
  method: delete [
    | instance |
    instance := @ Runtime instance
    @ Runtime delete: instance
  ]

  # Return a detailed inspection of this object
  # Shows class name, instance ID, and all instance variables with values
  primitiveMethod: inspect [
    local data class instance
    class="$_CLASS"
    instance="$_INSTANCE"
    data=$(@ Runtime dataFor: "$_RECEIVER")

    echo "a $class"
    echo "  id: $instance"

    if [[ -n "$data" && "$data" != "{}" ]]; then
      echo "$data" | jq -r 'to_entries | .[] | "  \(.key): \(.value)"'
    else
      @ Trash methodsFor: "$_RECEIVER"
    fi
  ]

  # Write inspection output to a file
  method: inspectTo: filepath [
    | output |
    output := @ self inspect
    @ File write: output to: filepath
    ^ filepath
  ]

  # Return this object's data as JSON
  method: asJson [
    ^ @ Runtime dataFor: self
  ]

  # Edit this class's source file and recompile if changed
  primitiveClassMethod: edit [
    local class source_file trait_source file_to_edit editor
    class="$_CLASS"
    source_file="$TRASHDIR/${class}.trash"
    trait_source="$TRASHDIR/traits/${class}.trash"
    file_to_edit=""

    # Find source file
    if [[ -f "$source_file" ]]; then
      file_to_edit="$source_file"
    elif [[ -f "$trait_source" ]]; then
      file_to_edit="$trait_source"
    else
      @ Console error: "Error: No source file found for $class"
      return 1
    fi

    # Get modification time before editing
    local before_mtime after_mtime
    before_mtime=$(@ File modificationTime: "$file_to_edit")

    # Open in editor
    editor=$(@ Env editor)
    "$editor" "$file_to_edit" </dev/tty >/dev/tty

    # Check if modified and recompile
    after_mtime=$(@ File modificationTime: "$file_to_edit")

    if [[ "$before_mtime" != "$after_mtime" ]]; then
      @ Console print: "File modified, compiling..."
      @ Trash compileAndReload: "$class"
    else
      @ Console print: "No changes detected"
    fi
  ]
__TRASHTALK_SOURCE_EOF__
}

__Object__class__new() {
  local id
  # Use $_CLASS directly - it's already set by dispatcher to the calling class
  # Don't use @ Runtime class - that makes a nested send which changes $_CLASS
  id=$(@ Runtime generateId: "$_CLASS")
  @ Runtime create: "$_CLASS" id: "$id"
  echo "$id"
}

__Object__printString() {
  echo "<${_CLASS} ${_INSTANCE}>"
}

__Object__class() {
  echo "$_CLASS"
}

__Object__id() {
  echo "$_INSTANCE"
}

__Object__isKindOf_() {
  local className="$1"
  local current="$1"
  local my_class="$_CLASS"
  current="$my_class"
  while [[ -n "$current" ]] ; do
  if [[ "$current" == "$1" ]] ; then
  echo "true"
  return 0
  fi
  current=$(@ Runtime superclassOf: "$current")
  done
  echo "false"
}

__Object__conformsTo_() {
  local protocolName="$1"
  local class="$_CLASS"
  _conforms_to "$class" "$1"
}

__Object__delete() {
  local instance
  instance="$(@ Runtime instance)"
  $(@ Runtime delete_ $instance)
}

__Object__inspect() {
  local data class instance
  class="$_CLASS"
  instance="$_INSTANCE"
  data=$(@ Runtime dataFor: "$_RECEIVER")
  echo "a $class"
  echo "  id: $instance"
  if [[ -n "$data" && "$data" != "{}" ]] ; then
  echo "$data" | jq -r 'to_entries | .[] | "  \(.key): \(.value)"'
  else
  @ Trash methodsFor: "$_RECEIVER"
  fi
}

__Object__inspectTo_() {
  local filepath="$1"
  local output
  output="$(@ "$_RECEIVER" inspect)"
  $(@ File write_to_ $output $filepath)
  echo "$filepath"; return
}

__Object__asJson() {
  echo "$(@ Runtime dataFor_ $_RECEIVER)"; return
}

__Object__class__edit() {
  local class source_file trait_source file_to_edit editor
  class="$_CLASS"
  source_file="$TRASHDIR/${class}.trash"
  trait_source="$TRASHDIR/traits/${class}.trash"
  file_to_edit=""
  # Find source file
  if [[ -f "$source_file" ]] ; then
  file_to_edit="$source_file"
  elif [[ -f "$trait_source" ]] ; then
  file_to_edit="$trait_source"
  else
  @ Console error: "Error: No source file found for $class"
  return 1
  fi
  # Get modification time before editing
  local before_mtime after_mtime
  before_mtime=$(@ File modificationTime: "$file_to_edit")
  # Open in editor
  editor=$(@ Env editor)
  "$editor" "$file_to_edit" </dev/tty > /dev/tty
  # Check if modified and recompile
  after_mtime=$(@ File modificationTime: "$file_to_edit")
  if [[ "$before_mtime" != "$after_mtime" ]] ; then
  @ Console print: "File modified, compiling..."
  @ Trash compileAndReload: "$class"
  else
  @ Console print: "No changes detected"
  fi
}

