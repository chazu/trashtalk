#!/usr/bin/env bash
# Generated by Trashtalk Compiler (procyon) - DO NOT EDIT
# Source: Object.trash
# Generated: 2026-01-09T14:29:12

__Object__superclass="nil"
__Object__instanceVars=""
__Object__classInstanceVars=""
__Object__traits=""
__Object__sourceHash="400fab96dae1b9295969a3371875638ce2d0991a9ddf28f5171ec9a473f289b0"

__Object__source() {
  cat <<'__TRASHTALK_SOURCE_EOF__'
Object subclass: nil

  # Create a new instance of this class
  # Subclasses inherit this - no need to define your own unless custom init needed
  rawClassMethod: new [
    local id
    id=$(_generate_instance_id "$_CLASS")
    _create_instance "$_CLASS" "$id"
    echo "$id"
  ]

  # Return a canonical string representation of this object
  # Format: <ClassName instanceId>
  rawMethod: printString [
    echo "<${_CLASS} ${_INSTANCE}>"
  ]

  # Return the class name of this object
  rawMethod: class [
    echo "$_CLASS"
  ]

  # Return the instance ID of this object
  rawMethod: id [
    echo "$_INSTANCE"
  ]

  # Check if this object is an instance of a given class
  rawMethod: isKindOf: className [
    local current="$_CLASS"
    while [[ -n "$current" ]]; do
      if [[ "$current" == "$className" ]]; then
        echo "true"
        return 0
      fi
      local super_var="__${current}__superclass"
      current="${!super_var:-}"
    done
    echo "false"
  ]

  # Check if this object conforms to a protocol
  rawMethod: conformsTo: protocolName [
    _conforms_to "$_CLASS" "$protocolName"
  ]

  # Delete this object from memory
  rawMethod: delete [
    _delete_instance "$_INSTANCE"
  ]

  # Return a detailed inspection of this object
  # Shows class name, instance ID, and all instance variables with values
  rawMethod: inspect [
    local data
    data=$(_env_get "$_RECEIVER")

    echo "a $_CLASS"
    echo "  id: $_INSTANCE"

    if [[ -n "$data" && "$data" != "{}" ]]; then
      echo "$data" | jq -r 'to_entries | .[] | "  \(.key): \(.value)"'
    else
      @ Trash methodsFor $_RECEIVER
    fi
  ]

  # Write inspection output to a file
  # Usage: @ $obj inspectTo: "/tmp/inspect.txt"
  rawMethod: inspectTo: filepath [
    @ "$_RECEIVER" inspect > "$filepath"
    echo "$filepath"
  ]

  # Return this object's data as JSON
  rawMethod: asJson [
    _env_get "$_RECEIVER"
  ]

  # Edit this class's source file and recompile if changed
  # Usage: @ Counter edit
  rawClassMethod: edit [
    local source_file="$TRASHDIR/${_CLASS}.trash"
    local trait_source="$TRASHDIR/traits/${_CLASS}.trash"
    local file_to_edit=""

    # Find source file
    if [[ -f "$source_file" ]]; then
      file_to_edit="$source_file"
    elif [[ -f "$trait_source" ]]; then
      file_to_edit="$trait_source"
    else
      echo "Error: No source file found for $_CLASS"
      return 1
    fi

    # Get modification time before editing
    local before_mtime after_mtime
    before_mtime=$(stat -f "%m" "$file_to_edit" 2>/dev/null || stat -c "%Y" "$file_to_edit" 2>/dev/null)

    # Open in editor
    ${EDITOR:-vi} "$file_to_edit" </dev/tty >/dev/tty

    # Check if modified and recompile
    after_mtime=$(stat -f "%m" "$file_to_edit" 2>/dev/null || stat -c "%Y" "$file_to_edit" 2>/dev/null)

    if [[ "$before_mtime" != "$after_mtime" ]]; then
      echo "File modified, compiling..."
      @ Trash compileAndReload "$_CLASS"
    else
      echo "No changes detected"
    fi
  ]

__TRASHTALK_SOURCE_EOF__
}

__Object__class__new() {
  local id
  id=$(_generate_instance_id "$_CLASS")
  _create_instance "$_CLASS" "$id"
  echo "$id"
}

__Object__printString() {
  echo "<${_CLASS} ${_INSTANCE}>"
}

__Object__class() {
  echo "$_CLASS"
}

__Object__id() {
  echo "$_INSTANCE"
}

__Object__isKindOf_() {
  local current="$_CLASS"
  while [[ -n "$current" ]] ; do
  if [[ "$current" == "$className" ]] ; then
  echo "true"
  return 0
  fi
  local super_var="__${current}__superclass"
  current="${!super_var:-}"
  done
  echo "false"
}

__Object__conformsTo_() {
  _conforms_to "$_CLASS" "$protocolName"
}

__Object__delete() {
  _delete_instance "$_INSTANCE"
}

__Object__inspect() {
  local data
  data=$(_env_get "$_RECEIVER")
  echo "a $_CLASS"
  echo "  id: $_INSTANCE"
  if [[ -n "$data" && "$data" != "{}" ]] ; then
  echo "$data" | jq -r 'to_entries | .[] | "  \(.key): \(.value)"'
  else
  @ Trash methodsFor $_RECEIVER
  fi
}

__Object__inspectTo_() {
  @ "$_RECEIVER" inspect > "$filepath"
  echo "$filepath"
}

__Object__asJson() {
  _env_get "$_RECEIVER"
}

__Object__class__edit() {
  local source_file="$TRASHDIR/${_CLASS}.trash"
  local trait_source="$TRASHDIR/traits/${_CLASS}.trash"
  local file_to_edit=""
  # Find source file
  if [[ -f "$source_file" ]] ; then
  file_to_edit="$source_file"
  elif [[ -f "$trait_source" ]] ; then
  file_to_edit="$trait_source"
  else
  echo "Error: No source file found for $_CLASS"
  return 1
  fi
  # Get modification time before editing
  local before_mtime after_mtime
  before_mtime=$(stat -f "%m" "$file_to_edit" 2>/dev/null || stat -c "%Y" "$file_to_edit" 2>/dev/null)
  # Open in editor
  ${EDITOR:-vi} "$file_to_edit" </dev/tty > /dev/tty
  # Check if modified and recompile
  after_mtime=$(stat -f "%m" "$file_to_edit" 2>/dev/null || stat -c "%Y" "$file_to_edit" 2>/dev/null)
  if [[ "$before_mtime" != "$after_mtime" ]] ; then
  echo "File modified, compiling..."
  @ Trash compileAndReload "$_CLASS"
  else
  echo "No changes detected"
  fi
}

