#!/usr/bin/env bash
# Generated by Trashtalk Compiler (jq) - DO NOT EDIT
# Source: NativeDaemon.trash
# Generated: 2026-01-12T21:18:47

__NativeDaemon__superclass="Object"
__NativeDaemon__instanceVars="pluginDir: status: debug: socketPath:/tmp/trashtalk-daemon.sock"
__NativeDaemon__classInstanceVars=""
__NativeDaemon__traits=""
__NativeDaemon__sourceHash="c5afeca25dd67746c1ea2195eff3408dc728e842abc0eb11860d66e423da1134"

__NativeDaemon__source() {
  cat <<'__TRASHTALK_SOURCE_EOF__'
# NativeDaemon - Single daemon for native class dispatch via c-shared plugins
#
# The daemon loads .dylib/.so plugins on demand, routing all native class
# calls through a single trashtalk-daemon process using Unix sockets.
#
# Usage:
#   daemon := @ NativeDaemon instance.
#   result := @ daemon dispatch: 'Counter' instance: '' selector: 'new' args: '[]'.
#
# The daemon is a singleton - only one instance per Trashtalk session.
# Plugins are loaded lazily on first use of each class.
# Daemon auto-exits after 5 minutes of inactivity.

NativeDaemon subclass: Object
  instanceVars: pluginDir:'' status:'' debug:'' socketPath:'/tmp/trashtalk-daemon.sock'

  # Singleton instance stored in global
  # Usage: daemon := @ NativeDaemon instance
  classMethod: instance [
    pragma: primitive
    if [[ -z "${_NATIVE_DAEMON:-}" ]]; then
      _NATIVE_DAEMON=$(_generate_instance_id NativeDaemon)
      _create_instance NativeDaemon "$_NATIVE_DAEMON"
      # Use direct ivar manipulation to avoid private method checks
      # when called from _native_daemon_dispatch
      local json
      json=$(_env_get "$_NATIVE_DAEMON")
      json=$(echo "$json" | jq -c '.status = "ready" | .pluginDir = "'"$TRASHDIR/.compiled"'"')
      _env_set "$_NATIVE_DAEMON" "$json"
    fi
    echo "$_NATIVE_DAEMON"
  ]

  # Check if daemon is available (singleton exists)
  classMethod: isAvailable [
    pragma: primitive
    if [[ -n "${_NATIVE_DAEMON:-}" ]]; then
      echo "true"
      return 0
    fi
    echo "false"
    return 1
  ]

  # Reset the singleton (stops the daemon)
  classMethod: reset [
    pragma: primitive
    if [[ -n "${_NATIVE_DAEMON:-}" ]]; then
      @ "$_NATIVE_DAEMON" stop 2>/dev/null || true
    fi
    _NATIVE_DAEMON=""
  ]

  # Ensure the daemon process is running
  # Starts it in background if not already running
  method: _ensureDaemon [
    pragma: primitive
    local socketPath pidFile pid pluginDir daemonCmd socketOpt pluginOpt debugOpt

    socketPath="$(_ivar socketPath)"
    pidFile="${socketPath}.pid"
    pluginDir="$(_ivar pluginDir)"
    # Use variables to avoid compiler breaking hyphenated option names
    daemonCmd="trashtalk-daemon"
    socketOpt="--socket"
    pluginOpt="--plugin-dir"
    debugOpt="--debug"

    # Check if daemon is already running
    if [[ -S "$socketPath" ]] && [[ -f "$pidFile" ]]; then
      pid=$(cat "$pidFile" 2>/dev/null)
      if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
        # Daemon is running
        return 0
      fi
    fi

    # Clean up stale files
    rm -f "$socketPath" "$pidFile" 2>/dev/null

    # Start daemon in background (disown to prevent subshell from waiting)
    if [[ "$(_ivar debug)" == "true" ]]; then
      "$daemonCmd" "$socketOpt" "$socketPath" "$pluginOpt" "$pluginDir" "$debugOpt" </dev/null >/dev/null 2>&1 &
      disown
    else
      "$daemonCmd" "$socketOpt" "$socketPath" "$pluginOpt" "$pluginDir" </dev/null >/dev/null 2>&1 &
      disown
    fi

    # Wait for socket to appear (max 2 seconds)
    local i
    for i in 1 2 3 4 5 6 7 8 9 10; do
      if [[ -S "$socketPath" ]]; then
        _ivar_set status "running"
        return 0
      fi
      sleep 0.2
    done

    echo "[NativeDaemon] Error: daemon failed to start" >&2
    return 1
  ]

  # Dispatch a method call to a native class via Unix socket
  # Returns: result string, or empty if fallback needed
  # Exit code: 0 = success, 1 = error, 200 = no native plugin (fallback to Bash)
  method: dispatch: className instance: instanceId selector: selector args: argsJson [
    pragma: primitive
    local className="$1" instanceId="$2" selector="$3" argsJson="$4"
    local socketPath request response exitCode result instanceJson nativeSelector
    local _daemon_profile_start _daemon_profile_end _daemon_elapsed _daemon_route="plugin"

    # Profile: record start time
    if [[ -n "${TRASH_PROFILE:-}" ]]; then
      _daemon_profile_start=$(_profile_time_ms)
    fi

    # Ensure daemon is running (call function directly to avoid send() overhead)
    __NativeDaemon___ensureDaemon
    if [[ $? -ne 0 ]]; then
      return 200
    fi

    socketPath="$(_ivar socketPath)"

    # Default args to empty array
    if [[ -z "$argsJson" ]]; then
      argsJson="[]"
    fi

    # Normalize selector: convert colons to underscores for native format
    nativeSelector="${selector//:/_}"

    # For instance methods, load instance data
    instanceJson=""
    if [[ -n "$instanceId" ]]; then
      instanceJson=$(_env_get "$instanceId" 2>/dev/null)
      # Native expects string values, so convert numbers to strings
      if [[ -n "$instanceJson" ]]; then
        instanceJson=$(echo "$instanceJson" | jq -c 'walk(if type == "number" then tostring else . end)')
      fi
    fi

    # Build JSON request for trashtalk-daemon
    # Format: {"class":"Counter","instance":"...","selector":"getValue","args":[]}
    if [[ -n "$instanceJson" ]]; then
      request=$(jq -cn --arg c "$className" --arg i "$instanceJson" --arg s "$nativeSelector" --argjson a "$argsJson" \
        '{class: $c, instance: $i, selector: $s, args: $a}')
    else
      request=$(jq -cn --arg c "$className" --arg i "" --arg s "$nativeSelector" --argjson a "$argsJson" \
        '{class: $c, instance: $i, selector: $s, args: $a}')
    fi

    if [[ "$(_ivar debug)" == "true" ]]; then
      echo "[NativeDaemon] Request: $request" >&2
    fi

    # Send request to daemon via Unix socket
    # nc -U connects to Unix socket, -w 30 sets 30 second timeout
    response=$(echo "$request" | nc -U "$socketPath" 2>/dev/null)

    if [[ -z "$response" ]]; then
      echo "[NativeDaemon] Error: no response from daemon" >&2
      return 1
    fi

    if [[ "$(_ivar debug)" == "true" ]]; then
      echo "[NativeDaemon] Response: $response" >&2
    fi

    # Parse response - daemon returns {"instance":"...","result":"...","exit_code":0}
    exitCode=$(echo "$response" | jq -r '.exit_code // 1')

    if [[ "$exitCode" == "200" ]]; then
      # No native plugin for this class, fallback to Bash
      if [[ -n "${TRASH_PROFILE:-}" ]]; then
        _daemon_profile_end=$(_profile_time_ms)
        _daemon_elapsed=$(( _daemon_profile_end - _daemon_profile_start ))
        echo "[daemon] $className.$selector ${_daemon_elapsed}ms route=fallback reason=no_plugin" >&2
      fi
      return 200
    fi

    if [[ "$exitCode" != "0" ]]; then
      local error
      error=$(echo "$response" | jq -r '.error // "unknown error"')
      echo "[NativeDaemon] Error: $error" >&2
      return 1
    fi

    # For instance methods, update instance with new state from native
    if [[ -n "$instanceId" ]] && [[ -n "$instanceJson" ]]; then
      local updatedJson
      updatedJson=$(echo "$response" | jq -r '.instance // empty')
      if [[ -n "$updatedJson" ]] && [[ "$updatedJson" != "null" ]]; then
        # Convert string numbers back to numbers where appropriate
        local newInstanceJson
        newInstanceJson=$(echo "$updatedJson" | jq -c 'walk(if type == "string" and test("^-?[0-9]+$") then tonumber else . end)')
        _env_set "$instanceId" "$newInstanceJson"
        # Persist changes to database (new model: all instances stay persistent)
        _env_persist "$instanceId"
      fi
    fi

    # Extract result
    result=$(echo "$response" | jq -r '.result // ""')

    # Profile: log daemon dispatch timing
    if [[ -n "${TRASH_PROFILE:-}" ]]; then
      _daemon_profile_end=$(_profile_time_ms)
      _daemon_elapsed=$(( _daemon_profile_end - _daemon_profile_start ))
      echo "[daemon] $className.$selector ${_daemon_elapsed}ms route=$_daemon_route" >&2
    fi

    echo "$result"
    return 0
  ]

  # Convenience: dispatch class method (no instance)
  # When 'new' is called, creates a matching entry in Bash's env store
  method: dispatchClass: className selector: selector args: argsJson [
    pragma: primitive
    local className="$1" selector="$2" argsJson="$3"
    local result

    result=$(@ "$_RECEIVER" dispatch: "$className" instance: "" selector: "$selector" args: "$argsJson")

    # For 'new' selector, create matching Bash instance
    if [[ "$selector" == "new" ]] && echo "$result" | grep -q "_"; then
      # Use Trashtalk's standard instance creation to set up env store entry
      _create_instance "$className" "$result"
    fi

    echo "$result"
  ]

  # Convenience: dispatch instance method with no args
  method: dispatch: className instance: instanceId selector: selector [
    pragma: primitive
    local className="$1" instanceId="$2" selector="$3"
    @ "$_RECEIVER" dispatch: "$className" instance: "$instanceId" selector: "$selector" args: "[]"
  ]

  # Check if a native plugin is available for a class
  method: hasNative: className [
    pragma: primitive
    local className="$1" pluginDir ext nativePlugin
    pluginDir="$(_ivar pluginDir)"

    # Check for .dylib (macOS) or .so (Linux)
    case "$(uname)" in
      Darwin) ext=".dylib" ;;
      *)      ext=".so" ;;
    esac

    nativePlugin="$pluginDir/${className}${ext}"

    if [[ -f "$nativePlugin" ]]; then
      echo "true"
    else
      echo "false"
    fi
  ]

  # List available native plugins
  method: listNatives [
    pragma: primitive
    local pluginDir file ext pattern
    pluginDir="$(_ivar pluginDir)"

    # Check for .dylib (macOS) or .so (Linux)
    case "$(uname)" in
      Darwin) ext=".dylib" ;;
      *)      ext=".so" ;;
    esac

    pattern="${pluginDir}/*${ext}"

    if [[ -d "$pluginDir" ]]; then
      for file in $pattern; do
        if [[ -f "$file" ]]; then
          basename "$file" "$ext"
        fi
      done | sort
    fi
  ]

  # Get daemon PID
  method: pid [
    pragma: primitive
    local socketPath pidFile
    socketPath="$(_ivar socketPath)"
    pidFile="${socketPath}.pid"

    if [[ -f "$pidFile" ]]; then
      cat "$pidFile"
    fi
  ]

  # Check if daemon is running
  method: isRunning [
    pragma: primitive
    local socketPath pidFile pid
    socketPath="$(_ivar socketPath)"
    pidFile="${socketPath}.pid"

    if [[ -S "$socketPath" ]] && [[ -f "$pidFile" ]]; then
      pid=$(cat "$pidFile" 2>/dev/null)
      if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
        echo "true"
        return 0
      fi
    fi
    echo "false"
    return 1
  ]

  # Stop the daemon
  method: stop [
    pragma: primitive
    local socketPath pidFile pid
    socketPath="$(_ivar socketPath)"
    pidFile="${socketPath}.pid"

    if [[ -f "$pidFile" ]]; then
      pid=$(cat "$pidFile" 2>/dev/null)
      if [[ -n "$pid" ]]; then
        kill "$pid" 2>/dev/null || true
      fi
    fi

    rm -f "$socketPath" "$pidFile" 2>/dev/null
    _ivar_set status "stopped"
  ]

  # Alias for backwards compatibility
  method: stopAll [
    pragma: primitive
    @ "$_RECEIVER" stop
  ]

  # Get daemon status
  method: status [
    ^ status
  ]

  # Enable/disable debug mode
  method: setDebug: flag [
    debug := flag
  ]

  # Private setters
  method: _setStatus: s [ status := s ]
  method: _setPluginDir: d [ pluginDir := d ]
__TRASHTALK_SOURCE_EOF__
}

__NativeDaemon__pluginDir() {
  echo "$(_ivar pluginDir)"; return
}

__NativeDaemon__pluginDir_() {
  _ivar_set pluginDir "$1"
}

__NativeDaemon__getPluginDir() {
  echo "$(_ivar pluginDir)"; return
}

__NativeDaemon__setPluginDir_() {
  _ivar_set pluginDir "$1"
}
__NativeDaemon__status() {
  echo "$(_ivar status)"; return
}

__NativeDaemon__status_() {
  _ivar_set status "$1"
}

__NativeDaemon__getStatus() {
  echo "$(_ivar status)"; return
}

__NativeDaemon__setStatus_() {
  _ivar_set status "$1"
}
__NativeDaemon__debug() {
  echo "$(_ivar debug)"; return
}

__NativeDaemon__debug_() {
  _ivar_set debug "$1"
}

__NativeDaemon__getDebug() {
  echo "$(_ivar debug)"; return
}

__NativeDaemon__setDebug_() {
  _ivar_set debug "$1"
}
__NativeDaemon__socketPath() {
  echo "$(_ivar socketPath)"; return
}

__NativeDaemon__socketPath_() {
  _ivar_set socketPath "$1"
}

__NativeDaemon__getSocketPath() {
  echo "$(_ivar socketPath)"; return
}

__NativeDaemon__setSocketPath_() {
  _ivar_set socketPath "$1"
}

__NativeDaemon__class__instance() {
    if [[ -z "${_NATIVE_DAEMON:-}" ]]; then
        _NATIVE_DAEMON=$(_generate_instance_id NativeDaemon)
        _create_instance NativeDaemon "$_NATIVE_DAEMON"
        # Use direct ivar manipulation to avoid private method checks
        # when called from _native_daemon_dispatch
        local json
        json=$(_env_get "$_NATIVE_DAEMON")
        json=$(echo "$json" | jq -c '.status="ready" | .pluginDir="'"$TRASHDIR/.compiled"'"')
        _env_set "$_NATIVE_DAEMON" "$json"
    fi
    echo "$_NATIVE_DAEMON"
}

__NativeDaemon__class__isAvailable() {
    if [[ -n "${_NATIVE_DAEMON:-}" ]]; then
        echo "true"
        return 0
    fi
    echo "false"
    return 1
}

__NativeDaemon__class__reset() {
    if [[ -n "${_NATIVE_DAEMON:-}" ]]; then
        @ "$_NATIVE_DAEMON" stop 2>/dev/null || true
    fi
    _NATIVE_DAEMON=""
}

__NativeDaemon___ensureDaemon() {
    local socketPath pidFile pid pluginDir daemonCmd socketOpt pluginOpt debugOpt

    socketPath="$(_ivar socketPath)"
    pidFile="${socketPath}.pid"
    pluginDir="$(_ivar pluginDir)"
    # Use variables to avoid compiler breaking hyphenated option names
    daemonCmd="trashtalk-daemon"
    socketOpt="--socket"
    pluginOpt="--plugin-dir"
    debugOpt="--debug"

    # Check if daemon is already running
    if [[ -S "$socketPath" ]] && [[ -f "$pidFile" ]]; then
        pid=$(cat "$pidFile" 2>/dev/null)
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            # Daemon is running
            return 0
        fi
    fi

    # Clean up stale files
    rm -f "$socketPath" "$pidFile" 2>/dev/null

    # Start daemon in background (disown to prevent subshell from waiting)
    if [[ "$(_ivar debug)" == "true" ]]; then
        "$daemonCmd" "$socketOpt" "$socketPath" "$pluginOpt" "$pluginDir" "$debugOpt" </dev/null >/dev/null 2>&1 &
        disown
        else
        "$daemonCmd" "$socketOpt" "$socketPath" "$pluginOpt" "$pluginDir" </dev/null >/dev/null 2>&1 &
        disown
    fi

    # Wait for socket to appear (max 2 seconds)
    local i
    for i in 1 2 3 4 5 6 7 8 9 10; do
        if [[ -S "$socketPath" ]]; then
            _ivar_set status "running"
            return 0
        fi
        sleep 0.2
    done

    echo "[NativeDaemon] Error: daemon failed to start" >&2
    return 1
}

__NativeDaemon__dispatch_instance_selector_args_() {
  local className="$1"
  local instanceId="$2"
  local selector="$3"
  local argsJson="$4"
    local className="$1" instanceId="$2" selector="$3" argsJson="$4"
    local socketPath request response exitCode result instanceJson nativeSelector
    local _daemon_profile_start _daemon_profile_end _daemon_elapsed _daemon_route="plugin"

    # Profile: record start time
    if [[ -n "${TRASH_PROFILE:-}" ]]; then
        _daemon_profile_start=$(_profile_time_ms)
    fi

    # Ensure daemon is running (call function directly to avoid send() overhead)
    __NativeDaemon___ensureDaemon
    if [[ $? -ne 0 ]]; then
        return 200
    fi

    socketPath="$(_ivar socketPath)"

    # Default args to empty array
    if [[ -z "$argsJson" ]]; then
        argsJson="[]"
    fi

    # Normalize selector: convert colons to underscores for native format
    nativeSelector="${selector//:/_}"

    # For instance methods, load instance data
    instanceJson=""
    if [[ -n "$instanceId" ]]; then
        instanceJson=$(_env_get "$instanceId" 2>/dev/null)
        # Native expects string values, so convert numbers to strings
        if [[ -n "$instanceJson" ]]; then
            instanceJson=$(echo "$instanceJson" | jq -c 'walk(if type == "number" then tostring else . end)')
        fi
    fi

    # Build JSON request for trashtalk-daemon
    # Format: {"class":"Counter","instance":"...","selector":"getValue","args":[]}
    if [[ -n "$instanceJson" ]]; then
        request=$(jq -cn --arg c "$className" --arg i "$instanceJson" --arg s "$nativeSelector" --argjson a "$argsJson" \
            '{class: $c, instance: $i, selector: $s, args: $a}')
        else
        request=$(jq -cn --arg c "$className" --arg i "" --arg s "$nativeSelector" --argjson a "$argsJson" \
            '{class: $c, instance: $i, selector: $s, args: $a}')
    fi

    if [[ "$(_ivar debug)" == "true" ]]; then
        echo "[NativeDaemon] Request: $request" >&2
    fi

    # Send request to daemon via Unix socket
    # nc -U connects to Unix socket, -w 30 sets 30 second timeout
    response=$(echo "$request" | nc -U "$socketPath" 2>/dev/null)

    if [[ -z "$response" ]]; then
        echo "[NativeDaemon] Error: no response from daemon" >&2
        return 1
    fi

    if [[ "$(_ivar debug)" == "true" ]]; then
        echo "[NativeDaemon] Response: $response" >&2
    fi

    # Parse response - daemon returns {"instance":"...","result":"...","exit_code":0}
    exitCode=$(echo "$response" | jq -r '.exit_code // 1')

    if [[ "$exitCode" == "200" ]]; then
        # No native plugin for this class, fallback to Bash
        if [[ -n "${TRASH_PROFILE:-}" ]]; then
            _daemon_profile_end=$(_profile_time_ms)
            _daemon_elapsed=$((_daemon_profile_end - _daemon_profile_start))
            echo "[daemon] $className.$selector ${_daemon_elapsed}ms route=fallback reason=no_plugin" >&2
        fi
        return 200
    fi

    if [[ "$exitCode" != "0" ]]; then
        local error
        error=$(echo "$response" | jq -r '.error // "unknown error"')
        echo "[NativeDaemon] Error: $error" >&2
        return 1
    fi

    # For instance methods, update instance with new state from native
    if [[ -n "$instanceId" ]] && [[ -n "$instanceJson" ]]; then
        local updatedJson
        updatedJson=$(echo "$response" | jq -r '.instance // empty')
        if [[ -n "$updatedJson" ]] && [[ "$updatedJson" != "null" ]]; then
            # Convert string numbers back to numbers where appropriate
            local newInstanceJson
            newInstanceJson=$(echo "$updatedJson" | jq -c 'walk(if type == "string" and test("^-?[0-9]+$") then tonumber else . end)')
            _env_set "$instanceId" "$newInstanceJson"
            # Persist changes to database (new model: all instances stay persistent)
            _env_persist "$instanceId"
        fi
    fi

    # Extract result
    result=$(echo "$response" | jq -r '.result // ""')

    # Profile: log daemon dispatch timing
    if [[ -n "${TRASH_PROFILE:-}" ]]; then
        _daemon_profile_end=$(_profile_time_ms)
        _daemon_elapsed=$((_daemon_profile_end - _daemon_profile_start))
        echo "[daemon] $className.$selector ${_daemon_elapsed}ms route=$_daemon_route" >&2
    fi

    echo "$result"
    return 0
}

__NativeDaemon__dispatchClass_selector_args_() {
  local className="$1"
  local selector="$2"
  local argsJson="$3"
    local className="$1" selector="$2" argsJson="$3"
    local result

    result=$(@ "$_RECEIVER" dispatch: "$className" instance: "" selector: "$selector" args: "$argsJson")

    # For 'new' selector, create matching Bash instance
    if [[ "$selector" == "new" ]] && echo "$result" | grep -q "_"; then
        # Use Trashtalk's standard instance creation to set up env store entry
        _create_instance "$className" "$result"
    fi

    echo "$result"
}

__NativeDaemon__dispatch_instance_selector_() {
  local className="$1"
  local instanceId="$2"
  local selector="$3"
    local className="$1" instanceId="$2" selector="$3"
    @ "$_RECEIVER" dispatch: "$className" instance: "$instanceId" selector: "$selector" args: "[]"
}

__NativeDaemon__hasNative_() {
  local className="$1"
    local className="$1" pluginDir ext nativePlugin
    pluginDir="$(_ivar pluginDir)"

    # Check for .dylib (macOS) or .so (Linux)
    case "$(uname)" in
        Darwin) ext=".dylib";;
        *) ext=".so";;
    esac

    nativePlugin="$pluginDir/${className}${ext}"

    if [[ -f "$nativePlugin" ]]; then
        echo "true"
        else
        echo "false"
    fi
}

__NativeDaemon__listNatives() {
    local pluginDir file ext pattern
    pluginDir="$(_ivar pluginDir)"

    # Check for .dylib (macOS) or .so (Linux)
    case "$(uname)" in
        Darwin) ext=".dylib";;
        *) ext=".so";;
    esac

    pattern="${pluginDir}/*${ext}"

    if [[ -d "$pluginDir" ]]; then
        for file in $pattern; do
            if [[ -f "$file" ]]; then
                basename "$file" "$ext"
            fi
        done | sort
        fi
}

__NativeDaemon__pid() {
    local socketPath pidFile
    socketPath="$(_ivar socketPath)"
    pidFile="${socketPath}.pid"

    if [[ -f "$pidFile" ]]; then
        cat "$pidFile"
    fi
}

__NativeDaemon__isRunning() {
    local socketPath pidFile pid
    socketPath="$(_ivar socketPath)"
    pidFile="${socketPath}.pid"

    if [[ -S "$socketPath" ]] && [[ -f "$pidFile" ]]; then
        pid=$(cat "$pidFile" 2>/dev/null)
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            echo "true"
            return 0
        fi
    fi
    echo "false"
    return 1
}

__NativeDaemon__stop() {
    local socketPath pidFile pid
    socketPath="$(_ivar socketPath)"
    pidFile="${socketPath}.pid"

    if [[ -f "$pidFile" ]]; then
        pid=$(cat "$pidFile" 2>/dev/null)
        if [[ -n "$pid" ]]; then
            kill "$pid" 2>/dev/null || true
        fi
    fi

    rm -f "$socketPath" "$pidFile" 2>/dev/null
    _ivar_set status "stopped"
}

__NativeDaemon__stopAll() {
    @ "$_RECEIVER" stop
}

__NativeDaemon__status() {
  echo "$(_ivar status)"; return
}

__NativeDaemon__setDebug_() {
  local flag="$1"
  _ivar_set debug "$flag"
}

__NativeDaemon___setStatus_() {
  local s="$1"
  _ivar_set status "$s"
}

__NativeDaemon___setPluginDir_() {
  local d="$1"
  _ivar_set pluginDir "$d"
}
