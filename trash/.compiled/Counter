#!/usr/bin/env bash
# Generated by Trashtalk Compiler (procyon) - DO NOT EDIT
# Source: Counter.trash
# Generated: 2026-01-12T15:04:28

__Counter__superclass="Object"
__Counter__instanceVars="value:0 step:1"
__Counter__classInstanceVars=""
__Counter__traits="Persistable"
__Counter__sourceHash="1b4be322e6f68a5ac8f4ded30db69bba439eb85905e56ec4a54ac0769552efd3"

__Counter__source() {
  cat <<'__TRASHTALK_SOURCE_EOF__'
# Counter - A simple counter class demonstrating Trashtalk DSL
# Instance variables use Smalltalk-style inference: value -> $(_ivar value)
Counter subclass: Object
  include: Persistable
  instanceVars: value:0 step:1

  classMethod: new [
    | id |
    id := @ Runtime generateId: "Counter"
    @ Runtime create: "Counter" id: id
    ^ id
  ]

  method: getValue [
    ^ value + 0
  ]

  method: getStep [
    ^ step + 0
  ]

  method: setValue: val [
    value := val + 0
  ]

  method: setStep: val [
    step := val + 0
  ]

  method: increment [
    | newVal |
    newVal := value + step
    value := newVal + 0
    ^ newVal + 0
  ]

  method: decrement [
    | newVal |
    newVal := value - step
    value := newVal + 0
    ^ newVal + 0
  ]

  method: incrementBy: amount [
    | newVal |
    newVal := value + amount
    value := newVal + 0
  ]

  method: reset [
    value := 0 + 0
  ]

  classMethod: description [
    ^ "A simple counter"
  ]
__TRASHTALK_SOURCE_EOF__
}

__Counter__value() {
  echo "$(_ivar value)"; return
}

__Counter__value_() {
  _ivar_set value "$1"
}

__Counter__step() {
  echo "$(_ivar step)"; return
}

__Counter__step_() {
  _ivar_set step "$1"
}

__Counter__class__new() {
  local id
  id="$(@ Runtime generateId_ "Counter")"
  $(@ Runtime create_id_ "Counter" $id)
  echo "$id"; return
}

__Counter__getValue() {
  echo "$(( $(_ivar value) + 0 ))"; return
}

__Counter__getStep() {
  echo "$(( $(_ivar step) + 0 ))"; return
}

__Counter__setValue_() {
  local val="$1"
  local __arith__; (( __arith__ = ($val + 0) )); _ivar_set value "$__arith__"
}

__Counter__setStep_() {
  local val="$1"
  local __arith__; (( __arith__ = ($val + 0) )); _ivar_set step "$__arith__"
}

__Counter__increment() {
  local newVal
  (( newVal = ($(_ivar value) + $(_ivar step)) ))
  local __arith__; (( __arith__ = ($newVal + 0) )); _ivar_set value "$__arith__"
  echo "$(( $newVal + 0 ))"; return
}

__Counter__decrement() {
  local newVal
  (( newVal = ($(_ivar value) - $(_ivar step)) ))
  local __arith__; (( __arith__ = ($newVal + 0) )); _ivar_set value "$__arith__"
  echo "$(( $newVal + 0 ))"; return
}

__Counter__incrementBy_() {
  local amount="$1"
  local newVal
  (( newVal = ($(_ivar value) + $amount) ))
  local __arith__; (( __arith__ = ($newVal + 0) )); _ivar_set value "$__arith__"
}

__Counter__reset() {
  local __arith__; (( __arith__ = (0 + 0) )); _ivar_set value "$__arith__"
}

__Counter__class__description() {
  echo ""A simple counter""; return
}

__Counter__save() {
  _env_persist "$_RECEIVER"
}

__Counter__unpersist() {
  db_delete "$_RECEIVER" 2 > /dev/null
}

__Counter__delete() {
  db_delete "$_RECEIVER" 2 > /dev/null
  _env_delete "$_RECEIVER"
}

__Counter__isPersisted() {
  if _env_is_persisted "$_RECEIVER" ; then
  echo "true"
  else
  echo "false"
  fi
}

__Counter__reload() {
  _env_load "$_RECEIVER"
}

__Counter__asJson() {
  _ensure_loaded "$_RECEIVER"
  _env_get "$_RECEIVER"
}

__Counter__class__create() {
  local instance_id
  instance_id=$(_generate_instance_id "$_CLASS")
  _create_instance "$_CLASS" "$instance_id"
  _env_persist "$instance_id"
  echo "$instance_id"
}

__Counter__class__findAll() {
  db_find_by_class "$_CLASS"
}

__Counter__class__count() {
  db_count_by_class "$_CLASS"
}

__Counter__class__find() {
  local predicate="$1"
  if [[ -z "$predicate" ]] ; then
  db_find_by_class "$_CLASS"
  return
  fi
  _find_with_predicate "$_CLASS" "$predicate"
}

__Counter__class__loadAll() {
  local ids id
  ids=$(db_find_by_class "$_CLASS")
  for id in $ids ; do
  _env_load "$id" 2 > /dev/null
  done
}

