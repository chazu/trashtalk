#!/usr/bin/env bash
# Generated by Trashtalk Compiler (jq) - DO NOT EDIT
# Source: Transcript.trash
# Generated: 2026-01-04T02:40:37

__Transcript__superclass="Object"
__Transcript__instanceVars="session: outputView: inputField: layout: running: transcriptHistory:"
__Transcript__classInstanceVars=""
__Transcript__traits=""
__Transcript__sourceHash="6b105df313117d5f63120c0226b173b257392c5daa90422ef1325468089452b8"

__Transcript__source() {
  cat <<'__TRASHTALK_SOURCE_EOF__'
Transcript subclass: Object
  instanceVars: session:'' outputView:'' inputField:'' layout:'' running:'' transcriptHistory:''

  rawClassMethod: open [
    local transcript session
    transcript=$(@ Transcript new)
    session=$(@ YutaniSession connect 2>&1 | grep -v "^\[INFO\]" | tail -1)

    if [[ -z "$session" ]] || echo "$session" | grep -qi error; then
      echo "Error: Could not connect to Yutani server" >&2
      return 1
    fi

    @ "$transcript" setSession: "$session"
    @ "$transcript" setup
    @ "$transcript" run
  ]

  rawClassMethod: openOn: host [
    local transcript session host="$1"
    transcript=$(@ Transcript new)
    session=$(@ YutaniSession connectTo: "$host" 2>&1 | grep -v "^\[INFO\]" | tail -1)

    if [[ -z "$session" ]] || echo "$session" | grep -qi error; then
      echo "Error: Could not connect to Yutani server at $host" >&2
      return 1
    fi

    @ "$transcript" setSession: "$session"
    @ "$transcript" setup
    @ "$transcript" run
  ]

  method: setSession: s [
    _ivar_set session "$s"
  ]

  method: session [
    _ivar session
  ]

  rawMethod: setup [
    local session output_view input_field layout initial_text
    session="$(_ivar session)"

    # Create vertical layout
    layout=$(@ "$session" createVerticalLayout)
    _ivar_set layout "$layout"

    # Create the output text view
    initial_text="Trashtalk Transcript
Type code and press Enter to evaluate. Ctrl+C to exit.
"
    output_view=$(@ "$session" createTextView: 'Output')
    _ivar_set outputView "$output_view"
    _ivar_set transcriptHistory "$initial_text"
    @ "$session" setText: "$initial_text" on: "$output_view"

    # Create input field
    input_field=$(@ "$session" createInputFieldWithPlaceholder: '>' placeholder: 'Enter Trashtalk code...')
    _ivar_set inputField "$input_field"

    # Add widgets to layout - output view takes most space, input field is fixed with focus
    @ "$session" addChild: "$output_view" to: "$layout"
    @ "$session" addChild: "$input_field" to: "$layout" fixedSize: 3 focus: true

    # Set layout as root
    @ "$session" setRoot: "$layout"

    _ivar_set running "true"
  ]

  rawMethod: run [
    local session event sid fifo
    session="$(_ivar session)"

    # Get session ID and build FIFO path
    sid=$(@ "$session" sessionId)
    fifo="/tmp/yutani-events-${sid}"

    # Start event stream
    @ "$session" startEventStream

    # Open FIFO once and keep it open (crucial for continuous reading)
    exec 3< "$fifo"

    while [[ "$(_ivar running)" == "true" ]]; do
      # Read next event from file descriptor 3
      if ! read -r event <&3; then
        break
      fi

      if [[ -z "$event" ]]; then
        continue
      fi

      # Skip non-JSON lines (errors, etc)
      if ! echo "$event" | jq -e . >/dev/null 2>&1; then
        continue
      fi

      # Parse event type - check for widget events first
      if echo "$event" | jq -e '.widget' >/dev/null 2>&1; then
        @ "$_RECEIVER" handleWidgetEvent: "$event"
      elif echo "$event" | jq -e '.key' >/dev/null 2>&1; then
        @ "$_RECEIVER" handleKeyEvent: "$event"
      fi
    done

    # Close file descriptor
    exec 3<&-

    # Cleanup
    @ "$session" disconnect
  ]

  rawMethod: handleWidgetEvent: event [
    local widget_id event_type text input_field
    input_field="$(_ivar inputField)"

    # Extract widget event fields
    widget_id=$(echo "$event" | jq -r '.widget.widgetId.id // ""')
    event_type=$(echo "$event" | jq -r '.widget.type // ""')
    # Text is in the data map for input fields
    text=$(echo "$event" | jq -r '.widget.data.text // ""')

    # Check for submission from our input field
    if [[ "$widget_id" == "$input_field" ]]; then
      case "$event_type" in
        WIDGET_SUBMITTED)
          @ "$_RECEIVER" evaluateInput: "$text"
          ;;
      esac
    fi
  ]

  rawMethod: handleKeyEvent: event [
    local key_name session input_field text
    session="$(_ivar session)"
    input_field="$(_ivar inputField)"

    # Extract key info
    key_name=$(echo "$event" | jq -r '.key.key // ""')

    case "$key_name" in
      KEY_CTRL_C)
        # Exit
        _ivar_set running "false"
        ;;
      KEY_CTRL_D)
        # Also exit
        _ivar_set running "false"
        ;;
      KEY_CTRL_L)
        # Clear transcript
        @ "$_RECEIVER" clear
        ;;
      KEY_ENTER)
        # Get text from input field and evaluate
        text=$(@ "$session" getInputText: "$input_field")
        if [[ -n "$text" ]]; then
          @ "$_RECEIVER" evaluateInput: "$text"
        fi
        ;;
      KEY_TAB)
        # Refocus input field
        @ "$session" focusWidget: "$input_field"
        ;;
      KEY_ESC)
        # Clear input and refocus
        @ "$session" setInputText: '' on: "$input_field"
        @ "$session" focusWidget: "$input_field"
        ;;
    esac
  ]

  rawMethod: evaluateInput: text [
    local result session output_view input_field new_text
    session="$(_ivar session)"
    output_view="$(_ivar outputView)"
    input_field="$(_ivar inputField)"

    if [[ -z "$text" ]]; then
      return
    fi

    # Evaluate the code
    result=$(@ Trash eval: "$text" 2>&1)

    # Build new output
    new_text="> ${text}
${result}

"

    # Append to transcript
    @ "$_RECEIVER" appendText: "$new_text"

    # Clear input field
    @ "$session" setInputText: '' on: "$input_field"

    # Re-focus input field
    @ "$session" focusWidget: "$input_field"
  ]

  rawMethod: appendText: text [
    local session output_view history
    session="$(_ivar session)"
    output_view="$(_ivar outputView)"

    history="$(_ivar transcriptHistory)"
    history="${history}${text}"
    _ivar_set transcriptHistory "$history"

    @ "$session" setText: "$history" on: "$output_view"
  ]

  rawMethod: clear [
    local session output_view
    session="$(_ivar session)"
    output_view="$(_ivar outputView)"

    _ivar_set transcriptHistory ""
    @ "$session" setText: "" on: "$output_view"
  ]

  method: close [
    _ivar_set running "false"
  ]
__TRASHTALK_SOURCE_EOF__
}

__Transcript__session() {
  echo "$(_ivar session)"; return
}

__Transcript__session_() {
  _ivar_set session "$1"
}

__Transcript__getSession() {
  echo "$(_ivar session)"; return
}

__Transcript__setSession_() {
  _ivar_set session "$1"
}
__Transcript__outputView() {
  echo "$(_ivar outputView)"; return
}

__Transcript__outputView_() {
  _ivar_set outputView "$1"
}

__Transcript__getOutputView() {
  echo "$(_ivar outputView)"; return
}

__Transcript__setOutputView_() {
  _ivar_set outputView "$1"
}
__Transcript__inputField() {
  echo "$(_ivar inputField)"; return
}

__Transcript__inputField_() {
  _ivar_set inputField "$1"
}

__Transcript__getInputField() {
  echo "$(_ivar inputField)"; return
}

__Transcript__setInputField_() {
  _ivar_set inputField "$1"
}
__Transcript__layout() {
  echo "$(_ivar layout)"; return
}

__Transcript__layout_() {
  _ivar_set layout "$1"
}

__Transcript__getLayout() {
  echo "$(_ivar layout)"; return
}

__Transcript__setLayout_() {
  _ivar_set layout "$1"
}
__Transcript__running() {
  echo "$(_ivar running)"; return
}

__Transcript__running_() {
  _ivar_set running "$1"
}

__Transcript__getRunning() {
  echo "$(_ivar running)"; return
}

__Transcript__setRunning_() {
  _ivar_set running "$1"
}
__Transcript__transcriptHistory() {
  echo "$(_ivar transcriptHistory)"; return
}

__Transcript__transcriptHistory_() {
  _ivar_set transcriptHistory "$1"
}

__Transcript__getTranscriptHistory() {
  echo "$(_ivar transcriptHistory)"; return
}

__Transcript__setTranscriptHistory_() {
  _ivar_set transcriptHistory "$1"
}

__Transcript__class__open() {
    local transcript session
    transcript=$(@ Transcript new)
    session=$(@ YutaniSession connect 2>&1 | grep -v "^\[INFO\]" | tail -1)

    if [[ -z "$session" ]] || echo "$session" | grep -qi error; then
        echo "Error: Could not connect to Yutani server" >&2
        return 1
    fi

    @ "$transcript" setSession: "$session"
    @ "$transcript" setup
    @ "$transcript" run
}

__Transcript__class__openOn_() {
  local host="$1"
    local transcript session host="$1"
    transcript=$(@ Transcript new)
    session=$(@ YutaniSession connectTo: "$host" 2>&1 | grep -v "^\[INFO\]" | tail -1)

    if [[ -z "$session" ]] || echo "$session" | grep -qi error; then
        echo "Error: Could not connect to Yutani server at $host" >&2
        return 1
    fi

    @ "$transcript" setSession: "$session"
    @ "$transcript" setup
    @ "$transcript" run
}

__Transcript__setSession_() {
  local s="$1"
  _ivar_set session "$s"
}

__Transcript__session() {
  _ivar session
}

__Transcript__setup() {
    local session output_view input_field layout initial_text
    session="$(_ivar session)"

    # Create vertical layout
    layout=$(@ "$session" createVerticalLayout)
    _ivar_set layout "$layout"

    # Create the output text view
    initial_text="Trashtalk Transcript
    Type code and press Enter to evaluate. Ctrl+C to exit.
    "
    output_view=$(@ "$session" createTextView: 'Output')
    _ivar_set outputView "$output_view"
    _ivar_set transcriptHistory "$initial_text"
    @ "$session" setText: "$initial_text" on: "$output_view"

    # Create input field
    input_field=$(@ "$session" createInputFieldWithPlaceholder: '>' placeholder: 'Enter Trashtalk code...')
    _ivar_set inputField "$input_field"

    # Add widgets to layout - output view takes most space, input field is fixed with focus
    @ "$session" addChild: "$output_view" to: "$layout"
    @ "$session" addChild: "$input_field" to: "$layout" fixedSize: 3 focus: true

    # Set layout as root
    @ "$session" setRoot: "$layout"

    _ivar_set running "true"
}

__Transcript__run() {
    local session event sid fifo
    session="$(_ivar session)"

    # Get session ID and build FIFO path
    sid=$(@ "$session" sessionId)
    fifo="/tmp/yutani-events-${sid}"

    # Start event stream
    @ "$session" startEventStream

    # Open FIFO once and keep it open (crucial for continuous reading)
    exec 3 <"$fifo"

    while [[ "$(_ivar running)" == "true" ]]; do
        # Read next event from file descriptor 3
        if ! read -r event <&3; then
            break
        fi

        if [[ -z "$event" ]]; then
            continue
        fi

        # Skip non-JSON lines (errors, etc)
        if ! echo "$event" | jq -e . >/dev/null 2>&1; then
            continue
        fi

        # Parse event type - check for widget events first
        if echo "$event" | jq -e '.widget' >/dev/null 2>&1; then
            @ "$_RECEIVER" handleWidgetEvent: "$event"
            elif echo "$event" | jq -e '.key' >/dev/null 2>&1; then
                @ "$_RECEIVER" handleKeyEvent: "$event"
            fi
        done

        # Close file descriptor
        exec 3 <&-

        # Cleanup
        @ "$session" disconnect
}

__Transcript__handleWidgetEvent_() {
  local event="$1"
    local widget_id event_type text input_field
    input_field="$(_ivar inputField)"

    # Extract widget event fields
    widget_id=$(echo "$event" | jq -r '.widget.widgetId.id // ""')
    event_type=$(echo "$event" | jq -r '.widget.type // ""')
    # Text is in the data map for input fields
    text=$(echo "$event" | jq -r '.widget.data.text // ""')

    # Check for submission from our input field
    if [[ "$widget_id" == "$input_field" ]]; then
        case "$event_type" in
            WIDGET_SUBMITTED)
            @ "$_RECEIVER" evaluateInput: "$text"
        ;;
        esac
    fi
}

__Transcript__handleKeyEvent_() {
  local event="$1"
    local key_name session input_field text
    session="$(_ivar session)"
    input_field="$(_ivar inputField)"

    # Extract key info
    key_name=$(echo "$event" | jq -r '.key.key // ""')

    case "$key_name" in
        KEY_CTRL_C)
        # Exit
        _ivar_set running "false"
    ;;
        KEY_CTRL_D)
        # Also exit
        _ivar_set running "false"
    ;;
        KEY_CTRL_L)
        # Clear transcript
        @ "$_RECEIVER" clear
    ;;
        KEY_ENTER)
        # Get text from input field and evaluate
        text=$(@ "$session" getInputText: "$input_field")
        if [[ -n "$text" ]]; then
            @ "$_RECEIVER" evaluateInput: "$text"
        fi
    ;;
        KEY_TAB)
        # Refocus input field
        @ "$session" focusWidget: "$input_field"
    ;;
        KEY_ESC)
        # Clear input and refocus
        @ "$session" setInputText: '' on: "$input_field"
        @ "$session" focusWidget: "$input_field"
    ;;
    esac
}

__Transcript__evaluateInput_() {
  local text="$1"
    local result session output_view input_field new_text
    session="$(_ivar session)"
    output_view="$(_ivar outputView)"
    input_field="$(_ivar inputField)"

    if [[ -z "$text" ]]; then
        return
    fi

    # Evaluate the code
    result=$(@ Trash eval: "$text" 2>&1)

    # Build new output
    new_text="> ${text}
    ${result}

    "

    # Append to transcript
    @ "$_RECEIVER" appendText: "$new_text"

    # Clear input field
    @ "$session" setInputText: '' on: "$input_field"

    # Re-focus input field
    @ "$session" focusWidget: "$input_field"
}

__Transcript__appendText_() {
  local text="$1"
    local session output_view history
    session="$(_ivar session)"
    output_view="$(_ivar outputView)"

    history="$(_ivar transcriptHistory)"
    history="${history}${text}"
    _ivar_set transcriptHistory "$history"

    @ "$session" setText: "$history" on: "$output_view"
}

__Transcript__clear() {
    local session output_view
    session="$(_ivar session)"
    output_view="$(_ivar outputView)"

    _ivar_set transcriptHistory ""
    @ "$session" setText: "" on: "$output_view"
}

__Transcript__close() {
  _ivar_set running "false"
}
