#!/usr/bin/env bash
# Generated by Trashtalk Compiler (jq) - DO NOT EDIT
# Source: String.trash
# Generated: 2026-01-09T20:03:21

__String__superclass="Object"
__String__instanceVars=""
__String__classInstanceVars=""
__String__traits=""
__String__sourceHash="a8010ba719d1c1423d095a7bd215e036f0bb2691c38ff432d130407ea4ec4dce"

__String__source() {
  cat <<'__TRASHTALK_SOURCE_EOF__'
# String - String manipulation and testing utilities
# Provides class methods for common string operations that enable
# converting raw methods to pure DSL.
#
# Usage:
#   (@ String isEmpty: myVar) ifTrue: [ ... ]
#   (@ String contains: text substring: "error") ifTrue: [ ... ]
#   result := @ String trimSuffix: ".trash" from: filename
#
String subclass: Object

  # ========================================
  # String Tests
  # ========================================

  # Test if string is empty (replaces [[ -z "$str" ]])
  rawClassMethod: isEmpty: str [
    [[ -z "$str" ]] && echo "true" || echo "false"
  ]

  # Test if string is not empty (replaces [[ -n "$str" ]])
  rawClassMethod: notEmpty: str [
    [[ -n "$str" ]] && echo "true" || echo "false"
  ]

  # Test if string contains substring
  rawClassMethod: contains: str substring: sub [
    [[ "$str" == *"$sub"* ]] && echo "true" || echo "false"
  ]

  # Test if string starts with prefix
  rawClassMethod: startsWith: str prefix: prefix [
    [[ "$str" == "$prefix"* ]] && echo "true" || echo "false"
  ]

  # Test if string ends with suffix
  rawClassMethod: endsWith: str suffix: suffix [
    [[ "$str" == *"$suffix" ]] && echo "true" || echo "false"
  ]

  # Test if two strings are equal
  rawClassMethod: equals: a to: b [
    [[ "$a" == "$b" ]] && echo "true" || echo "false"
  ]

  # ========================================
  # String Manipulation
  # ========================================

  # Remove prefix pattern from string (replaces ${str##pattern})
  rawClassMethod: trimPrefix: pattern from: str [
    echo "${str##$pattern}"
  ]

  # Remove suffix pattern from string (replaces ${str%%pattern})
  rawClassMethod: trimSuffix: pattern from: str [
    echo "${str%%$pattern}"
  ]

  # Remove shortest prefix match (replaces ${str#pattern})
  rawClassMethod: trimShortPrefix: pattern from: str [
    echo "${str#$pattern}"
  ]

  # Remove shortest suffix match (replaces ${str%pattern})
  rawClassMethod: trimShortSuffix: pattern from: str [
    echo "${str%$pattern}"
  ]

  # Replace first occurrence (replaces ${str/old/new})
  rawClassMethod: replace: old with: new in: str [
    echo "${str/$old/$new}"
  ]

  # Replace all occurrences (replaces ${str//old/new})
  rawClassMethod: replaceAll: old with: new in: str [
    echo "${str//$old/$new}"
  ]

  # Get substring (replaces ${str:start:length})
  rawClassMethod: substring: str from: start length: len [
    echo "${str:$start:$len}"
  ]

  # Get string length
  rawClassMethod: length: str [
    echo "${#str}"
  ]

  # Convert to uppercase
  rawClassMethod: uppercase: str [
    echo "${str^^}"
  ]

  # Convert to lowercase
  rawClassMethod: lowercase: str [
    echo "${str,,}"
  ]

  # ========================================
  # String Splitting
  # ========================================

  # Split string on delimiter, return as newline-separated values
  rawClassMethod: split: str on: delim [
    local IFS="$delim"
    local parts
    read -ra parts <<< "$str"
    printf '%s\n' "${parts[@]}"
  ]

  # Get part before delimiter (replaces ${str%%delim*})
  rawClassMethod: before: delim in: str [
    echo "${str%%$delim*}"
  ]

  # Get part after delimiter (replaces ${str#*delim})
  rawClassMethod: after: delim in: str [
    echo "${str#*$delim}"
  ]

  # ========================================
  # String Building
  # ========================================

  # Concatenate two strings
  rawClassMethod: concat: a with: b [
    echo "${a}${b}"
  ]

  # Concatenate three strings
  rawClassMethod: concat: a with: b with: c [
    echo "${a}${b}${c}"
  ]

  # Join array elements with delimiter
  rawClassMethod: join: delimiter values: values [
    local IFS="$delimiter"
    echo "$values"
  ]

  # Repeat string n times
  rawClassMethod: repeat: str times: n [
    local result=""
    local i
    for ((i=0; i<n; i++)); do
      result="${result}${str}"
    done
    echo "$result"
  ]

  # ========================================
  # Whitespace Handling
  # ========================================

  # Trim leading and trailing whitespace (using extglob)
  rawClassMethod: trim: str [
    shopt -s extglob
    str="${str##+([[:space:]])}"
    str="${str%%+([[:space:]])}"
    shopt -u extglob
    echo "$str"
  ]

  # Trim leading whitespace (using extglob)
  rawClassMethod: trimLeft: str [
    shopt -s extglob
    echo "${str##+([[:space:]])}"
  ]

  # Trim trailing whitespace (using extglob)
  rawClassMethod: trimRight: str [
    shopt -s extglob
    echo "${str%%+([[:space:]])}"
  ]
__TRASHTALK_SOURCE_EOF__
}

__String__class__isEmpty_() {
  local str="$1"
    [[ -z "$str" ]] && echo "true" || echo "false"
}

__String__class__notEmpty_() {
  local str="$1"
    [[ -n "$str" ]] && echo "true" || echo "false"
}

__String__class__contains_substring_() {
  local str="$1"
  local sub="$2"
    [[ "$str" == *"$sub"* ]] && echo "true" || echo "false"
}

__String__class__startsWith_prefix_() {
  local str="$1"
  local prefix="$2"
    [[ "$str" == "$prefix"* ]] && echo "true" || echo "false"
}

__String__class__endsWith_suffix_() {
  local str="$1"
  local suffix="$2"
    [[ "$str" == *"$suffix" ]] && echo "true" || echo "false"
}

__String__class__equals_to_() {
  local a="$1"
  local b="$2"
    [[ "$a" == "$b" ]] && echo "true" || echo "false"
}

__String__class__trimPrefix_from_() {
  local pattern="$1"
  local str="$2"
    echo "${str##$pattern}"
}

__String__class__trimSuffix_from_() {
  local pattern="$1"
  local str="$2"
    echo "${str%%$pattern}"
}

__String__class__trimShortPrefix_from_() {
  local pattern="$1"
  local str="$2"
    echo "${str#$pattern}"
}

__String__class__trimShortSuffix_from_() {
  local pattern="$1"
  local str="$2"
    echo "${str%$pattern}"
}

__String__class__replace_with_in_() {
  local old="$1"
  local new="$2"
  local str="$3"
    echo "${str/$old/$new}"
}

__String__class__replaceAll_with_in_() {
  local old="$1"
  local new="$2"
  local str="$3"
    echo "${str//$old/$new}"
}

__String__class__substring_from_length_() {
  local str="$1"
  local start="$2"
  local len="$3"
    echo "${str:$start:$len}"
}

__String__class__length_() {
  local str="$1"
    echo "${#str}"
}

__String__class__uppercase_() {
  local str="$1"
    echo "${str^^}"
}

__String__class__lowercase_() {
  local str="$1"
    echo "${str,,}"
}

__String__class__split_on_() {
  local str="$1"
  local delim="$2"
    local IFS="$delim"
    local parts
    read -ra parts <<<"$str"
    printf '%s\n' "${parts[@]}"
}

__String__class__before_in_() {
  local delim="$1"
  local str="$2"
    echo "${str%%$delim*}"
}

__String__class__after_in_() {
  local delim="$1"
  local str="$2"
    echo "${str#*$delim}"
}

__String__class__concat_with_() {
  local a="$1"
  local b="$2"
    echo "${a}${b}"
}

__String__class__concat_with_with_() {
  local a="$1"
  local b="$2"
  local c="$3"
    echo "${a}${b}${c}"
}

__String__class__join_values_() {
  local delimiter="$1"
  local values="$2"
    local IFS="$delimiter"
    echo "$values"
}

__String__class__repeat_times_() {
  local str="$1"
  local n="$2"
    local result=""
    local i
    for ((i=0; i<n; i++)); do
        result="${result}${str}"
    done
    echo "$result"
}

__String__class__trim_() {
  local str="$1"
    shopt -s extglob
    str="${str##+([[:space:]])}"
    str="${str%%+([[:space:]])}"
    shopt -u extglob
    echo "$str"
}

__String__class__trimLeft_() {
  local str="$1"
    shopt -s extglob
    echo "${str##+([[:space:]])}"
}

__String__class__trimRight_() {
  local str="$1"
    shopt -s extglob
    echo "${str%%+([[:space:]])}"
}
