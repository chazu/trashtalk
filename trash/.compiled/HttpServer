#!/usr/bin/env bash
# Generated by Trashtalk Compiler (jq) - DO NOT EDIT
# Source: HttpServer.trash
# Generated: 2026-01-06T00:53:20

__HttpServer__superclass="Object"
__HttpServer__instanceVars="port:8080 root"
__HttpServer__classInstanceVars=""
__HttpServer__traits="Debuggable"
__HttpServer__sourceHash="c586d8c886ae1377c51380095549d9d24b67c6512e3e6753adeba9acda461f3d"

__HttpServer__source() {
  cat <<'__TRASHTALK_SOURCE_EOF__'
# HttpServer - A simple HTTP server for serving static content
# Uses a bash-based approach with netcat for network I/O
#
# Usage:
#   server=$(@ HttpServer new)
#   @ $server root: '/path/to/webroot'
#   @ $server port: 8080
#   @ $server start    # Starts in foreground
#
# Or use the class method for quick start:
#   @ HttpServer serveDirectory: '/path/to/webroot' onPort: 8080
#
# Note: For production use, consider a proper HTTP server.
# This is intended for development and simple static file serving.

HttpServer subclass: Object
  include: Debuggable
  instanceVars: port:8080 root:. running:false

  rawClassMethod: new [
    local id
    id=$(_generate_instance_id HttpServer)
    _create_instance HttpServer "$id"
    echo "$id"
  ]

  # Set the document root directory
  method: root: path [
    _ivar_set root "$path"
  ]

  # Set the port to listen on
  method: port: p [
    _ivar_set port "$p"
  ]

  # Quick start: serve a directory on a port
  rawClassMethod: serveDirectory: dir onPort: port [
    local server
    server=$(@ HttpServer new)
    @ "$server" root: "$dir"
    @ "$server" port: "$port"
    @ "$server" start
  ]

  # Start the server (foreground, blocking)
  rawMethod: start [
    local port root pipe_dir request_pipe response_pipe
    port=$(_ivar port)
    root=$(_ivar root)

    # Validate root directory
    if [[ ! -d "$root" ]]; then
      echo "Error: Document root '$root' is not a directory" >&2
      return 1
    fi

    # Create named pipes for communication
    pipe_dir="/tmp/httpserver_$$"
    mkdir -p "$pipe_dir"
    request_pipe="$pipe_dir/request"
    response_pipe="$pipe_dir/response"
    mkfifo "$request_pipe" "$response_pipe"

    # Cleanup on exit
    trap "rm -rf '$pipe_dir'; exit" INT TERM EXIT

    echo "=== Trashtalk HTTP Server ==="
    echo "Port: $port"
    echo "Root: $root"
    echo "Press Ctrl+C to stop"
    echo ""

    _ivar_set running true

    # Main server loop using ncat-style handling
    while [[ "$(_ivar running)" == "true" ]]; do
      @ "$_RECEIVER" _handleConnection "$port" "$root"
    done

    rm -rf "$pipe_dir"
  ]

  # Handle a single HTTP connection
  rawMethod: _handleConnection: port root: root [
    local request method path version response_file
    local status_code status_text content_type body

    # Create a handler script that nc will execute
    local handler="/tmp/http_handler_$$.sh"
    cat > "$handler" << 'HANDLER_EOF'
#!/bin/bash
ROOT="$1"

# Read the request line
read -r request_line
method=$(echo "$request_line" | cut -d' ' -f1)
path=$(echo "$request_line" | cut -d' ' -f2)

# Read and discard headers until empty line
while IFS= read -r header; do
  header="${header%%$'\r'}"
  [[ -z "$header" ]] && break
done

# Security: prevent directory traversal
path="${path//\.\./}"

# Strip query string
path="${path%%\?*}"

# Default to index.html for directory requests
[[ "$path" == "/" ]] && path="/index.html"

# Build full file path
response_file="${ROOT}${path}"

# Log to stderr (visible in server output)
echo "[$(date '+%H:%M:%S')] $method $path" >&2

# Determine MIME type
get_mime_type() {
  case "${1##*.}" in
    html|htm) echo "text/html" ;;
    css)      echo "text/css" ;;
    js)       echo "application/javascript" ;;
    json)     echo "application/json" ;;
    txt)      echo "text/plain" ;;
    xml)      echo "application/xml" ;;
    jpg|jpeg) echo "image/jpeg" ;;
    png)      echo "image/png" ;;
    gif)      echo "image/gif" ;;
    svg)      echo "image/svg+xml" ;;
    ico)      echo "image/x-icon" ;;
    pdf)      echo "application/pdf" ;;
    *)        echo "application/octet-stream" ;;
  esac
}

# Send response
if [[ -f "$response_file" && -r "$response_file" ]]; then
  content_type=$(get_mime_type "$response_file")
  content_length=$(wc -c < "$response_file" | tr -d ' ')
  printf "HTTP/1.1 200 OK\r\n"
  printf "Content-Type: %s\r\n" "$content_type"
  printf "Content-Length: %d\r\n" "$content_length"
  printf "Connection: close\r\n"
  printf "\r\n"
  cat "$response_file"
else
  body="<html><body><h1>404 Not Found</h1><p>File not found: $path</p></body></html>"
  printf "HTTP/1.1 404 Not Found\r\n"
  printf "Content-Type: text/html\r\n"
  printf "Content-Length: %d\r\n" "${#body}"
  printf "Connection: close\r\n"
  printf "\r\n"
  printf "%s" "$body"
fi
HANDLER_EOF
    chmod +x "$handler"

    # Use nc to handle one connection
    # BSD nc on macOS: nc -l <port> executes with stdin/stdout connected to client
    nc -l "$port" -c "$handler $root" 2>/dev/null || \
    { cat | "$handler" "$root"; } < <(nc -l "$port") 2>/dev/null || \
    @ "$_RECEIVER" _handleSimple "$port" "$root"

    rm -f "$handler"
  ]

  # Simple fallback handler without -c support
  rawMethod: _handleSimple: port root: root [
    local request_file="/tmp/http_req_$$"
    local response_file="/tmp/http_resp_$$"

    # Capture request
    timeout 30 nc -l "$port" > "$request_file" 2>/dev/null &
    local nc_pid=$!
    wait $nc_pid 2>/dev/null

    if [[ -s "$request_file" ]]; then
      local request_line method path
      request_line=$(head -1 "$request_file")
      method=$(echo "$request_line" | cut -d' ' -f1)
      path=$(echo "$request_line" | cut -d' ' -f2)

      # Security and defaults
      path="${path//\.\./}"
      path="${path%%\?*}"
      [[ "$path" == "/" ]] && path="/index.html"

      echo "[$(date '+%H:%M:%S')] $method $path"

      local file_path="${root}${path}"

      # Build response
      if [[ -f "$file_path" ]]; then
        {
          printf "HTTP/1.1 200 OK\r\n"
          printf "Content-Type: %s\r\n" "$(@ "$_RECEIVER" _mimeType: "$file_path")"
          printf "Connection: close\r\n"
          printf "\r\n"
          cat "$file_path"
        } > "$response_file"
      else
        local body="<html><body><h1>404 Not Found</h1></body></html>"
        {
          printf "HTTP/1.1 404 Not Found\r\n"
          printf "Content-Type: text/html\r\n"
          printf "Connection: close\r\n"
          printf "\r\n"
          printf "%s" "$body"
        } > "$response_file"
      fi

      # Send response on next connection (client retries)
      cat "$response_file" | nc -l "$port" 2>/dev/null &
      sleep 0.2
    fi

    rm -f "$request_file" "$response_file"
  ]

  # Determine MIME type from file extension
  rawMethod: _mimeType: filepath [
    local ext="${filepath##*.}"
    case "${ext,,}" in
      html|htm) echo "text/html" ;;
      css)      echo "text/css" ;;
      js)       echo "application/javascript" ;;
      json)     echo "application/json" ;;
      txt)      echo "text/plain" ;;
      xml)      echo "application/xml" ;;
      jpg|jpeg) echo "image/jpeg" ;;
      png)      echo "image/png" ;;
      gif)      echo "image/gif" ;;
      svg)      echo "image/svg+xml" ;;
      ico)      echo "image/x-icon" ;;
      pdf)      echo "application/pdf" ;;
      woff)     echo "font/woff" ;;
      woff2)    echo "font/woff2" ;;
      ttf)      echo "font/ttf" ;;
      *)        echo "application/octet-stream" ;;
    esac
  ]

  # Stop the server
  method: stop [
    _ivar_set running false
    echo "Server stopped"
  ]
__TRASHTALK_SOURCE_EOF__
}

__HttpServer__port() {
  echo "$(_ivar port)"; return
}

__HttpServer__port_() {
  _ivar_set port "$1"
}

__HttpServer__getPort() {
  echo "$(_ivar port)"; return
}

__HttpServer__setPort_() {
  _ivar_set port "$1"
}
__HttpServer__root() {
  echo "$(_ivar root)"; return
}

__HttpServer__root_() {
  _ivar_set root "$1"
}

__HttpServer__getRoot() {
  echo "$(_ivar root)"; return
}

__HttpServer__setRoot_() {
  _ivar_set root "$1"
}

__HttpServer__class__new() {
    local id
    id=$(_generate_instance_id HttpServer)
    _create_instance HttpServer "$id"
    echo "$id"
}

__HttpServer__root_() {
  local path="$1"
  _ivar_set root "$path"
}

__HttpServer__port_() {
  local p="$1"
  _ivar_set port "$p"
}

__HttpServer__class__serveDirectory_onPort_() {
  local dir="$1"
  local port="$2"
    local server
    server=$(@ HttpServer new)
    @ "$server" root: "$dir"
    @ "$server" port: "$port"
    @ "$server" start
}

__HttpServer__start() {
    local port root pipe_dir request_pipe response_pipe
    port=$(_ivar port)
    root=$(_ivar root)

    # Validate root directory
    if [[ ! -d "$root" ]]; then
        echo "Error: Document root '$root' is not a directory" >&2
        return 1
    fi

    # Create named pipes for communication
    pipe_dir="/tmp/httpserver_$$"
    mkdir -p "$pipe_dir"
    request_pipe="$pipe_dir/request"
    response_pipe="$pipe_dir/response"
    mkfifo "$request_pipe" "$response_pipe"

    # Cleanup on exit
    trap "rm -rf '$pipe_dir'; exit" INT TERM EXIT

    echo "=== Trashtalk HTTP Server ==="
    echo "Port: $port"
    echo "Root: $root"
    echo "Press Ctrl+C to stop"
    echo ""

    _ivar_set running true

    # Main server loop using ncat-style handling
    while [[ "$(_ivar running)" == "true" ]]; do
        @ "$_RECEIVER" _handleConnection "$port" "$root"
    done

    rm -rf "$pipe_dir"
}

__HttpServer___handleConnection_root_() {
  local port="$1"
  local root="$2"
    local request method path version response_file
    local status_code status_text content_type body

    # Create a handler script that nc will execute
    local handler="/tmp/http_handler_$$.sh"
    cat >"$handler" <<'HANDLER_EOF'
#!/bin/bash
ROOT="$1"

# Read the request line
read -r request_line
method=$(echo "$request_line" | cut -d' ' -f1)
path=$(echo "$request_line" | cut -d' ' -f2)

# Read and discard headers until empty line
while IFS= read -r header; do
header="${header%%$'\r'}"
[[ -z "$header" ]] && break
done

# Security: prevent directory traversal
path="${path//\.\./}"

# Strip query string
path="${path%%\?*}"

# Default to index.html for directory requests
[[ "$path" == "/" ]] && path="/index.html"

# Build full file path
response_file="${ROOT}${path}"

# Log to stderr (visible in server output)
echo "[$(date '+%H:%M:%S')] $method $path" >&2

# Determine MIME type
get_mime_type () {
case "${1##*.}" in
html | htm) echo "text/html";;
css) echo "text/css";;
js) echo "application/javascript";;
json) echo "application/json";;
txt) echo "text/plain";;
xml) echo "application/xml";;
jpg | jpeg) echo "image/jpeg";;
png) echo "image/png";;
gif) echo "image/gif";;
svg) echo "image/svg+xml";;
ico) echo "image/x-icon";;
pdf) echo "application/pdf";;
*) echo "application/octet-stream";;
esac
}

# Send response
if [[ -f "$response_file" && -r "$response_file" ]]; then
content_type=$(get_mime_type "$response_file")
content_length=$(wc -c <"$response_file" | tr -d ' ')
printf "HTTP/1.1 200 OK\r\n"
printf "Content-Type: %s\r\n" "$content_type"
printf "Content-Length: %d\r\n" "$content_length"
printf "Connection: close\r\n"
printf "\r\n"
cat "$response_file"
else
body="<html><body><h1>404 Not Found</h1><p>File not found: $path</p></body></html>"
printf "HTTP/1.1 404 Not Found\r\n"
printf "Content-Type: text/html\r\n"
printf "Content-Length: %d\r\n" "${#body}"
printf "Connection: close\r\n"
printf "\r\n"
printf "%s" "$body"
fi
HANDLER_EOF
    chmod +x "$handler"

    # Use nc to handle one connection
    # BSD nc on macOS: nc -l <port> executes with stdin/stdout connected to client
    nc -l "$port" -c "$handler $root" 2>/dev/null || \
        { cat | "$handler" "$root"; } < <(nc -l "$port") 2>/dev/null || \
        @ "$_RECEIVER" _handleSimple "$port" "$root"

    rm -f "$handler"
}

__HttpServer___handleSimple_root_() {
  local port="$1"
  local root="$2"
    local request_file="/tmp/http_req_$$"
    local response_file="/tmp/http_resp_$$"

    # Capture request
    timeout 30 nc -l "$port" >"$request_file" 2>/dev/null &
    local nc_pid=$!
    wait $nc_pid 2>/dev/null

    if [[ -s "$request_file" ]]; then
        local request_line method path
        request_line=$(head -1 "$request_file")
        method=$(echo "$request_line" | cut -d' ' -f1)
        path=$(echo "$request_line" | cut -d' ' -f2)

        # Security and defaults
        path="${path//\.\./}"
        path="${path%%\?*}"
        [[ "$path" == "/" ]] && path="/index.html"

        echo "[$(date '+%H:%M:%S')] $method $path"

        local file_path="${root}${path}"

        # Build response
        if [[ -f "$file_path" ]]; then
            {
            printf "HTTP/1.1 200 OK\r\n"
            printf "Content-Type: %s\r\n" "$(@ "$_RECEIVER" _mimeType: "$file_path")"
            printf "Connection: close\r\n"
            printf "\r\n"
            cat "$file_path"
            } >"$response_file"
            else
            local body="<html><body><h1>404 Not Found</h1></body></html>"
            {
            printf "HTTP/1.1 404 Not Found\r\n"
            printf "Content-Type: text/html\r\n"
            printf "Connection: close\r\n"
            printf "\r\n"
            printf "%s" "$body"
            } >"$response_file"
        fi

        # Send response on next connection (client retries)
        cat "$response_file" | nc -l "$port" 2>/dev/null &
        sleep 0.2
    fi

    rm -f "$request_file" "$response_file"
}

__HttpServer___mimeType_() {
  local filepath="$1"
    local ext="${filepath##*.}"
    case "${ext,,}" in
        html | htm) echo "text/html";;
        css) echo "text/css";;
        js) echo "application/javascript";;
        json) echo "application/json";;
        txt) echo "text/plain";;
        xml) echo "application/xml";;
        jpg | jpeg) echo "image/jpeg";;
        png) echo "image/png";;
        gif) echo "image/gif";;
        svg) echo "image/svg+xml";;
        ico) echo "image/x-icon";;
        pdf) echo "application/pdf";;
        woff) echo "font/woff";;
        woff2) echo "font/woff2";;
        ttf) echo "font/ttf";;
        *) echo "application/octet-stream";;
    esac
}

__HttpServer__stop() {
  _ivar_set running false
  echo "Server stopped"
}
