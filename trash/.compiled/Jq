#!/usr/bin/env bash
# Generated by Trashtalk Compiler (jq) - DO NOT EDIT
# Source: Jq.trash
# Generated: 2026-01-09T16:02:04

__Tools__Jq__superclass="Tool"
__Tools__Jq__instanceVars=""
__Tools__Jq__classInstanceVars=""
__Tools__Jq__traits=""
__Tools__Jq__sourceHash="d21c7e65987d4b49e27e01fa69a044f688889ee8cf9f07e8971871aa5c6b57a2"
__Tools__Jq__package="Tools"
__Tools__Jq__qualifiedName="Tools::Jq"

__Tools__Jq__source() {
  cat <<'__TRASHTALK_SOURCE_EOF__'
# Tools::Jq - Wrapper for the jq JSON processor
# Example of how to subclass Tool for a specific external program
#
# Usage:
#   @ Tools::Jq ensure
#   @ Tools::Jq parse: '.name' on: '{"name": "test"}'
#
package: Tools

Jq subclass: Tool

  classMethod: name [
    ^ "jq"
  ]

  classMethod: installCommand [
    ^ "brew install jq"
  ]

  # Parse JSON with a jq filter
  rawClassMethod: parse: filter on: json [
    local tool_path
    tool_path=$(@ "$_CLASS" path)
    if [[ -z "$tool_path" ]]; then
      _throw "ToolError" "jq is not installed"
      return 1
    fi
    echo "$2" | "$tool_path" "$1"
  ]

  # Parse JSON from a file
  rawClassMethod: parseFile: filepath with: filter [
    local tool_path
    tool_path=$(@ "$_CLASS" path)
    if [[ -z "$tool_path" ]]; then
      _throw "ToolError" "jq is not installed"
      return 1
    fi
    "$tool_path" "$2" "$1"
  ]

  # Compact output (no pretty printing)
  rawClassMethod: compact: json [
    local tool_path
    tool_path=$(@ "$_CLASS" path)
    if [[ -z "$tool_path" ]]; then
      _throw "ToolError" "jq is not installed"
      return 1
    fi
    echo "$1" | "$tool_path" -c '.'
  ]

  # Get a specific key from JSON
  rawClassMethod: get: key from: json [
    local tool_path
    tool_path=$(@ "$_CLASS" path)
    if [[ -z "$tool_path" ]]; then
      _throw "ToolError" "jq is not installed"
      return 1
    fi
    echo "$2" | "$tool_path" -r ".$1"
  ]
__TRASHTALK_SOURCE_EOF__
}

__Tools__Jq__class__name() {
  echo "jq"
}

__Tools__Jq__class__installCommand() {
  echo "brew install jq"
}

__Tools__Jq__class__parse_on_() {
  local filter="$1"
  local json="$2"
    local tool_path
    tool_path=$(@ "$_CLASS" path)
    if [[ -z "$tool_path" ]]; then
        _throw "ToolError" "jq is not installed"
        return 1
    fi
    echo "$2" | "$tool_path" "$1"
}

__Tools__Jq__class__parseFile_with_() {
  local filepath="$1"
  local filter="$2"
    local tool_path
    tool_path=$(@ "$_CLASS" path)
    if [[ -z "$tool_path" ]]; then
        _throw "ToolError" "jq is not installed"
        return 1
    fi
    "$tool_path" "$2" "$1"
}

__Tools__Jq__class__compact_() {
  local json="$1"
    local tool_path
    tool_path=$(@ "$_CLASS" path)
    if [[ -z "$tool_path" ]]; then
        _throw "ToolError" "jq is not installed"
        return 1
    fi
    echo "$1" | "$tool_path" -c '.'
}

__Tools__Jq__class__get_from_() {
  local key="$1"
  local json="$2"
    local tool_path
    tool_path=$(@ "$_CLASS" path)
    if [[ -z "$tool_path" ]]; then
        _throw "ToolError" "jq is not installed"
        return 1
    fi
    echo "$2" | "$tool_path" -r ".$1"
}
