#!/usr/bin/env bash
# Generated by Trashtalk Compiler (jq) - DO NOT EDIT
# Source: IDE.trash
# Generated: 2026-01-09T21:43:35

__IDE__superclass="Object"
__IDE__instanceVars="session: outputView: inputField: layout:"
__IDE__classInstanceVars=""
__IDE__traits=""
__IDE__sourceHash="e8f6028253aea7c9c874eff4cc80b53ae0d373020f5e3af91ffadb4a5a665226"

__IDE__source() {
  cat <<'__TRASHTALK_SOURCE_EOF__'
IDE subclass: Object
  instanceVars: session:'' outputView:'' inputField:'' layout:''

  rawClassMethod: open [
    local ide session
    echo "[IDE] open called" >&2
    ide=$(@ IDE new)
    echo "[IDE] Created instance: $ide" >&2
    session=$(@ YutaniSession connect 2>&1 | grep -v "^\[INFO\]" | tail -1)
    echo "[IDE] Session: $session" >&2

    if [[ -z "$session" ]] || echo "$session" | grep -qi error; then
      echo "Error: Could not connect to Yutani server" >&2
      return 1
    fi

    @ "$ide" setSession: "$session"
    @ "$ide" setup
    @ "$ide" runEventLoop
  ]

  method: setSession: s [
    session := s
  ]

  rawMethod: setup [
    local session output_view input_field layout
    session="$(_ivar session)"

    # Create vertical layout
    layout=$(@ "$session" createVerticalLayout)
    _ivar_set layout "$layout"

    # Create output view
    output_view=$(@ "$session" createTextView: 'Transcript')
    _ivar_set outputView "$output_view"
    @ "$session" setText: "Trashtalk IDE - Type code and press Enter" on: "$output_view"

    # Create input field
    input_field=$(@ "$session" createInputFieldWithPlaceholder: '>' placeholder: 'Enter code...')
    _ivar_set inputField "$input_field"

    # Add to layout
    @ "$session" addChild: "$output_view" to: "$layout"
    @ "$session" addChild: "$input_field" to: "$layout" fixedSize: 3 focus: true

    @ "$session" setRoot: "$layout"

    echo "[IDE] Setup complete. Output=$output_view Input=$input_field" >&2
  ]

  rawMethod: runEventLoop [
    local session
    session="$(_ivar session)"

    echo "[IDE] runEventLoop starting" >&2
    echo "[IDE] Session: $session" >&2

    # Store receiver in global for handler to access
    __IDE_INSTANCE="$_RECEIVER"

    # Start event stream
    @ "$session" startEventStream
    echo "[IDE] Event stream started" >&2

    # Process events - handler reads from $__COPROC_LINE (set by Coproc)
    @ "$session" onEventDo: '@ "$__IDE_INSTANCE" handleEvent'

    # Cleanup (onEventDo: returns when stream ends)
    @ "$session" disconnect
    echo "[IDE] Done." >&2
  ]

  # Handle a single event line (reads from $__COPROC_LINE)
  rawMethod: handleEvent [
    local session key_name eventLine
    session="$(_ivar session)"
    eventLine="$__COPROC_LINE"

    echo "[IDE:handleEvent] Called with line: ${eventLine:0:60}..." >&2

    # Skip non-JSON lines
    if ! echo "$eventLine" | jq -e . >/dev/null 2>&1; then
      echo "[IDE:handleEvent] Skipping non-JSON" >&2
      return
    fi

    # Handle key events
    if echo "$eventLine" | jq -e '.key' >/dev/null 2>&1; then
      key_name=$(echo "$eventLine" | jq -r '.key.key // ""')
      echo "[IDE] Key: $key_name" >&2

      case "$key_name" in
        KEY_ENTER)
          @ "$_RECEIVER" doEval
          ;;
        KEY_CTRL_C|KEY_CTRL_D)
          echo "[IDE] Exiting..." >&2
          @ "$session" stopEventStream
          ;;
      esac
    fi
  ]

  rawMethod: doEval [
    local session input_field output_view text result history
    session="$(_ivar session)"
    input_field="$(_ivar inputField)"
    output_view="$(_ivar outputView)"

    echo "[IDE] doEval called" >&2

    # Get current input text
    text=$(@ "$session" getInputText: "$input_field")
    echo "[IDE] Input text: [$text]" >&2

    if [[ -z "$text" ]]; then
      echo "[IDE] Empty input, skipping" >&2
      return
    fi

    # Evaluate
    echo "[IDE] Evaluating..." >&2
    result=$(@ Trash eval: "$text" 2>&1)
    echo "[IDE] Result: $result" >&2

    # Update output
    history="> $text
$result

"
    @ "$session" setText: "$history" on: "$output_view"

    # Clear input
    @ "$session" setInputText: '' on: "$input_field"

    echo "[IDE] doEval complete" >&2
  ]
__TRASHTALK_SOURCE_EOF__
}

__IDE__session() {
  echo "$(_ivar session)"; return
}

__IDE__session_() {
  _ivar_set session "$1"
}

__IDE__getSession() {
  echo "$(_ivar session)"; return
}

__IDE__setSession_() {
  _ivar_set session "$1"
}
__IDE__outputView() {
  echo "$(_ivar outputView)"; return
}

__IDE__outputView_() {
  _ivar_set outputView "$1"
}

__IDE__getOutputView() {
  echo "$(_ivar outputView)"; return
}

__IDE__setOutputView_() {
  _ivar_set outputView "$1"
}
__IDE__inputField() {
  echo "$(_ivar inputField)"; return
}

__IDE__inputField_() {
  _ivar_set inputField "$1"
}

__IDE__getInputField() {
  echo "$(_ivar inputField)"; return
}

__IDE__setInputField_() {
  _ivar_set inputField "$1"
}
__IDE__layout() {
  echo "$(_ivar layout)"; return
}

__IDE__layout_() {
  _ivar_set layout "$1"
}

__IDE__getLayout() {
  echo "$(_ivar layout)"; return
}

__IDE__setLayout_() {
  _ivar_set layout "$1"
}

__IDE__class__open() {
    local ide session
    echo "[IDE] open called" >&2
    ide=$(@ IDE new)
    echo "[IDE] Created instance: $ide" >&2
    session=$(@ YutaniSession connect 2>&1 | grep -v "^\[INFO\]" | tail -1)
    echo "[IDE] Session: $session" >&2

    if [[ -z "$session" ]] || echo "$session" | grep -qi error; then
        echo "Error: Could not connect to Yutani server" >&2
        return 1
    fi

    @ "$ide" setSession: "$session"
    @ "$ide" setup
    @ "$ide" runEventLoop
}

__IDE__setSession_() {
  local s="$1"
  _ivar_set session "$s"
}

__IDE__setup() {
    local session output_view input_field layout
    session="$(_ivar session)"

    # Create vertical layout
    layout=$(@ "$session" createVerticalLayout)
    _ivar_set layout "$layout"

    # Create output view
    output_view=$(@ "$session" createTextView: 'Transcript')
    _ivar_set outputView "$output_view"
    @ "$session" setText: "Trashtalk IDE - Type code and press Enter" on: "$output_view"

    # Create input field
    input_field=$(@ "$session" createInputFieldWithPlaceholder: '>' placeholder: 'Enter code...')
    _ivar_set inputField "$input_field"

    # Add to layout
    @ "$session" addChild: "$output_view" to: "$layout"
    @ "$session" addChild: "$input_field" to: "$layout" fixedSize: 3 focus: true

    @ "$session" setRoot: "$layout"

    echo "[IDE] Setup complete. Output=$output_view Input=$input_field" >&2
}

__IDE__runEventLoop() {
    local session
    session="$(_ivar session)"

    echo "[IDE] runEventLoop starting" >&2
    echo "[IDE] Session: $session" >&2

    # Store receiver in global for handler to access
    __IDE_INSTANCE="$_RECEIVER"

    # Start event stream
    @ "$session" startEventStream
    echo "[IDE] Event stream started" >&2

    # Process events - handler reads from $__COPROC_LINE (set by Coproc)
    @ "$session" onEventDo: '@ "$__IDE_INSTANCE" handleEvent'

    # Cleanup (onEventDo: returns when stream ends)
    @ "$session" disconnect
    echo "[IDE] Done." >&2
}

__IDE__handleEvent() {
    local session key_name eventLine
    session="$(_ivar session)"
    eventLine="$__COPROC_LINE"

    echo "[IDE:handleEvent] Called with line: ${eventLine:0:60}..." >&2

    # Skip non-JSON lines
    if ! echo "$eventLine" | jq -e . >/dev/null 2>&1; then
        echo "[IDE:handleEvent] Skipping non-JSON" >&2
        return
    fi

    # Handle key events
    if echo "$eventLine" | jq -e '.key' >/dev/null 2>&1; then
        key_name=$(echo "$eventLine" | jq -r '.key.key // ""')
        echo "[IDE] Key: $key_name" >&2

        case "$key_name" in
            KEY_ENTER)
            @ "$_RECEIVER" doEval
        ;;
            KEY_CTRL_C | KEY_CTRL_D)
            echo "[IDE] Exiting..." >&2
            @ "$session" stopEventStream
        ;;
        esac
    fi
}

__IDE__doEval() {
    local session input_field output_view text result history
    session="$(_ivar session)"
    input_field="$(_ivar inputField)"
    output_view="$(_ivar outputView)"

    echo "[IDE] doEval called" >&2

    # Get current input text
    text=$(@ "$session" getInputText: "$input_field")
    echo "[IDE] Input text: [$text]" >&2

    if [[ -z "$text" ]]; then
        echo "[IDE] Empty input, skipping" >&2
        return
    fi

    # Evaluate
    echo "[IDE] Evaluating..." >&2
    result=$(@ Trash eval: "$text" 2>&1)
    echo "[IDE] Result: $result" >&2

    # Update output
    history="> $text
    $result

    "
    @ "$session" setText: "$history" on: "$output_view"

    # Clear input
    @ "$session" setInputText: '' on: "$input_field"

    echo "[IDE] doEval complete" >&2
}
