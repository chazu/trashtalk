#!/usr/bin/env bash
# Generated by Trashtalk Compiler (jq) - DO NOT EDIT
# Source: Trash.trash
# Generated: 2025-12-22T03:23:46

__Trash__superclass="Object"
__Trash__instanceVars=""
__Trash__classInstanceVars=""
__Trash__traits="Debuggable"

__Trash__info() {
  echo "=== Trash System Information ==="
  echo "Version: 0.1.0"
  echo "Directory: $TRASHDIR"
  echo "Objects: $(@ $_RECEIVER listObjects | wc -l)"
  echo "Traits: $(@ $_RECEIVER listTraits | wc -l)"
  echo "Active Processes: $(@ Process listProcesses | wc -l)"
  echo "KV Store: $KV_USER_DIR"
}

__Trash__listObjects() {
  find "$TRASHDIR" -maxdepth 1 -type f ! -path "*/traits/*" | while read -r file; do
  basename "$file"
  done | grep -v '\.trash$' | grep -v '\.legacy$' | sort
}

__Trash__listTraits() {
  if [[ -d "$TRASHDIR/traits" ]]; then
  find "$TRASHDIR/traits" -type f | while read -r file; do
  basename "$file"
  done | sort
  fi
}

__Trash__methodsFor_() {
  local class_name="$1"
    local compiled_file="$TRASHDIR/.compiled/$class_name"
    local runtime_file="$TRASHDIR/$class_name"

    # Check for compiled or runtime class file
    if [[ -f "$compiled_file" ]]; then
        source "$compiled_file"
        elif [[ -f "$runtime_file" ]]; then
            source "$runtime_file"
            else
            echo "Class $class_name not found"
            return 1
        fi

        echo "Methods for $class_name:"
        # List functions defined for this class
        declare -F | awk '{print $3}' | grep "^__${class_name}__" | grep -v "__class__" | sed "s/__${class_name}__/ /"

        # Show class methods
        echo "Class methods:"
        declare -F | awk '{print $3}' | grep "^__${class_name}__class__" | sed "s/__${class_name}__class__/ /"

        # Show inherited methods
        local super_var="__${class_name}__superclass"
        local superclass="${!super_var:-}"
        if [[ -n "$superclass" && "$superclass" != "nil" && "$superclass" != "Object" ]]; then
            echo ""
            echo "(inherited from $superclass)"
            @ "$_RECEIVER" methodsFor: "$superclass" | sed 's/^/ /'
        fi
}

__Trash__methodsIn_category_() {
  local class_name="$1"
  local cat_name="$2"
    # Get compiled class metadata
    local compiled_file="$TRASHDIR/.compiled/$class_name"
    if [[ ! -f "$compiled_file" ]]; then
        echo "Error: Class $class_name not found"
        return 1
    fi

    # Source the class to get metadata
    source "$compiled_file"

    # Get method categories metadata
    local cats_var="__${class_name}__methodCategories"
    local cats="${!cats_var:-}"

    if [[ -z "$cats" ]]; then
        echo "No categorized methods for $class_name"
        return 0
    fi

    # Parse and filter by category
    echo "Methods in '$cat_name' for $class_name:"
    for entry in $cats; do
        local method="${entry%%:*}"
        local category="${entry#*:}"
        if [[ "$category" == "$cat_name" ]]; then
            echo " $method"
        fi
    done
}

__Trash__categoriesFor_() {
  local class_name="$1"
    # Get compiled class metadata
    local compiled_file="$TRASHDIR/.compiled/$class_name"
    if [[ ! -f "$compiled_file" ]]; then
        echo "Error: Class $class_name not found"
        return 1
    fi

    # Source the class to get metadata
    source "$compiled_file"

    # Get method categories metadata
    local cats_var="__${class_name}__methodCategories"
    local cats="${!cats_var:-}"

    if [[ -z "$cats" ]]; then
        echo "No categories for $class_name"
        return 0
    fi

    # Extract unique categories
    echo "Categories for $class_name:"
    local seen=""
    for entry in $cats; do
        local category="${entry#*:}"
        if [[ ! " $seen " =~ " $category " ]]; then
            echo " $category"
            seen="$seen $category"
        fi
    done
}

__Trash__hierarchyFor_() {
  local class_name="$1"
    local compiled_file="$TRASHDIR/.compiled/$class_name"
    local runtime_file="$TRASHDIR/$class_name"

    if [[ -f "$compiled_file" || -f "$runtime_file" ]]; then
        echo "Inheritance hierarchy for $class_name:"
        @ "$_RECEIVER" _showHierarchy: "$class_name" depth: 0
        else
        echo "Class $class_name not found"
        return 1
    fi
}

__Trash___showHierarchy_depth_() {
  local class_name="$1"
  local depth="$2"
    local indent="" i superclass super_var
    local compiled_file="$TRASHDIR/.compiled/$class_name"
    local runtime_file="$TRASHDIR/$class_name"

    for ((i=0; i<depth; i++)); do
        indent=" $indent"
    done
    echo "$indent$class_name"

    # Source class to get metadata
    if [[ -f "$compiled_file" ]]; then
        source "$compiled_file"
        elif [[ -f "$runtime_file" ]]; then
            source "$runtime_file"
            else
            return 0
        fi

        # Get superclass from metadata
        super_var="__${class_name}__superclass"
        superclass="${!super_var:-}"
        if [[ -n "$superclass" && "$superclass" != "nil" ]]; then
            @ "$_RECEIVER" _showHierarchy: "$superclass" depth: $((depth + 1))
        fi
}

__Trash__createObject_super_() {
  local object_name="$1"
  local superclass="$2"
    local trash_file="$TRASHDIR/${object_name}.trash"
    superclass="${superclass:-Object}"

    if [[ -f "$trash_file" ]]; then
        echo "Class $object_name already exists"
        return 1
    fi

    cat >"$trash_file" <<EOF
# $object_name - Created by Trash system
$object_name subclass: $superclass

rawMethod: example [
echo "Hello from $object_name"
]

rawClassMethod: new [
local id = \$(_generate_instance_id "$object_name")
_create_instance "$object_name" "\$id"
echo "\$id"
]
EOF

    echo "Created $trash_file (inherits from $superclass)"
    echo "Compiling..."
    "$SCRIPT_DIR/jq-compiler/driver.bash" compile "$trash_file" >"$TRASHDIR/.compiled/$object_name" 2>/dev/null
    cp "$TRASHDIR/.compiled/$object_name" "$TRASHDIR/$object_name"
    source "$TRASHDIR/.compiled/$object_name"
    echo "✓ $object_name ready to use"
}

__Trash__removeObject_() {
  local object_name="$1"
  local object_file confirmation
  object_file="$TRASHDIR/$object_name"
  if [[ ! -f "$object_file" ]]; then
  echo "Object $object_name not found"
  return 1
  fi
  echo "Are you sure you want to remove object $object_name? (y/N)"
  read -r confirmation
  if [[ "$confirmation" =~ ^[Yy]$ ]]; then
  rm "$object_file"
  echo "Removed object $object_name"
  kvdel "$object_name" 2>/dev/null || true
  else
  echo "Cancelled"
  fi
}

__Trash__reload() {
  echo "Reloading all object stubs..."
  initialize_trash
  echo "Reload complete"
}

__Trash__reloadClass_() {
  local class_name="$1"
    if [[ -z "$class_name" ]]; then
        echo "Usage: @ Trash reloadClass <ClassName>"
        return 1
    fi

    local compiled_file="$TRASHDIR/.compiled/$class_name"
    local class_file="$TRASHDIR/$class_name"
    local trait_file="$TRASHDIR/traits/$class_name"
    local compiled_trait="$TRASHDIR/.compiled/traits/$class_name"

    # Clear the sourcing cache so the class will be re-sourced
    _clear_class_cache "$class_name"

    # Check if it's a trait
    if [[ -f "$compiled_trait" ]]; then
        echo "Reloading trait $class_name..."
        # Unset old trait functions
        while IFS= read -r func; do
            unset -f "$func" 2>/dev/null
        done < <(declare -F | awk '{print $3}' | grep "^__${class_name}__")
            # Source the compiled trait
            source "$compiled_trait"
            _mark_class_sourced "$class_name"
            cp "$compiled_trait" "$trait_file"
            echo "✓ Trait $class_name reloaded"
            return 0
        fi

        # Check for compiled class
        if [[ -f "$compiled_file" ]]; then
            echo "Reloading class $class_name..."
            # Unset old class functions
            while IFS= read -r func; do
                unset -f "$func" 2>/dev/null
            done < <(declare -F | awk '{print $3}' | grep "^__${class_name}__")
                # Source the compiled class
                source "$compiled_file"
                _mark_class_sourced "$class_name"
                cp "$compiled_file" "$class_file"
                echo "✓ Class $class_name reloaded"
                return 0
            fi

            # Fall back to legacy class file
            if [[ -f "$class_file" ]]; then
                echo "Reloading legacy class $class_name..."
                source "$class_file"
                _mark_class_sourced "$class_name"
                echo "✓ Legacy class $class_name reloaded"
                return 0
            fi

            echo "Error: Class $class_name not found"
            echo "Searched:"
            echo " - $compiled_file"
            echo " - $compiled_trait"
            echo " - $class_file"
            return 1
}

__Trash__compileAndReload_() {
  local class_name="$1"
    if [[ -z "$class_name" ]]; then
        echo "Usage: @ Trash compileAndReload <ClassName>"
        return 1
    fi

    local source_file="$TRASHDIR/${class_name}.trash"
    local trait_source="$TRASHDIR/traits/${class_name}.trash"
    local target_file=""
    local file_to_compile=""
    local temp_file="/tmp/trash_compile_$$_${class_name}"

    # Find source file and determine target
    if [[ -f "$trait_source" ]]; then
    file_to_compile="$trait_source"
        target_file="$TRASHDIR/.compiled/traits/$class_name"
        echo "Compiling trait $class_name..."
        elif [[ -f "$source_file" ]]; then
        file_to_compile="$source_file"
            target_file="$TRASHDIR/.compiled/$class_name"
            echo "Compiling class $class_name..."
            else
            echo "Error: No source file found for $class_name"
            echo "Searched:"
            echo " - $source_file"
            echo " - $trait_source"
            return 1
        fi

        # Compile to temp file
        if ! "$SCRIPT_DIR/jq-compiler/driver.bash" compile "$file_to_compile" >"$temp_file" 2>&1; then
            echo "Compilation failed:"
            cat "$temp_file"
            rm -f "$temp_file"
            return 1
        fi

        # Validate bash syntax
        if ! bash -n "$temp_file" 2>&1; then
            echo "Syntax validation failed - class not updated"
            rm -f "$temp_file"
            return 1
        fi

        # Success - replace the compiled file
        mv "$temp_file" "$target_file"
        @ "$_RECEIVER" reloadClass "$class_name"
        return $?
}

__Trash__stats() {
  echo "=== Trash System Statistics ==="
  echo "Objects: $(@ $_RECEIVER listObjects | wc -l)"
  echo "Traits: $(@ $_RECEIVER listTraits | wc -l)"
  echo "KV entries: $(kvlist 2>/dev/null | wc -l)"
  echo "Active processes: $(@ Process listProcesses 2>/dev/null | wc -l)"
  echo "Memory usage: $(du -sh "$TRASHDIR" | cut -f1)"
  echo "KV store size: $(du -sh "$KV_USER_DIR" 2>/dev/null | cut -f1 || echo "0B")"
}

__Trash__cleanup() {
  echo "Cleaning up trash system..."
  @ Process listProcesses >/dev/null 2>&1
  echo "Cleanup complete"
}

__Trash__showStack() {
  local stack count i frame_id frame_data receiver selector args
  _ensure_stack
  stack=$(kvget _stack 2>/dev/null)
  if [[ -z "$stack" || "$stack" == "[]" ]]; then
  echo "Call stack is empty"
  return 0
  fi
  count=$(echo "$stack" | jq 'length')
  echo "=== Call Stack ($count frames) ==="
  for ((i=count-1; i>=0; i--)); do
  frame_id=$(echo "$stack" | jq -r ".[$i]")
  frame_data=$(kvget "$frame_id" 2>/dev/null)
  if [[ -n "$frame_data" ]]; then
  receiver=$(echo "$frame_data" | jq -r '.args.receiver // "?"')
  selector=$(echo "$frame_data" | jq -r '.args.selector // "?"')
  args=$(echo "$frame_data" | jq -r '.args.args // ""')
  echo " [$i] $receiver >> $selector $args"
  else
  echo " [$i] $frame_id (frame data missing)"
  fi
  done
  echo ""
  echo "Enable stack frames with: export TRASH_STACK_FRAMES=1"
}

__Trash__clearStack() {
  local stack frame_id
  _ensure_stack
  stack=$(kvget _stack 2>/dev/null)
  if [[ -z "$stack" || "$stack" == "[]" ]]; then
  echo "Stack already empty"
  return 0
  fi
  echo "$stack" | jq -r '.[]' 2>/dev/null | while read -r frame_id; do
  if [[ -n "$frame_id" ]]; then
  kvdel "$frame_id" 2>/dev/null
  fi
  done
  kvset _stack "[]"
  echo "Stack cleared"
}

__Trash__stackDepth() {
  local stack
  _ensure_stack
  stack=$(kvget _stack 2>/dev/null)
  if [[ -z "$stack" ]]; then
  echo "0"
  else
  echo "$stack" | jq 'length'
  fi
}

__Trash__help() {
  echo "=== Trash System Commands ==="
  echo "@ Trash info - Show system information"
  echo "@ Trash listObjects - List all objects"
  echo "@ Trash listTraits - List all traits"
  echo "@ Trash methodsFor <object> - Show methods for object"
  echo "@ Trash hierarchyFor <object> - Show inheritance hierarchy"
  echo "@ Trash new <class> - Create class skeleton and edit"
  echo "@ Trash edit <class> - Edit class and recompile on save"
  echo "@ Trash createObject <name> [super] - Create new object (no edit)"
  echo "@ Trash removeObject <name> - Remove object"
  echo "@ Trash reload - Reload all object stubs"
  echo "@ Trash reloadClass <class> - Hot reload a single class"
  echo "@ Trash compileAndReload <class> - Compile and reload from .trash"
  echo "@ Trash stats - Show system statistics"
  echo "@ Trash cleanup - Clean up system"
  echo "@ Trash version - Show version information"
  echo "@ Trash inspect <object> - Detailed object inspection"
  echo "@ Trash repl - Launch interactive REPL"
  echo ""
  echo "=== Instance Queries (use class methods) ==="
  echo "@ <Class> findAll - Find all instances of class"
  echo "@ <Class> find '<predicate>' - Find with predicate"
  echo "@ <Class> count - Count instances of class"
  echo "@ Store listClasses - List classes with instances"
  echo ""
  echo "=== Debugging ==="
  echo "@ Trash showStack - Show current call stack"
  echo "@ Trash clearStack - Clear call stack"
}

__Trash__version() {
  echo "Trash System v$TRASH_VERSION"
  echo "Author: $TRASH_AUTHOR"
  echo "Description: $TRASH_DESCRIPTION"
  echo "Bash version: $BASH_VERSION"
  echo "System: $(uname -s) $(uname -r)"
}

__Trash__class__repl() {
    local trashtalk_root
    trashtalk_root="$(dirname "$TRASHDIR")"
    "$trashtalk_root/bin/trash-repl"
}

__Trash__inspect_() {
  local object_name="$1"
  local object_file traits state
  if [[ -z "$object_name" ]]; then
  echo "Usage: @ Trash inspect <object_name>"
  return 1
  fi
  echo "=== Detailed Inspection: $object_name ==="
  object_file="$TRASHDIR/$object_name"
  if [[ ! -f "$object_file" ]]; then
  echo "Object $object_name not found"
  return 1
  fi
  echo "File: $object_file"
  echo "Size: $(wc -l < "$object_file") lines"
  echo "Modified: $(stat -f "%Sm" "$object_file" 2>/dev/null || stat -c "%y" "$object_file" 2>/dev/null)"
  echo ""
  @ "$_RECEIVER" hierarchyFor: "$object_name"
  echo ""
  @ "$_RECEIVER" methodsFor: "$object_name"
  echo ""
  traits=$(grep "^include" "$object_file" | awk '{print $2}')
  if [[ -n "$traits" ]]; then
  echo "Traits:"
  echo "$traits" | sed 's/^/ /'
  else
  echo "Traits: none"
  fi
  echo ""
  state=$(kvget "$object_name" 2>/dev/null)
  if [[ -n "$state" ]]; then
  echo "Persistent state:"
  echo "$state" | jq .2>/dev/null || echo "$state"
  else
  echo "Persistent state: none"
  fi
}

__Trash__new_() {
  local class_name="$1"
    local trash_file="$TRASHDIR/${class_name}.trash"

    if [[ -f "$trash_file" ]]; then
        echo "Class $class_name already exists. Use '@ Trash edit $class_name' to edit."
        return 1
    fi

    # Create minimal skeleton (using printf to avoid heredoc stdin issues)
    printf '%s\n' \
        "$class_name subclass: Object" \
        " instanceVars:" \
        "" \
        " rawClassMethod: new [" \
        " local id=\$(_generate_instance_id $class_name)" \
        " _create_instance $class_name \" \$id \"" \
        " echo \" \$id \"" \
        " ]" \
        "" \
        " method: example [" \
        " ^ \" Hello from $class_name \"" \
        " ]" \
        >"$trash_file"

    echo "Created $trash_file"

    # Open in editor and compile if saved
    local before_mtime after_mtime
    before_mtime=$(stat -f "%m" "$trash_file" 2>/dev/null || stat -c "%Y" "$trash_file" 2>/dev/null)

    ${EDITOR:-vi} "$trash_file" </dev/tty >/dev/tty

    after_mtime=$(stat -f "%m" "$trash_file" 2>/dev/null || stat -c "%Y" "$trash_file" 2>/dev/null)

    if [[ "$before_mtime" != "$after_mtime" ]]; then
        echo "File modified, compiling..."
        @ "$_RECEIVER" compileAndReload "$class_name"
        else
        echo "No changes detected"
    fi
}

__Trash__edit_() {
  local class_name="$1"
    local trash_file="$TRASHDIR/${class_name}.trash"
    local trait_file="$TRASHDIR/traits/${class_name}.trash"
    local file_to_edit=""

    # Find the source file
    if [[ -f "$trash_file" ]]; then
    file_to_edit="$trash_file"
        elif [[ -f "$trait_file" ]]; then
        file_to_edit="$trait_file"
            else
            echo "Error: No source file found for $class_name"
            echo "Searched:"
            echo " - $trash_file"
            echo " - $trait_file"
            echo ""
            echo "Use '@ Trash new $class_name' to create a new class."
            return 1
        fi

        # Open in editor and compile if saved
        local before_mtime after_mtime
        before_mtime=$(stat -f "%m" "$file_to_edit" 2>/dev/null || stat -c "%Y" "$file_to_edit" 2>/dev/null)

        ${EDITOR:-vi} "$file_to_edit" </dev/tty >/dev/tty

        after_mtime=$(stat -f "%m" "$file_to_edit" 2>/dev/null || stat -c "%Y" "$file_to_edit" 2>/dev/null)

        if [[ "$before_mtime" != "$after_mtime" ]]; then
            echo "File modified, compiling..."
            @ "$_RECEIVER" compileAndReload "$class_name"
            else
            echo "No changes detected"
        fi
}

__Trash__quickCreate_template_() {
  local class_name="$1"
  local template="$2"
    template="${template:-basic}"
    local trash_file="$TRASHDIR/${class_name}.trash"

    if [[ -f "$trash_file" ]]; then
        echo "Class $class_name already exists"
        return 1
    fi

    case "$template" in
        "service")
        cat >"$trash_file" <<EOF
# $class_name - Service template
$class_name subclass: Object
include: Debuggable

rawMethod: start [
@ self debug: "Starting service..."
echo "Service started"
]

rawMethod: stop [
@ self debug: "Stopping service..."
echo "Service stopped"
]

rawMethod: status [
echo "Service is running"
]

rawMethod: restart [
@ "\$_RECEIVER" stop
@ "\$_RECEIVER" start
]

rawClassMethod: new [
local id = \$(_generate_instance_id "$class_name")
_create_instance "$class_name" "\$id"
echo "\$id"
]
EOF
    ;;
        "actor")
        cat >"$trash_file" <<EOF
# $class_name - Actor template (for use with Process)
$class_name subclass: Object
include: Debuggable
instanceVars: status: active

rawMethod: receive: message [
@ self debug: "Received message: \$message"
case "\$message" in
"ping") echo "pong";;
"status") echo "active";;
*) echo "Unknown message: \$message";;
esac
]

rawMethod: initialize [
@ self debug: "Actor initialized"
]

rawClassMethod: new [
local id = \$(_generate_instance_id "$class_name")
_create_instance "$class_name" "\$id"
echo "\$id"
]
EOF
    ;;
        *)
        # Basic template
        cat >"$trash_file" <<EOF
# $class_name - Created by Trash system
$class_name subclass: Object

rawMethod: example [
echo "Hello from $class_name"
]

rawClassMethod: new [
local id = \$(_generate_instance_id "$class_name")
_create_instance "$class_name" "\$id"
echo "\$id"
]
EOF
    ;;
    esac

    echo "Created $trash_file using $template template"
    echo "Compiling..."
    mkdir -p "$TRASHDIR/.compiled"
    "$SCRIPT_DIR/jq-compiler/driver.bash" compile "$trash_file" >"$TRASHDIR/.compiled/$class_name" 2>/dev/null
    cp "$TRASHDIR/.compiled/$class_name" "$TRASHDIR/$class_name"
    source "$TRASHDIR/.compiled/$class_name"
    echo "✓ $class_name ready to use"
}
