#!/bin/bash
# Generated by Trashtalk Compiler (jq) - DO NOT EDIT
# Source: Trash.trash
# Generated: 2025-12-18T19:38:41

__Trash__superclass="Object"
__Trash__instanceVars=""
__Trash__classInstanceVars=""
__Trash__traits="Debuggable"

__Trash__info() {
  echo "=== Trash System Information ==="
  echo "Version: 0.1.0"
  echo "Directory: $TRASHDIR"
  echo "Objects: $(@ $_RECEIVER listObjects | wc -l)"
  echo "Traits: $(@ $_RECEIVER listTraits | wc -l)"
  echo "Active Processes: $(@ Process listProcesses | wc -l)"
  echo "KV Store: $KV_USER_DIR"
}

__Trash__listObjects() {
  find "$TRASHDIR" -maxdepth 1 -type f ! -path "*/traits/*" | while read -r file; do
  basename "$file"
  done | grep -v '\.trash$' | grep -v '\.legacy$' | sort
}

__Trash__listTraits() {
  if [[ -d "$TRASHDIR/traits" ]]; then
  find "$TRASHDIR/traits" -type f | while read -r file; do
  basename "$file"
  done | sort
  fi
}

__Trash__methodsFor() {
  local object_name="$1"
  local object_file superclass
  object_file="$TRASHDIR/$object_name"
  if [[ -f "$object_file" ]]; then
  echo "Methods for $object_name:"
  get_fcn_list "$object_file" | sed 's/^/ /'
  superclass=$(grep "^is_a" "$object_file" | awk '{print $2}')
  if [[ -n "$superclass" && "$superclass" != "Object" ]]; then
  echo " (inherited from $superclass)"
  @ "$_RECEIVER" methodsFor "$superclass" | sed 's/^/ /'
  fi
  else
  echo "Object $object_name not found"
  return 1
  fi
}

__Trash__methodsIn_category() {
  local class_name="$1"
  local cat_name="$2"
    # Get compiled class metadata
    local compiled_file="$TRASHDIR/.compiled/$class_name"
    if [[ ! -f "$compiled_file" ]]; then
        echo "Error: Class $class_name not found"
        return 1
    fi

    # Source the class to get metadata
    source "$compiled_file"

    # Get method categories metadata
    local cats_var="__${class_name}__methodCategories"
    local cats="${!cats_var:-}"

    if [[ -z "$cats" ]]; then
        echo "No categorized methods for $class_name"
        return 0
    fi

    # Parse and filter by category
    echo "Methods in '$cat_name' for $class_name:"
    for entry in $cats; do
        local method="${entry%%:*}"
        local category="${entry#*:}"
        if [[ "$category" == "$cat_name" ]]; then
            echo " $method"
        fi
    done
}

__Trash__categoriesFor() {
  local class_name="$1"
    # Get compiled class metadata
    local compiled_file="$TRASHDIR/.compiled/$class_name"
    if [[ ! -f "$compiled_file" ]]; then
        echo "Error: Class $class_name not found"
        return 1
    fi

    # Source the class to get metadata
    source "$compiled_file"

    # Get method categories metadata
    local cats_var="__${class_name}__methodCategories"
    local cats="${!cats_var:-}"

    if [[ -z "$cats" ]]; then
        echo "No categories for $class_name"
        return 0
    fi

    # Extract unique categories
    echo "Categories for $class_name:"
    local seen=""
    for entry in $cats; do
        local category="${entry#*:}"
        if [[ ! " $seen " =~ " $category " ]]; then
            echo " $category"
            seen="$seen $category"
        fi
    done
}

__Trash__hierarchyFor() {
  local object_name="$1"
  local object_file
  object_file="$TRASHDIR/$object_name"
  if [[ -f "$object_file" ]]; then
  echo "Inheritance hierarchy for $object_name:"
  @ "$_RECEIVER" _showHierarchy_depth "$object_name" 0
  else
  echo "Object $object_name not found"
  return 1
  fi
}

__Trash___showHierarchy_depth() {
  local object_name="$1"
  local depth="$2"
  local indent i object_file superclass
  indent=""
  for ((i=0; i<depth; i++)); do
  indent=" $indent"
  done
  echo "$indent$object_name"
  object_file="$TRASHDIR/$object_name"
  if [[ -f "$object_file" ]]; then
  superclass=$(grep "^is_a" "$object_file" | awk '{print $2}')
  if [[ -n "$superclass" ]]; then
  @ "$_RECEIVER" _showHierarchy_depth "$superclass" $((depth + 1))
  fi
  fi
}

__Trash__createObject_super() {
  local object_name="$1"
  local superclass="$2"
    local object_file="$TRASHDIR/$object_name"
    superclass="${superclass:-Object}"

    if [[ -f "$object_file" ]]; then
        echo "Object $object_name already exists"
        return 1
    fi

    cat >"$object_file" <<EOF
is_a $superclass

# $object_name - Created by Trash system
# Add your methods below

example () {
echo "Hello from $object_name"
}
EOF

    echo "Created object $object_name (inherits from $superclass)"
    echo "Edit $object_file to add methods"
    create_object_stub "$object_name"
}

__Trash__removeObject() {
  local object_name="$1"
  local object_file confirmation
  object_file="$TRASHDIR/$object_name"
  if [[ ! -f "$object_file" ]]; then
  echo "Object $object_name not found"
  return 1
  fi
  echo "Are you sure you want to remove object $object_name? (y/N)"
  read -r confirmation
  if [[ "$confirmation" =~ ^[Yy]$ ]]; then
  rm "$object_file"
  echo "Removed object $object_name"
  kvdel "$object_name" 2>/dev/null || true
  else
  echo "Cancelled"
  fi
}

__Trash__reload() {
  echo "Reloading all object stubs..."
  initialize_trash
  echo "Reload complete"
}

__Trash__reloadClass() {
  local class_name="$1"
    if [[ -z "$class_name" ]]; then
        echo "Usage: @ Trash reloadClass <ClassName>"
        return 1
    fi

    local compiled_file="$TRASHDIR/.compiled/$class_name"
    local class_file="$TRASHDIR/$class_name"
    local trait_file="$TRASHDIR/traits/$class_name"
    local compiled_trait="$TRASHDIR/.compiled/traits/$class_name"

    # Check if it's a trait
    if [[ -f "$compiled_trait" ]]; then
        echo "Reloading trait $class_name..."
        # Unset old trait functions
        while IFS= read -r func; do
            unset -f "$func" 2>/dev/null
        done < <(declare -F | awk '{print $3}' | grep "^__${class_name}__")
            # Source the compiled trait
            source "$compiled_trait"
            cp "$compiled_trait" "$trait_file"
            echo "✓ Trait $class_name reloaded"
            return 0
        fi

        # Check for compiled class
        if [[ -f "$compiled_file" ]]; then
            echo "Reloading class $class_name..."
            # Unset old class functions
            while IFS= read -r func; do
                unset -f "$func" 2>/dev/null
            done < <(declare -F | awk '{print $3}' | grep "^__${class_name}__")
                # Source the compiled class
                source "$compiled_file"
                cp "$compiled_file" "$class_file"
                echo "✓ Class $class_name reloaded"
                return 0
            fi

            # Fall back to legacy class file
            if [[ -f "$class_file" ]]; then
                echo "Reloading legacy class $class_name..."
                source "$class_file"
                echo "✓ Legacy class $class_name reloaded"
                return 0
            fi

            echo "Error: Class $class_name not found"
            echo "Searched:"
            echo " - $compiled_file"
            echo " - $compiled_trait"
            echo " - $class_file"
            return 1
}

__Trash__compileAndReload() {
  local class_name="$1"
    if [[ -z "$class_name" ]]; then
        echo "Usage: @ Trash compileAndReload <ClassName>"
        return 1
    fi

    local source_file="$TRASHDIR/${class_name}.trash"
    local trait_source="$TRASHDIR/traits/${class_name}.trash"

    # Check for trait source
    if [[ -f "$trait_source" ]]; then
        echo "Compiling trait $class_name..."
        "$SCRIPT_DIR/lib/jq-compiler/driver.bash" compile "$trait_source" >"$TRASHDIR/.compiled/traits/$class_name"
        @ "$_RECEIVER" reloadClass "$class_name"
        return $?
    fi

    # Check for class source
    if [[ -f "$source_file" ]]; then
        echo "Compiling class $class_name..."
        "$SCRIPT_DIR/lib/jq-compiler/driver.bash" compile "$source_file" >"$TRASHDIR/.compiled/$class_name"
        @ "$_RECEIVER" reloadClass "$class_name"
        return $?
    fi

    echo "Error: No source file found for $class_name"
    echo "Searched:"
    echo " - $source_file"
    echo " - $trait_source"
    return 1
}

__Trash__stats() {
  echo "=== Trash System Statistics ==="
  echo "Objects: $(@ $_RECEIVER listObjects | wc -l)"
  echo "Traits: $(@ $_RECEIVER listTraits | wc -l)"
  echo "KV entries: $(kvlist 2>/dev/null | wc -l)"
  echo "Active processes: $(@ Process listProcesses 2>/dev/null | wc -l)"
  echo "Memory usage: $(du -sh "$TRASHDIR" | cut -f1)"
  echo "KV store size: $(du -sh "$KV_USER_DIR" 2>/dev/null | cut -f1 || echo "0B")"
}

__Trash__cleanup() {
  echo "Cleaning up trash system..."
  @ Process listProcesses >/dev/null 2>&1
  echo "Cleanup complete"
}

__Trash__findAll() {
  local class_name="$1"
  if [[ -z "$class_name" ]]; then
  echo "Usage: @ Trash findAll <ClassName>"
  return 1
  fi
  @ "$class_name" findAll
}

__Trash__find_where() {
  local class_name="$1"
  local predicate="$2"
  if [[ -z "$class_name" ]]; then
  echo "Usage: @ Trash find <ClassName> [predicate]"
  return 1
  fi
  @ "$class_name" find "$predicate"
}

__Trash__class__find() {
    local class_name="$1"
    local predicate="$2"
    if [[ -z "$class_name" ]]; then
        echo "Usage: @ Trash find <ClassName> [predicate]"
        return 1
    fi
    @ "$class_name" find "$predicate"
}

__Trash__countInstances() {
  local class_name="$1"
  if [[ -z "$class_name" ]]; then
  echo "Usage: @ Trash countInstances <ClassName>"
  return 1
  fi
  @ "$class_name" count
}

__Trash__listInstanceTypes() {
  db_list_classes
}

__Trash__showStack() {
  local stack count i frame_id frame_data receiver selector args
  _ensure_stack
  stack=$(kvget _stack 2>/dev/null)
  if [[ -z "$stack" || "$stack" == "[]" ]]; then
  echo "Call stack is empty"
  return 0
  fi
  count=$(echo "$stack" | jq 'length')
  echo "=== Call Stack ($count frames) ==="
  for ((i=count-1; i>=0; i--)); do
  frame_id=$(echo "$stack" | jq -r ".[$i]")
  frame_data=$(kvget "$frame_id" 2>/dev/null)
  if [[ -n "$frame_data" ]]; then
  receiver=$(echo "$frame_data" | jq -r '.args.receiver // "?"')
  selector=$(echo "$frame_data" | jq -r '.args.selector // "?"')
  args=$(echo "$frame_data" | jq -r '.args.args // ""')
  echo " [$i] $receiver >> $selector $args"
  else
  echo " [$i] $frame_id (frame data missing)"
  fi
  done
  echo ""
  echo "Enable stack frames with: export TRASH_STACK_FRAMES=1"
}

__Trash__clearStack() {
  local stack frame_id
  _ensure_stack
  stack=$(kvget _stack 2>/dev/null)
  if [[ -z "$stack" || "$stack" == "[]" ]]; then
  echo "Stack already empty"
  return 0
  fi
  echo "$stack" | jq -r '.[]' 2>/dev/null | while read -r frame_id; do
  if [[ -n "$frame_id" ]]; then
  kvdel "$frame_id" 2>/dev/null
  fi
  done
  kvset _stack "[]"
  echo "Stack cleared"
}

__Trash__stackDepth() {
  local stack
  _ensure_stack
  stack=$(kvget _stack 2>/dev/null)
  if [[ -z "$stack" ]]; then
  echo "0"
  else
  echo "$stack" | jq 'length'
  fi
}

__Trash__help() {
  echo "=== Trash System Commands ==="
  echo "@ Trash info - Show system information"
  echo "@ Trash listObjects - List all objects"
  echo "@ Trash listTraits - List all traits"
  echo "@ Trash methodsFor <object> - Show methods for object"
  echo "@ Trash hierarchyFor <object> - Show inheritance hierarchy"
  echo "@ Trash createObject <name> [super] - Create new object"
  echo "@ Trash removeObject <name> - Remove object"
  echo "@ Trash reload - Reload all object stubs"
  echo "@ Trash reloadClass <class> - Hot reload a single class"
  echo "@ Trash compileAndReload <class> - Compile and reload from .trash"
  echo "@ Trash stats - Show system statistics"
  echo "@ Trash cleanup - Clean up system"
  echo "@ Trash version - Show version information"
  echo "@ Trash inspect <object> - Detailed object inspection"
  echo ""
  echo "=== Instance Query Commands ==="
  echo "@ Trash findAll <Class> - Find all instances"
  echo "@ Trash find <Class> [pred] - Find with predicate"
  echo "@ Trash countInstances <Class> - Count instances"
  echo "@ Trash listInstanceTypes - List classes with instances"
  echo "@ Trash showStack - Show current call stack"
  echo "@ Trash clearStack - Clear call stack"
}

__Trash__version() {
  echo "Trash System v$TRASH_VERSION"
  echo "Author: $TRASH_AUTHOR"
  echo "Description: $TRASH_DESCRIPTION"
  echo "Bash version: $BASH_VERSION"
  echo "System: $(uname -s) $(uname -r)"
}

__Trash__inspect() {
  local object_name="$1"
  local object_file traits state
  if [[ -z "$object_name" ]]; then
  echo "Usage: @ Trash inspect <object_name>"
  return 1
  fi
  echo "=== Detailed Inspection: $object_name ==="
  object_file="$TRASHDIR/$object_name"
  if [[ ! -f "$object_file" ]]; then
  echo "Object $object_name not found"
  return 1
  fi
  echo "File: $object_file"
  echo "Size: $(wc -l < "$object_file") lines"
  echo "Modified: $(stat -f "%Sm" "$object_file" 2>/dev/null || stat -c "%y" "$object_file" 2>/dev/null)"
  echo ""
  @ "$_RECEIVER" hierarchyFor "$object_name"
  echo ""
  @ "$_RECEIVER" methodsFor "$object_name"
  echo ""
  traits=$(grep "^include" "$object_file" | awk '{print $2}')
  if [[ -n "$traits" ]]; then
  echo "Traits:"
  echo "$traits" | sed 's/^/ /'
  else
  echo "Traits: none"
  fi
  echo ""
  state=$(kvget "$object_name" 2>/dev/null)
  if [[ -n "$state" ]]; then
  echo "Persistent state:"
  echo "$state" | jq .2>/dev/null || echo "$state"
  else
  echo "Persistent state: none"
  fi
}

__Trash__quickCreate_template() {
  local object_name="$1"
  local template="$2"
    template="${template:-basic}"
    local object_file="$TRASHDIR/$object_name"

    if [[ -f "$object_file" ]]; then
        echo "Object $object_name already exists"
        return 1
    fi

    case "$template" in
        "service")
        cat >"$object_file" <<'EOF'
is_a Object
include Debuggable

# Service object template

start () {
debug "Starting service..."
echo "Service started"
}

stop () {
debug "Stopping service..."
echo "Service stopped"
}

status () {
echo "Service is running"
}

restart () {
stop
start
}
EOF
    ;;
        "tool")
        cat >"$object_file" <<'EOF'
is_a Tool
include Debuggable

# Tool object template

install () {
debug "Installing tool..."
echo "Tool installed"
}

uninstall () {
debug "Uninstalling tool..."
echo "Tool uninstalled"
}

configure () {
local config="$1"
debug "Configuring with: $config"
echo "Tool configured"
}
EOF
    ;;
        "actor")
        cat >"$object_file" <<'EOF'
is_a Object
include Debuggable

# Actor object template (for use with Process)

receive () {
local message="$1"
debug "Received message: $message"

case "$message" in
"ping")
echo "pong"
;;
"status")
echo "active"
;;
*)
echo "Unknown message: $message"
;;
esac
}

initialize () {
debug "Actor initialized"
kvset "$_RECEIVER" "$(jo status=active created=$(date))"
}
EOF
    ;;
        *)
        # Basic template
        cat >"$object_file" <<EOF
is_a Object

# $object_name - Created by Trash system

example () {
echo "Hello from $object_name"
}
EOF
    ;;
    esac

    echo "Created $object_name using $template template"
    create_object_stub "$object_name"
}
