is_a Object
include Debuggable

# Trash - The system object representing the entire trash system
# Provides introspection, management, and system-wide operations

# Get system information
info() {
    echo "=== Trash System Information ==="
    echo "Version: 0.1.0"
    echo "Directory: $TRASHDIR"
    echo "Objects: $(listObjects | wc -l)"
    echo "Traits: $(listTraits | wc -l)"
    echo "Active Processes: $(@ Process listProcesses | wc -l)"
    echo "KV Store: $KV_USER_DIR"
}

# List all available objects
listObjects() {
    find "$TRASHDIR" -maxdepth 1 -type f ! -path "*/traits/*" | while read -r file; do
        basename "$file"
    done | sort
}

# List all available traits
listTraits() {
    if [[ -d "$TRASHDIR/traits" ]]; then
        find "$TRASHDIR/traits" -type f | while read -r file; do
            basename "$file"
        done | sort
    fi
}

# Get methods available on an object
methodsFor() {
    local object_name="$1"
    local object_file="$TRASHDIR/$object_name"
    
    if [[ -f "$object_file" ]]; then
        echo "Methods for $object_name:"
        get_fcn_list "$object_file" | sed 's/^/  /'
        
        # Show inherited methods
        local superclass=$(grep "^is_a" "$object_file" | awk '{print $2}')
        if [[ -n "$superclass" && "$superclass" != "Object" ]]; then
            echo "  (inherited from $superclass)"
            methodsFor "$superclass" | sed 's/^/    /'
        fi
    else
        echo "Object $object_name not found"
        return 1
    fi
}

# Show inheritance hierarchy for an object
hierarchyFor() {
    local object_name="$1"
    local object_file="$TRASHDIR/$object_name"
    
    if [[ -f "$object_file" ]]; then
        echo "Inheritance hierarchy for $object_name:"
        _show_hierarchy "$object_name" 0
    else
        echo "Object $object_name not found"
        return 1
    fi
}

# Helper for showing hierarchy
_show_hierarchy() {
    local object_name="$1"
    local depth="$2"
    local indent=""
    
    for ((i=0; i<depth; i++)); do
        indent="  $indent"
    done
    
    echo "$indent$object_name"
    
    local object_file="$TRASHDIR/$object_name"
    if [[ -f "$object_file" ]]; then
        local superclass=$(grep "^is_a" "$object_file" | awk '{print $2}')
        if [[ -n "$superclass" ]]; then
            _show_hierarchy "$superclass" $((depth + 1))
        fi
    fi
}

# Create a new object file
createObject() {
    local object_name="$1"
    local superclass="${2:-Object}"
    local object_file="$TRASHDIR/$object_name"
    
    if [[ -f "$object_file" ]]; then
        echo "Object $object_name already exists"
        return 1
    fi
    
    cat > "$object_file" << EOF
is_a $superclass

# $object_name - Created by Trash system
# Add your methods below

example() {
    echo "Hello from $object_name"
}
EOF
    
    echo "Created object $object_name (inherits from $superclass)"
    echo "Edit $object_file to add methods"
    
    # Create object stub for immediate use
    create_object_stub "$object_name"
}

# Remove an object (with confirmation)
removeObject() {
    local object_name="$1"
    local object_file="$TRASHDIR/$object_name"
    
    if [[ ! -f "$object_file" ]]; then
        echo "Object $object_name not found"
        return 1
    fi
    
    echo "Are you sure you want to remove object $object_name? (y/N)"
    read -r confirmation
    
    if [[ "$confirmation" =~ ^[Yy]$ ]]; then
        rm "$object_file"
        echo "Removed object $object_name"
        
        # Remove any associated state
        kvdel "$object_name" 2>/dev/null || true
    else
        echo "Cancelled"
    fi
}

# Reload all object stubs (useful after adding new objects)
reload() {
    echo "Reloading object stubs..."
    initialize_trash
    echo "Reload complete"
}

# Show system statistics
stats() {
    echo "=== Trash System Statistics ==="
    echo "Objects: $(listObjects | wc -l)"
    echo "Traits: $(listTraits | wc -l)"
    echo "KV entries: $(kvlist 2>/dev/null | wc -l)"
    echo "Active processes: $(@ Process listProcesses 2>/dev/null | wc -l)"
    echo "Memory usage: $(du -sh "$TRASHDIR" | cut -f1)"
    echo "KV store size: $(du -sh "$KV_USER_DIR" 2>/dev/null | cut -f1 || echo "0B")"
}

# Clean up system (remove dead processes, orphaned KV entries, etc.)
cleanup() {
    echo "Cleaning up trash system..."

    # Clean up dead processes
    @ Process listProcesses >/dev/null 2>&1

    # Could add more cleanup logic here
    echo "Cleanup complete"
}

# ============================================
# Instance Query API
# ============================================

# Find all instances of a class
findAll() {
    local class_name="$1"

    if [[ -z "$class_name" ]]; then
        echo "Usage: @ Trash findAll <ClassName>"
        return 1
    fi

    # Scan kv-bash for type markers
    local kv_dir="${KV_USER_DIR:-$HOME/.kv-bash}"
    for file in "$kv_dir"/*._type 2>/dev/null; do
        if [[ -f "$file" ]]; then
            local type_val=$(cat "$file")
            if [[ "$type_val" == "$class_name" ]]; then
                # Extract instance ID from filename
                local instance_id=$(basename "$file" ._type)
                echo "$instance_id"
            fi
        fi
    done
}

# Find instances matching a predicate
find() {
    local class_name="$1"
    local predicate="$2"

    if [[ -z "$class_name" ]]; then
        echo "Usage: @ Trash find <ClassName> [predicate]"
        echo "Example: @ Trash find Counter 'value > 5'"
        return 1
    fi

    # Get all instances of the class
    local instances=$(findAll "$class_name")

    if [[ -z "$predicate" ]]; then
        echo "$instances"
        return 0
    fi

    # Filter by predicate
    echo "$instances" | while read -r instance_id; do
        if [[ -n "$instance_id" ]]; then
            if _evaluate_predicate "$instance_id" "$class_name" "$predicate"; then
                echo "$instance_id"
            fi
        fi
    done
}

# Helper: evaluate a predicate against an instance
_evaluate_predicate() {
    local instance_id="$1"
    local class_name="$2"
    local predicate="$3"

    # Get the instance value (try getValue method first, then raw kv data)
    local value
    value=$(@ "$instance_id" getValue 2>/dev/null)
    if [[ -z "$value" ]]; then
        value=$(kvget "$instance_id" 2>/dev/null)
    fi

    # Simple predicate evaluation
    # Format: "value OP number" or just "OP number" (value implied)
    if [[ "$predicate" =~ ^(value[[:space:]]*)?([<>=!]+)[[:space:]]*([0-9]+)$ ]]; then
        local op="${BASH_REMATCH[2]}"
        local target="${BASH_REMATCH[3]}"

        # Handle non-numeric values
        if ! [[ "$value" =~ ^-?[0-9]+$ ]]; then
            return 1
        fi

        case "$op" in
            ">")  [[ "$value" -gt "$target" ]] ;;
            "<")  [[ "$value" -lt "$target" ]] ;;
            ">=") [[ "$value" -ge "$target" ]] ;;
            "<=") [[ "$value" -le "$target" ]] ;;
            "=="|"=") [[ "$value" -eq "$target" ]] ;;
            "!=") [[ "$value" -ne "$target" ]] ;;
            *)    return 1 ;;
        esac
    else
        # Unsupported predicate format
        echo "Warning: Unsupported predicate format: $predicate" >&2
        return 1
    fi
}

# Count instances of a class
countInstances() {
    local class_name="$1"

    if [[ -z "$class_name" ]]; then
        echo "Usage: @ Trash countInstances <ClassName>"
        return 1
    fi

    findAll "$class_name" | wc -l | tr -d ' '
}

# List all instance types
listInstanceTypes() {
    local kv_dir="${KV_USER_DIR:-$HOME/.kv-bash}"
    for file in "$kv_dir"/*._type 2>/dev/null; do
        if [[ -f "$file" ]]; then
            cat "$file"
        fi
    done | sort -u
}

# ============================================
# Stack Frame Introspection
# ============================================

# Show current call stack
showStack() {
    _ensure_stack
    local stack=$(kvget _stack 2>/dev/null)

    if [[ -z "$stack" || "$stack" == "[]" ]]; then
        echo "Call stack is empty"
        return 0
    fi

    local count=$(echo "$stack" | jq 'length')
    echo "=== Call Stack ($count frames) ==="

    # Iterate from top of stack (most recent) to bottom
    for ((i=count-1; i>=0; i--)); do
        local frame_id=$(echo "$stack" | jq -r ".[$i]")
        local frame_data=$(kvget "$frame_id" 2>/dev/null)

        if [[ -n "$frame_data" ]]; then
            local receiver=$(echo "$frame_data" | jq -r '.args.receiver // "?"')
            local selector=$(echo "$frame_data" | jq -r '.args.selector // "?"')
            local args=$(echo "$frame_data" | jq -r '.args.args // ""')
            echo "  [$i] $receiver >> $selector $args"
        else
            echo "  [$i] $frame_id (frame data missing)"
        fi
    done

    echo ""
    echo "Enable stack frames with: export TRASH_STACK_FRAMES=1"
}

# Clear the call stack (for debugging/recovery)
clearStack() {
    _ensure_stack
    local stack=$(kvget _stack 2>/dev/null)

    if [[ -z "$stack" || "$stack" == "[]" ]]; then
        echo "Stack already empty"
        return 0
    fi

    # Delete all frame data
    echo "$stack" | jq -r '.[]' 2>/dev/null | while read -r frame_id; do
        if [[ -n "$frame_id" ]]; then
            kvdel "$frame_id" 2>/dev/null
        fi
    done

    # Reset stack
    kvset _stack "[]"
    echo "Stack cleared"
}

# Get stack depth
stackDepth() {
    _ensure_stack
    local stack=$(kvget _stack 2>/dev/null)
    if [[ -z "$stack" ]]; then
        echo "0"
    else
        echo "$stack" | jq 'length'
    fi
}

# ============================================

# Show help
help() {
    echo "=== Trash System Commands ==="
    echo "@ Trash info                    - Show system information"
    echo "@ Trash listObjects             - List all objects"
    echo "@ Trash listTraits              - List all traits"
    echo "@ Trash methodsFor <object>     - Show methods for object"
    echo "@ Trash hierarchyFor <object>   - Show inheritance hierarchy"
    echo "@ Trash createObject <name> [super] - Create new object"
    echo "@ Trash removeObject <name>     - Remove object"
    echo "@ Trash reload                  - Reload object stubs"
    echo "@ Trash stats                   - Show system statistics"
    echo "@ Trash cleanup                 - Clean up system"
    echo "@ Trash version                 - Show version information"
    echo "@ Trash inspect <object>        - Detailed object inspection"
    echo ""
    echo "=== Instance Query Commands ==="
    echo "@ Trash findAll <Class>         - Find all instances of a class"
    echo "@ Trash find <Class> [pred]     - Find instances matching predicate"
    echo "@ Trash countInstances <Class>  - Count instances of a class"
    echo "@ Trash listInstanceTypes       - List all instance types"
    echo "@ Trash showStack               - Show current call stack"
    echo "@ Trash clearStack              - Clear call stack (recovery)"
    echo ""
    echo "@ Trash help                    - Show this help"
    echo ""
    echo "Examples:"
    echo "  @ Trash createObject MyService Tool"
    echo "  @ Trash methodsFor Array"
    echo "  @ Trash findAll Counter"
    echo "  @ Trash find Counter 'value > 5'"
}

# Show version information
version() {
    echo "Trash System v$TRASH_VERSION"
    echo "Author: $TRASH_AUTHOR"
    echo "Description: $TRASH_DESCRIPTION"
    echo "Bash version: $BASH_VERSION"
    echo "System: $(uname -s) $(uname -r)"
}

# Detailed object inspection
inspect() {
    local object_name="$1"

    if [[ -z "$object_name" ]]; then
        echo "Usage: @ Trash inspect <object_name>"
        return 1
    fi

    echo "=== Detailed Inspection: $object_name ==="

    # Check if object exists
    local object_file="$TRASHDIR/$object_name"
    if [[ ! -f "$object_file" ]]; then
        echo "Object $object_name not found"
        return 1
    fi

    # Basic info
    echo "File: $object_file"
    echo "Size: $(wc -l < "$object_file") lines"
    echo "Modified: $(stat -f "%Sm" "$object_file" 2>/dev/null || stat -c "%y" "$object_file" 2>/dev/null)"

    # Inheritance
    echo ""
    hierarchyFor "$object_name"

    # Methods
    echo ""
    methodsFor "$object_name"

    # Traits
    echo ""
    local traits=$(grep "^include" "$object_file" | awk '{print $2}')
    if [[ -n "$traits" ]]; then
        echo "Traits:"
        echo "$traits" | sed 's/^/  /'
    else
        echo "Traits: none"
    fi

    # State (if any)
    echo ""
    local state=$(kvget "$object_name" 2>/dev/null)
    if [[ -n "$state" ]]; then
        echo "Persistent state:"
        echo "$state" | jq . 2>/dev/null || echo "$state"
    else
        echo "Persistent state: none"
    fi
}

# Quick object creation with template
quickCreate() {
    local object_name="$1"
    local template="${2:-basic}"

    if [[ -z "$object_name" ]]; then
        echo "Usage: @ Trash quickCreate <name> [template]"
        echo "Templates: basic, service, tool, actor"
        return 1
    fi

    local object_file="$TRASHDIR/$object_name"

    if [[ -f "$object_file" ]]; then
        echo "Object $object_name already exists"
        return 1
    fi

    case "$template" in
        "service")
            cat > "$object_file" << 'EOF'
is_a Object
include Debuggable

# Service object template

start() {
    debug "Starting service..."
    echo "Service started"
}

stop() {
    debug "Stopping service..."
    echo "Service stopped"
}

status() {
    echo "Service is running"
}

restart() {
    stop
    start
}
EOF
            ;;
        "tool")
            cat > "$object_file" << 'EOF'
is_a Tool
include Debuggable

# Tool object template

install() {
    debug "Installing tool..."
    echo "Tool installed"
}

uninstall() {
    debug "Uninstalling tool..."
    echo "Tool uninstalled"
}

configure() {
    local config="$1"
    debug "Configuring with: $config"
    echo "Tool configured"
}
EOF
            ;;
        "actor")
            cat > "$object_file" << 'EOF'
is_a Object
include Debuggable

# Actor object template (for use with Process)

receive() {
    local message="$1"
    debug "Received message: $message"

    case "$message" in
        "ping")
            echo "pong"
            ;;
        "status")
            echo "active"
            ;;
        *)
            echo "Unknown message: $message"
            ;;
    esac
}

initialize() {
    debug "Actor initialized"
    kvset "$_RECEIVER" "$(jo status=active created=$(date))"
}
EOF
            ;;
        *)
            # Basic template
            cat > "$object_file" << EOF
is_a Object

# $object_name - Created by Trash system

example() {
    echo "Hello from $object_name"
}
EOF
            ;;
    esac

    echo "Created $object_name using $template template"
    create_object_stub "$object_name"
}
