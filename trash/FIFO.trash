# FIFO - Named pipe abstraction
# Encapsulates creation, access, and cleanup of POSIX named pipes (FIFOs)
FIFO subclass: Object
  instanceVars: path:'' keeperPid:'' writerPid:'' readerPid:''

  # Create a FIFO instance for a given path (does not create the pipe yet)
  rawClassMethod: at: aPath [
    local id
    id=$(_generate_instance_id FIFO)
    _create_instance FIFO "$id"
    @ "$id" _setPath: "$aPath"
    echo "$id"
  ]

  # Create the named pipe on disk
  rawMethod: create [
    local p
    p="$(_ivar path)"
    rm -f "$p" 2>/dev/null
    mkfifo "$p"
  ]

  # Check if the pipe exists on disk
  rawMethod: exists [
    local p
    p="$(_ivar path)"
    if [[ -p "$p" ]]; then
      echo "true"
    else
      echo "false"
    fi
  ]

  # Remove the pipe from disk
  rawMethod: remove [
    local p
    p="$(_ivar path)"
    rm -f "$p" 2>/dev/null
  ]

  # Open the FIFO read-write to prevent blocking
  # Spawns a background process that holds the FIFO open
  rawMethod: open [
    local p keeper_pid pidfile
    p="$(_ivar path)"
    pidfile="/tmp/fifo_keeper_${_INSTANCE}.pid"

    # Spawn a detached process that ignores SIGINT (Ctrl+C immune)
    # The keeper opens the FIFO read-write and sleeps forever
    # trap '' INT makes it ignore interrupt signals
    /bin/bash -c 'trap "" INT; echo $$ > "$2"; exec 3<>"$1"; while true; do sleep 86400; done' _ "$p" "$pidfile" </dev/null >/dev/null 2>&1 &

    sleep 0.1
    keeper_pid=$(cat "$pidfile" 2>/dev/null)
    rm -f "$pidfile"

    _ivar_set keeperPid "$keeper_pid"
  ]

  # Close the FIFO (kills the keeper process)
  rawMethod: close [
    local keeper_pid
    keeper_pid="$(_ivar keeperPid)"
    if [[ -n "$keeper_pid" ]]; then
      kill "$keeper_pid" 2>/dev/null
      _ivar_set keeperPid ""
    fi
  ]

  # Write a line to the FIFO
  rawMethod: writeLine: text [
    local p text="$1"
    p="$(_ivar path)"
    echo "$text" > "$p"
  ]

  # Read a line from the FIFO
  rawMethod: readLine [
    local p line
    p="$(_ivar path)"
    if read -r line < "$p"; then
      echo "$line"
    fi
  ]

  # Read a line with timeout (seconds)
  rawMethod: readLineTimeout: seconds [
    local p line seconds="$1"
    p="$(_ivar path)"
    if read -t "$seconds" -r line < "$p" 2>/dev/null; then
      echo "$line"
    fi
  ]

  # Read lines continuously, calling handler for each
  # The current line is available in $__FIFO_LINE
  # Exits when the writer closes the FIFO
  rawMethod: readLinesDo: handler [
    local p
    p="$(_ivar path)"

    while IFS='' read -r __FIFO_LINE; do
      eval "$1"
    done < "$p"
  ]

  # =========================================================================
  # Async Writer API
  # =========================================================================

  # Start a command that writes to this FIFO in the background
  # The command's stdout is redirected to the FIFO
  rawMethod: startWriter: cmd [
    local p cmd="$1" pidfile writer_pid
    p="$(_ivar path)"
    pidfile="/tmp/fifo_writer_${_INSTANCE}.pid"

    # Spawn the command writing to the FIFO
    # Uses trap to ignore SIGINT so Ctrl+C doesn't kill it
    # Opens FIFO read-write (<>) to avoid blocking on open
    /bin/bash -c 'trap "" INT; echo $$ > "$2"; exec 1<>"$3"; eval "$1"' _ "$cmd" "$pidfile" "$p" </dev/null 2>&1 &

    sleep 0.1
    writer_pid=$(cat "$pidfile" 2>/dev/null)
    rm -f "$pidfile"

    _ivar_set writerPid "$writer_pid"
  ]

  # Stop the writer process
  rawMethod: stopWriter [
    local writer_pid
    writer_pid="$(_ivar writerPid)"
    if [[ -n "$writer_pid" ]]; then
      kill "$writer_pid" 2>/dev/null
      kill -9 "$writer_pid" 2>/dev/null
      _ivar_set writerPid ""
    fi
  ]

  # =========================================================================
  # Async Reader API
  # =========================================================================

  # Start a background reader that calls handler for each line
  # The current line is available in $__FIFO_LINE
  rawMethod: startReader: handler [
    local p handler="$1" pidfile reader_pid
    p="$(_ivar path)"
    pidfile="/tmp/fifo_reader_${_INSTANCE}.pid"

    # Spawn a reader loop in the background
    # Uses trap to ignore SIGINT so Ctrl+C doesn't kill it
    # Opens FIFO read-write (<>) to avoid blocking on open
    /bin/bash -c 'trap "" INT; echo $$ > "$2"; exec 0<>"$3"; while IFS= read -r __FIFO_LINE; do eval "$1"; done' _ "$handler" "$pidfile" "$p" </dev/null 2>&1 &

    sleep 0.1
    reader_pid=$(cat "$pidfile" 2>/dev/null)
    rm -f "$pidfile"

    _ivar_set readerPid "$reader_pid"
  ]

  # Stop the reader process
  rawMethod: stopReader [
    local reader_pid
    reader_pid="$(_ivar readerPid)"
    if [[ -n "$reader_pid" ]]; then
      kill "$reader_pid" 2>/dev/null
      kill -9 "$reader_pid" 2>/dev/null
      _ivar_set readerPid ""
    fi
  ]

  # Private setter
  method: _setPath: aPath [
    path := aPath
  ]
