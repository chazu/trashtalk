# Future - Simple async computation with result retrieval
Future subclass: Object
  pragma: primitiveClass
  instanceVars: command pid result_file status exit_code

  # Create a future for a command (does not start it yet)
  # Usage: future=$(@ Future for: '@ Counter expensiveCalculation')
  rawClassMethod: for: command [
    local future_id
    future_id=$(_generate_instance_id Future)

    # Set up result file paths
    local result_dir="/tmp/trashtalk/futures"
    mkdir -p "$result_dir"
    local result_file="$result_dir/$future_id"

    # Create instance with command stored but not yet running
    _create_instance Future "$future_id"
    @ "$future_id" setCommand "$command"
    @ "$future_id" setResult_file "$result_file"
    @ "$future_id" setStatus "created"
    @ "$future_id" setExit_code ""
    @ "$future_id" setPid ""

    echo "$future_id"
  ]

  # Start the computation in background
  # Returns the PID of the background process
  rawMethod: start [
    local cmd result_file exit_file
    cmd=$(_ivar command)
    result_file=$(_ivar result_file)
    exit_file="${result_file}.exit"

    # Run command in background subshell
    (eval "$cmd" > "$result_file" 2>&1; echo $? > "$exit_file") &
    local bg_pid=$!

    _ivar_set pid "$bg_pid"
    _ivar_set status "pending"

    echo "$bg_pid"
  ]

  # Block until the computation completes, return result
  rawMethod: await [
    local pid result_file exit_file
    pid=$(_ivar pid)
    result_file=$(_ivar result_file)
    exit_file="${result_file}.exit"

    # Wait for process to complete
    wait "$pid" 2>/dev/null

    # Read exit code and update status
    local exit_code
    exit_code=$(cat "$exit_file" 2>/dev/null || echo "1")
    _ivar_set exit_code "$exit_code"

    if [[ "$exit_code" == "0" ]]; then
      _ivar_set status "completed"
    else
      _ivar_set status "failed"
    fi

    # Return result
    cat "$result_file"
  ]

  # Check if computation is done without blocking
  rawMethod: poll [
    local pid
    pid=$(_ivar pid)

    if kill -0 "$pid" 2>/dev/null; then
      echo "pending"
    else
      # Process finished, update status
      @ "$_RECEIVER" await >/dev/null
      echo "$(_ivar status)"
    fi
  ]

  # Check if done (returns 0 if done, 1 if pending)
  rawMethod: isDone [
    local pid
    pid=$(_ivar pid)
    ! kill -0 "$pid" 2>/dev/null
  ]

  # Cancel the computation
  rawMethod: cancel [
    local pid
    pid=$(_ivar pid)

    if kill -0 "$pid" 2>/dev/null; then
      kill -TERM "$pid" 2>/dev/null
      sleep 0.1
      kill -KILL "$pid" 2>/dev/null
      _ivar_set status "cancelled"
      echo "Cancelled"
    else
      echo "Already completed"
    fi
  ]

  # Get current status
  rawMethod: status [
    local pid status
    status=$(_ivar status)
    pid=$(_ivar pid)

    # Update status if process finished
    if [[ "$status" == "pending" ]] && ! kill -0 "$pid" 2>/dev/null; then
      @ "$_RECEIVER" await >/dev/null
      status=$(_ivar status)
    fi

    echo "$status"
  ]

  # Get exit code (empty if still pending)
  rawMethod: exitCode [
    _ivar exit_code
  ]

  # Clean up resources
  rawMethod: cleanup [
    local result_file
    result_file=$(_ivar result_file)
    rm -f "$result_file" "${result_file}.exit" 2>/dev/null
    @ "$_RECEIVER" delete
  ]

  # Show help
  rawClassMethod: help [
    echo "=== Future - Async Computation ==="
    echo ""
    echo "Usage (two-call pattern - recommended):"
    echo "  future=\$(@ Future for: 'command')   # Create future"
    echo "  @ \$future start                     # Start background process"
    echo "  result=\$(@ \$future await)          # Get result"
    echo ""
    echo "Class Methods:"
    echo "  for: <command>  - Create future (stores command, does not start)"
    echo ""
    echo "Instance Methods:"
    echo "  start           - Start the background computation"
    echo "  await           - Block until done, return result"
    echo "  poll            - Check status without blocking"
    echo "  isDone          - Returns 0 if done, 1 if pending"
    echo "  cancel          - Kill the computation"
    echo "  status          - Show status (created/pending/completed/failed/cancelled)"
    echo "  exitCode        - Get exit code (empty if pending)"
    echo "  cleanup         - Remove result files and delete future"
    echo ""
    echo "Example:"
    echo "  # Create future for expensive computation"
    echo "  f=\$(@ Future for: 'sleep 2 && echo done')"
    echo "  @ \$f start  # Start it"
    echo "  "
    echo "  # Do other work while it runs..."
    echo "  @ SomeClass doOtherStuff"
    echo "  "
    echo "  # Get result (blocks if not ready)"
    echo "  result=\$(@ \$f await)"
    echo "  echo \"Result: \$result\""
    echo "  @ \$f cleanup"
  ]
