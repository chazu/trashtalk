package: Yutani

Application subclass: Object
  instanceVars: session:'' dispatcher:'' rootWidget:'' running:''

  # Launch application on default host
  classMethod: launch [
    pragma: primitive
    @ "$_CLASS" launchOn: "localhost:7755"
  ]

  # Launch application on specified host
  classMethod: launchOn: host [
    pragma: primitive
    local host="$1"
    local app session dispatcher

    # Create application instance
    app=$(@ "$_CLASS" new)

    # Connect to Yutani
    session=$(@ Yutani::Session connectTo: "$host" 2>&1 | grep -v "^\[INFO\]" | tail -1)
    if [[ -z "$session" ]] || echo "$session" | grep -qi error; then
      echo "Error: Could not connect to Yutani server at $host" >&2
      return 1
    fi

    # Create dispatcher
    dispatcher=$(@ Yutani::EventDispatcher new)

    # Set up application
    @ "$app" _setSession: "$session"
    @ "$app" _setDispatcher: "$dispatcher"
    @ "$app" _setRunning: "true"

    # Call user's setup method
    @ "$app" setup

    # Run event loop
    @ "$app" run

    # Cleanup
    @ "$app" cleanup
  ]

  # Subclasses override this to build UI
  method: setup [
    :
  ]

  # Main event loop - tries native streaming first, falls back to coproc
  method: run [
    pragma: primitive
    local session dispatcher
    session="$(_ivar session)"
    dispatcher="$(_ivar dispatcher)"

    # Try native streaming first (requires native GrpcClient.dylib and daemon)
    # Falls back to coproc-based streaming if native fails
    if @ "$_RECEIVER" _tryNativeEventLoop 2>/dev/null; then
      return 0
    fi

    # Fallback: coproc-based event loop
    @ "$_RECEIVER" _runCoprocEventLoop
  ]

  # Native event loop using GrpcClient.serverStream
  # Returns true if native streaming was successful
  method: _tryNativeEventLoop [
    pragma: primitive
    local session dispatcher
    session="$(_ivar session)"
    dispatcher="$(_ivar dispatcher)"

    # Use native streaming - blocks until stream ends
    @ "$session" runEventLoopWithDispatcher: "$dispatcher"
  ]

  # Fallback: coproc-based event loop (uses grpcurl subprocess)
  method: _runCoprocEventLoop [
    pragma: primitive
    local session dispatcher
    session="$(_ivar session)"
    dispatcher="$(_ivar dispatcher)"

    # Store dispatcher in global for handler access
    __APP_DISPATCHER="$dispatcher"
    __APP_INSTANCE="$_RECEIVER"

    # Use session's event handling with a dispatcher handler
    @ "$session" onEventDo: '
      @ "$__APP_DISPATCHER" dispatchJson: "$__COPROC_LINE"
      if [[ $(@ "$__APP_DISPATCHER" isRunning) != "true" ]]; then
        @ "$__APP_INSTANCE" stop
      fi
    '
  ]

  # Stop the application
  method: stop [
    running := 'false'
  ]

  # Cleanup resources
  method: cleanup [
    pragma: primitive
    local session dispatcher
    session="$(_ivar session)"
    dispatcher="$(_ivar dispatcher)"

    if [[ -n "$dispatcher" ]]; then
      @ "$dispatcher" cleanup
    fi

    if [[ -n "$session" ]]; then
      @ "$session" disconnect
    fi
  ]

  # === Widget Creation Helpers ===
  # These create widgets with dispatcher already set

  method: createTextView: title [
    pragma: primitive
    local title="$1"
    local session dispatcher widget
    session="$(_ivar session)"
    dispatcher="$(_ivar dispatcher)"
    widget=$(@ Yutani::TextView titled: "$title" inSession: "$session")
    @ "$widget" setDispatcher: "$dispatcher"
    echo "$widget"
  ]

  method: createTextView: title text: initialText [
    pragma: primitive
    local title="$1" initialText="$2"
    local session dispatcher widget
    session="$(_ivar session)"
    dispatcher="$(_ivar dispatcher)"
    widget=$(@ Yutani::TextView titled: "$title" text: "$initialText" inSession: "$session")
    @ "$widget" setDispatcher: "$dispatcher"
    echo "$widget"
  ]

  method: createInputField: label [
    pragma: primitive
    local label="$1"
    local session dispatcher widget
    session="$(_ivar session)"
    dispatcher="$(_ivar dispatcher)"
    widget=$(@ Yutani::InputField labeled: "$label" inSession: "$session")
    @ "$widget" setDispatcher: "$dispatcher"
    echo "$widget"
  ]

  method: createInputField: label placeholder: placeholder [
    pragma: primitive
    local label="$1" placeholder="$2"
    local session dispatcher widget
    session="$(_ivar session)"
    dispatcher="$(_ivar dispatcher)"
    widget=$(@ Yutani::InputField labeled: "$label" placeholder: "$placeholder" inSession: "$session")
    @ "$widget" setDispatcher: "$dispatcher"
    echo "$widget"
  ]

  method: createListView: title [
    pragma: primitive
    local title="$1"
    local session dispatcher widget
    session="$(_ivar session)"
    dispatcher="$(_ivar dispatcher)"
    widget=$(@ Yutani::ListView titled: "$title" inSession: "$session")
    @ "$widget" setDispatcher: "$dispatcher"
    echo "$widget"
  ]

  method: createVerticalLayout [
    pragma: primitive
    local session dispatcher widget
    session="$(_ivar session)"
    dispatcher="$(_ivar dispatcher)"
    widget=$(@ Yutani::VerticalLayout inSession: "$session")
    @ "$widget" setDispatcher: "$dispatcher"
    echo "$widget"
  ]

  method: createHorizontalLayout [
    pragma: primitive
    local session dispatcher widget
    session="$(_ivar session)"
    dispatcher="$(_ivar dispatcher)"
    widget=$(@ Yutani::HorizontalLayout inSession: "$session")
    @ "$widget" setDispatcher: "$dispatcher"
    echo "$widget"
  ]

  # Set root widget
  method: setRoot: widget [
    rootWidget := widget
    @ widget setAsRoot
  ]

  # === Event Handler Registration ===

  # Register global key handler
  method: onKeyDo: handler [
    @ dispatcher onKeyDo: handler
  ]

  # Register global mouse handler
  method: onMouseDo: handler [
    @ dispatcher onMouseDo: handler
  ]

  # Accessors
  method: getSession [ ^ session ]
  method: getDispatcher [ ^ dispatcher ]
  method: getRootWidget [ ^ rootWidget ]

  # Private setters
  method: _setSession: v [ session := v ]
  method: _setDispatcher: v [ dispatcher := v ]
  method: _setRunning: v [ running := v ]
