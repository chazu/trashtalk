package: Yutani

Application subclass: Object
  instanceVars: session:'' dispatcher:'' rootWidget:'' running:''

  # Launch application on default host
  classMethod: launch [
    @ self launchOn: 'localhost:7755'
  ]

  # Launch application on specified host (bash-specific: error handling, grep)
  rawClassMethod: launchOn: host [
    pragma: bashOnly
    local host="$1"
    local app session dispatcher

    # Create application instance
    app=$(@ "$_CLASS" new)

    # Connect to Yutani
    session=$(@ Yutani::Session connectTo: "$host" 2>&1 | grep -v "^\[INFO\]" | tail -1)
    if [[ -z "$session" ]] || echo "$session" | grep -qi error; then
      echo "Error: Could not connect to Yutani server at $host" >&2
      return 1
    fi

    # Create dispatcher
    dispatcher=$(@ Yutani::EventDispatcher new)

    # Set up application
    @ "$app" _setSession: "$session"
    @ "$app" _setDispatcher: "$dispatcher"
    @ "$app" _setRunning: "true"

    # Call user's setup method
    @ "$app" setup

    # Run event loop
    @ "$app" run

    # Cleanup
    @ "$app" cleanup
  ]

  # Subclasses override this to build UI
  method: setup [
    :
  ]

  # Main event loop - tries native streaming first, falls back to coproc
  # (bash-specific: error redirection)
  rawMethod: run [
    pragma: bashOnly
    # Try native streaming first (requires native GrpcClient.dylib and daemon)
    # Falls back to coproc-based streaming if native fails
    if @ "$_RECEIVER" _tryNativeEventLoop 2>/dev/null; then
      return 0
    fi

    # Fallback: coproc-based event loop
    @ "$_RECEIVER" _runCoprocEventLoop
  ]

  # Native event loop using GrpcClient.serverStream
  method: _tryNativeEventLoop [
    @ $session runEventLoopWithDispatcher: $dispatcher
  ]

  # Fallback: coproc-based event loop (uses grpcurl subprocess)
  # (bash-specific: globals for handler access)
  rawMethod: _runCoprocEventLoop [
    pragma: bashOnly
    # Store dispatcher in global for handler access
    __APP_DISPATCHER="$(_ivar dispatcher)"
    __APP_INSTANCE="$_RECEIVER"

    # Use session's event handling with a dispatcher handler
    @ "$(_ivar session)" onEventDo: '
      @ "$__APP_DISPATCHER" dispatchJson: "$__COPROC_LINE"
      if [[ $(@ "$__APP_DISPATCHER" isRunning) != "true" ]]; then
        @ "$__APP_INSTANCE" stop
      fi
    '
  ]

  # Stop the application
  method: stop [
    running := 'false'
  ]

  # Cleanup resources
  method: cleanup [
    ($dispatcher notEmpty) ifTrue: [
      @ $dispatcher cleanup
    ].
    ($session notEmpty) ifTrue: [
      @ $session disconnect
    ]
  ]

  # === Widget Creation Helpers ===
  # These create widgets with dispatcher already set

  method: createTextView: title [
    | widget |
    widget := $(@ Yutani::TextView titled: title inSession: $session).
    @ $widget setDispatcher: $dispatcher.
    ^ $widget
  ]

  method: createTextView: title text: initialText [
    | widget |
    widget := $(@ Yutani::TextView titled: title text: initialText inSession: $session).
    @ $widget setDispatcher: $dispatcher.
    ^ $widget
  ]

  method: createInputField: label [
    | widget |
    widget := $(@ Yutani::InputField labeled: label inSession: $session).
    @ $widget setDispatcher: $dispatcher.
    ^ $widget
  ]

  method: createInputField: label placeholder: placeholder [
    | widget |
    widget := $(@ Yutani::InputField labeled: label placeholder: placeholder inSession: $session).
    @ $widget setDispatcher: $dispatcher.
    ^ $widget
  ]

  method: createListView: title [
    | widget |
    widget := $(@ Yutani::ListView titled: title inSession: $session).
    @ $widget setDispatcher: $dispatcher.
    ^ $widget
  ]

  method: createVerticalLayout [
    | widget |
    widget := $(@ Yutani::VerticalLayout inSession: $session).
    @ $widget setDispatcher: $dispatcher.
    ^ $widget
  ]

  method: createHorizontalLayout [
    | widget |
    widget := $(@ Yutani::HorizontalLayout inSession: $session).
    @ $widget setDispatcher: $dispatcher.
    ^ $widget
  ]

  # Set root widget
  method: setRoot: widget [
    rootWidget := $widget.
    @ $widget setAsRoot
  ]

  # === Event Handler Registration ===

  # Register global key handler
  method: onKeyDo: handler [
    @ $dispatcher onKeyDo: handler
  ]

  # Register global mouse handler
  method: onMouseDo: handler [
    @ $dispatcher onMouseDo: handler
  ]

  # Accessors
  method: getSession [ ^ $session ]
  method: getDispatcher [ ^ $dispatcher ]
  method: getRootWidget [ ^ $rootWidget ]

  # Private setters
  method: _setSession: v [ session := v ]
  method: _setDispatcher: v [ dispatcher := v ]
  method: _setRunning: v [ running := v ]
