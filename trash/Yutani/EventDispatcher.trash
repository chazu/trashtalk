package: Yutani

EventDispatcher subclass: Object
  instanceVars: handlerFile:'' keyHandler:'' mouseHandler:'' resizeHandler:'' focusHandler:'' running:''

  # Create a new dispatcher
  rawClassMethod: new [
    local instance hfile
    instance=$(_generate_instance_id "Yutani__EventDispatcher")
    _create_instance "Yutani::EventDispatcher" "$instance"
    # Create unique handler file
    hfile="/tmp/yutani_handlers_${instance}.txt"
    touch "$hfile"
    @ "$instance" _setHandlerFile: "$hfile"
    @ "$instance" _setRunning: "true"
    echo "$instance"
  ]

  # Register a handler for a specific widget
  # Handler is a bash command that will be eval'd with $__EVENT set to the Event instance
  rawMethod: onWidget: widgetId do: handler [
    local widgetId="$1" handler="$2" hfile
    hfile="$(_ivar handlerFile)"
    # Remove any existing handler for this widget
    if [[ -f "$hfile" ]]; then
      grep -v "^${widgetId}:" "$hfile" > "${hfile}.tmp" 2>/dev/null || true
      mv "${hfile}.tmp" "$hfile"
    fi
    # Add new handler
    echo "${widgetId}:${handler}" >> "$hfile"
  ]

  # Register a global key handler
  # Handler receives $__EVENT
  rawMethod: onKeyDo: handler [
    local handler="$1"
    _ivar_set keyHandler "$handler"
  ]

  # Register a global mouse handler
  method: onMouseDo: handler [
    mouseHandler := handler
  ]

  # Register a global resize handler
  method: onResizeDo: handler [
    resizeHandler := handler
  ]

  # Register a global focus handler
  method: onFocusDo: handler [
    focusHandler := handler
  ]

  # Dispatch an event to the appropriate handler
  rawMethod: dispatch: event [
    pragma: direct
    local event="$1"
    local eventType widgetId handler hfile line

    eventType=$(@ "$event" eventType)

    case "$eventType" in
      key)
        handler="$(_ivar keyHandler)"
        if [[ -n "$handler" ]]; then
          __EVENT="$event"
          eval "$handler"
        fi
        ;;
      widget)
        widgetId=$(@ "$event" widgetId)
        hfile="$(_ivar handlerFile)"
        if [[ -f "$hfile" && -n "$widgetId" ]]; then
          # Find handler for this widget
          line=$(grep "^${widgetId}:" "$hfile" 2>/dev/null | head -1)
          if [[ -n "$line" ]]; then
            handler="${line#*:}"
            __EVENT="$event"
            eval "$handler"
          fi
        fi
        ;;
      mouse)
        handler="$(_ivar mouseHandler)"
        if [[ -n "$handler" ]]; then
          __EVENT="$event"
          eval "$handler"
        fi
        ;;
      resize)
        handler="$(_ivar resizeHandler)"
        if [[ -n "$handler" ]]; then
          __EVENT="$event"
          eval "$handler"
        fi
        ;;
      focus)
        handler="$(_ivar focusHandler)"
        if [[ -n "$handler" ]]; then
          __EVENT="$event"
          eval "$handler"
        fi
        ;;
    esac
  ]

  # Dispatch a raw JSON event (creates Event, then dispatches)
  rawMethod: dispatchJson: json [
    pragma: direct
    local json="$1" event

    # Skip non-JSON lines
    if ! echo "$json" | jq -e . >/dev/null 2>&1; then
      return
    fi

    event=$(@ Yutani::Event fromJson: "$json")
    @ "$_RECEIVER" dispatch: "$event"
  ]

  # Check if dispatcher is still running
  method: isRunning [
    ^ running
  ]

  # Stop the dispatcher
  method: stop [
    running := 'false'
  ]

  # Remove a widget handler
  rawMethod: removeHandlerFor: widgetId [
    local widgetId="$1" hfile
    hfile="$(_ivar handlerFile)"
    if [[ -f "$hfile" ]]; then
      grep -v "^${widgetId}:" "$hfile" > "${hfile}.tmp" 2>/dev/null || true
      mv "${hfile}.tmp" "$hfile"
    fi
  ]

  # Clean up handler file
  rawMethod: cleanup [
    local hfile
    hfile="$(_ivar handlerFile)"
    rm -f "$hfile" 2>/dev/null
  ]

  # Private setters
  method: _setHandlerFile: v [ handlerFile := v ]
  method: _setRunning: v [ running := v ]
