package: Yutani

# EventDispatcher - routes UI events to widget handlers
# Refactored to use Bash associative array for O(1) handler lookup

EventDispatcher subclass: Object
  instanceVars: keyHandler:'' mouseHandler:'' resizeHandler:'' focusHandler:'' running:''

  # ============================================================================
  # Initialization
  # ============================================================================

  # Create a new dispatcher with its own handler registry
  classMethod: new [
    | instance |
    instance := $(@ Runtime generateId: 'Yutani::EventDispatcher').
    @ Runtime create: 'Yutani::EventDispatcher' id: instance.
    @ instance _setRunning: 'true'.
    ^ instance
  ]

  # ============================================================================
  # Widget Handler Registration
  # ============================================================================

  # Register a handler for a specific widget
  # Handler is a bash command that will be eval'd with $__EVENT set
  # Uses file-based storage to survive subshell boundaries (bash-specific)
  rawMethod: onWidget: widgetId do: handler [
    pragma: bashOnly
    local widgetId="$1" handler="$2"
    local handlerFile="/tmp/yutani_handler_${widgetId}.txt"
    echo "$handler" > "$handlerFile"
  ]

  # Remove handler for a widget (bash-specific file operations)
  rawMethod: removeHandlerFor: widgetId [
    pragma: bashOnly
    local widgetId="$1"
    local handlerFile="/tmp/yutani_handler_${widgetId}.txt"
    rm -f "$handlerFile"
  ]

  # ============================================================================
  # Global Event Handlers
  # ============================================================================

  # Register a global key handler
  method: onKeyDo: handler [
    keyHandler := handler
  ]

  # Register a global mouse handler
  method: onMouseDo: handler [
    mouseHandler := handler
  ]

  # Register a global resize handler
  method: onResizeDo: handler [
    resizeHandler := handler
  ]

  # Register a global focus handler
  method: onFocusDo: handler [
    focusHandler := handler
  ]

  # ============================================================================
  # Event Dispatch
  # ============================================================================

  # Dispatch an event to the appropriate handler
  # Uses case statement, file I/O, and eval (bash-specific)
  rawMethod: dispatch: event [
    pragma: bashOnly
    pragma: direct
    local event="$1"
    local eventType widgetId handler

    eventType=$(@ "$event" eventType)

    case "$eventType" in
      key)
        handler="$(_ivar keyHandler)"
        if [[ -n "$handler" ]]; then
          __EVENT="$event"
          eval "$handler"
        fi
        ;;
      widget)
        widgetId=$(@ "$event" widgetId)
        if [[ -n "$widgetId" ]]; then
          local handlerFile="/tmp/yutani_handler_${widgetId}.txt"
          if [[ -f "$handlerFile" ]]; then
            handler=$(cat "$handlerFile")
            if [[ -n "$handler" ]]; then
              __EVENT="$event"
              eval "$handler"
            fi
          fi
        fi
        ;;
      mouse)
        handler="$(_ivar mouseHandler)"
        if [[ -n "$handler" ]]; then
          __EVENT="$event"
          eval "$handler"
        fi
        ;;
      resize)
        handler="$(_ivar resizeHandler)"
        if [[ -n "$handler" ]]; then
          __EVENT="$event"
          eval "$handler"
        fi
        ;;
      focus)
        handler="$(_ivar focusHandler)"
        if [[ -n "$handler" ]]; then
          __EVENT="$event"
          eval "$handler"
        fi
        ;;
    esac
  ]

  # Dispatch a raw JSON event (creates Event, then dispatches)
  # Skip non-JSON lines by checking for opening brace
  method: dispatchJson: json [
    | event |
    (@ String startsWith: json prefix: '{') ifTrue: [
      event := $(@ Yutani::Event fromJson: json).
      @ self dispatch: event
    ]
  ]

  # ============================================================================
  # Lifecycle
  # ============================================================================

  # Check if dispatcher is still running
  method: isRunning [
    ^ running
  ]

  # Stop the dispatcher
  method: stop [
    running := 'false'
  ]

  # Clean up all handlers for this dispatcher (bash-specific file operations)
  rawMethod: cleanup [
    pragma: bashOnly
    # Remove all handler files (simple cleanup - removes all yutani handlers)
    rm -f /tmp/yutani_handler_*.txt 2>/dev/null
    rm -f /tmp/yutani_text_*.txt 2>/dev/null
  ]

  # ============================================================================
  # Private Setters
  # ============================================================================

  method: _setRunning: v [ running := v ]

