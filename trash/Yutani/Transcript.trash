package: Yutani

Transcript subclass: Yutani::Application
  instanceVars: outputView:'' inputField:'' layout:'' history:''

  # Override setup to build the UI
  method: setup [
    | _layout _outputView _inputField initialText submitHandler keyHandler selfId |

    # Capture self ID for handler embedding
    selfId := $(@ self id).

    # Create layout
    _layout := $(@ self createVerticalLayout).
    layout := _layout.

    # Create output view with initial text
    initialText := 'Trashtalk Transcript
Type code and press Enter to evaluate. Ctrl+C to exit.
'.
    _outputView := $(@ self createTextView: 'Output' text: initialText).
    outputView := _outputView.
    history := initialText.

    # Create input field
    _inputField := $(@ self createInputField: '>' placeholder: 'Enter Trashtalk code...').
    inputField := _inputField.

    # Add widgets to layout
    @ _layout addChild: _outputView.
    @ _layout addChild: _inputField fixedSize: 3 focus: true.

    # Set root
    @ self setRoot: _layout.

    # Register event handlers - embed instance ID using string concatenation
    submitHandler := $(@ String concat: '@ "' with: selfId with: '" evaluateInput: "$__TEXT"').
    keyHandler := $(@ String concat: '@ "' with: selfId with: '" handleKey: "$__EVENT"').

    @ _inputField onSubmitDo: submitHandler.
    @ self onKeyDo: keyHandler
  ]

  # Handle key events
  method: handleKey: event [
    | keyName |
    keyName := $(@ event keyName).

    (@ String equals: keyName to: 'KEY_CTRL_C') ifTrue: [ @ self stop ].
    (@ String equals: keyName to: 'KEY_CTRL_D') ifTrue: [ @ self stop ].
    (@ String equals: keyName to: 'KEY_CTRL_L') ifTrue: [ @ self clearOutput ].
    (@ String equals: keyName to: 'KEY_TAB') ifTrue: [ @ inputField focus ].
    (@ String equals: keyName to: 'KEY_ESC') ifTrue: [
      @ inputField clear.
      @ inputField focus
    ]
  ]

  # Evaluate input text
  method: evaluateInput: text [
    | result newText |

    (@ String isEmpty: text) ifTrue: [ ^ nil ].

    # Evaluate the code
    result := $(@ Trash eval: text).

    # Build output: "> input\nresult\n\n"
    newText := $(@ String concat: '> ' with: text with: '
').
    newText := $(@ String concat: newText with: result with: '

').

    # Append to output
    @ self appendOutput: newText.

    # Clear and refocus input
    @ inputField clear.
    @ inputField focus
  ]

  # Append text to output
  method: appendOutput: text [
    | currentHistory |
    currentHistory := "${history}${text}".
    history := currentHistory.
    @ outputView setText: currentHistory
  ]

  # Clear output
  method: clearOutput [
    history := ''.
    @ outputView clear
  ]
