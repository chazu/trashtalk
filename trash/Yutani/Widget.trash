package: Yutani

Widget subclass: Object
  instanceVars: session:'' widgetId:'' title:'' dispatcher:'' submitHandler:'' pendingText:'' eventHandler:''

  # Session accessor
  method: getSession [
    ^ session
  ]

  method: setSession: s [
    session := s
  ]

  # Widget ID accessor
  method: getWidgetId [
    ^ widgetId
  ]

  method: setWidgetId: id [
    widgetId := id
  ]

  # Title accessor
  method: getTitle [
    ^ title
  ]

  method: setTitle: t [
    title := t
  ]

  # Dispatcher accessor
  method: getDispatcher [
    ^ dispatcher
  ]

  method: setDispatcher: d [
    dispatcher := d
  ]

  # Delete this widget from the session
  method: delete [
    | s w d |
    s := session.
    w := widgetId.
    d := dispatcher.
    (d notEmpty) ifTrue: [
      (w notEmpty) ifTrue: [
        @ d removeHandlerFor: w
      ]
    ].
    (s notEmpty) ifTrue: [
      (w notEmpty) ifTrue: [
        @ s deleteWidget: w
      ]
    ]
  ]

  # Focus this widget
  method: focus [
    | s w |
    s := session.
    w := widgetId.
    (s notEmpty) ifTrue: [
      (w notEmpty) ifTrue: [
        @ s focusWidget: w
      ]
    ]
  ]

  # Register an event handler for this widget
  # Handler is eval'd with $__EVENT set to the Event instance
  method: onEventDo: handler [
    | d w |
    d := dispatcher.
    w := widgetId.
    (d notEmpty) ifTrue: [
      (w notEmpty) ifTrue: [
        @ d onWidget: w do: handler
      ]
    ]
  ]

  # ============================================================================
  # Block-based Event Handling
  # ============================================================================
  # Widget can act as its own handler by implementing valueWith:
  # This allows onSubmitDo: to wrap user blocks with CHANGED/DONE logic

  # Called by EventDispatcher when Widget is registered as handler
  # Handles the CHANGED/DONE pattern: stores text on CHANGED, calls user block on DONE
  method: valueWith: event [
    | wt text |
    # If we have a submit handler, do CHANGED/DONE logic
    (submitHandler notEmpty) ifTrue: [
      wt := @ event widgetEventType.
      (wt = 'WIDGET_CHANGED') ifTrue: [
        pendingText := @ event widgetDataAt: 'text'
      ].
      (wt = 'WIDGET_DONE') ifTrue: [
        text := pendingText.
        @ submitHandler valueWith: text
      ].
      ^ nil
    ].
    # If we have an event handler, call it with the event
    (eventHandler notEmpty) ifTrue: [
      @ eventHandler valueWith: event
    ]
  ]

  # Register a Block handler for submission events
  # Block will be called with the submitted text when user presses Enter
  # Usage: @ widget onSubmitDo: [:text | @ Console print: text]
  method: onSubmitDo: handler [
    | d w |
    submitHandler := handler.
    d := dispatcher.
    w := widgetId.
    (d notEmpty) ifTrue: [
      (w notEmpty) ifTrue: [
        # Register self as handler - valueWith: handles the CHANGED/DONE logic
        @ d onWidget: w do: self
      ]
    ]
  ]
