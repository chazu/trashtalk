package: Yutani

IDE subclass: Yutani::Application
  instanceVars: outputView:'' inputField:'' layout:'' history:''

  # Override setup to build the UI
  # Uses printf for handler construction (bash-specific)
  rawMethod: setup [
    pragma: bashOnly
    local _layout _outputView _inputField initialText

    # Create layout
    _layout=$(@ "$_RECEIVER" createVerticalLayout)
    _ivar_set layout "$_layout"

    # Create output view
    initialText="Trashtalk IDE - Type code and press Enter
"
    _outputView=$(@ "$_RECEIVER" createTextView: "Transcript" text: "$initialText")
    _ivar_set outputView "$_outputView"
    _ivar_set history "$initialText"

    # Create input field
    _inputField=$(@ "$_RECEIVER" createInputField: ">" placeholder: "Enter code...")
    _ivar_set inputField "$_inputField"

    # Add to layout
    @ "$_layout" addChild: "$_outputView"
    @ "$_layout" addChild: "$_inputField" fixedSize: 3 focus: true

    # Set root
    @ "$_RECEIVER" setRoot: "$_layout"

    # Register event handlers - embed instance ID at registration time
    local submitHandler keyHandler
    printf -v submitHandler '@ "%s" evaluateInput: "$__TEXT"' "$_RECEIVER"
    printf -v keyHandler '@ "%s" handleKey: "$__EVENT"' "$_RECEIVER"

    @ "$_inputField" onSubmitDo: "$submitHandler"
    @ "$_RECEIVER" onKeyDo: "$keyHandler"
  ]

  # Handle key events (uses bash case statement)
  rawMethod: handleKey: event [
    pragma: bashOnly
    local event="$1" keyName _inputField

    keyName=$(@ "$event" keyName)
    _inputField="$(_ivar inputField)"

    case "$keyName" in
      KEY_CTRL_C|KEY_CTRL_D)
        @ "$_RECEIVER" stop
        ;;
      KEY_TAB)
        @ "$_inputField" focus
        ;;
      KEY_ESC)
        @ "$_inputField" clear
        @ "$_inputField" focus
        ;;
    esac
  ]

  # Evaluate input text (uses bash control flow and multi-line string building)
  rawMethod: evaluateInput: text [
    pragma: bashOnly
    local text="$1" result _inputField _outputView newText

    if [[ -z "$text" ]]; then
      return
    fi

    _inputField="$(_ivar inputField)"
    _outputView="$(_ivar outputView)"

    # Evaluate the code
    result=$(@ Trash eval: "$text" 2>&1)

    # Build output
    newText="> ${text}
${result}

"

    # Append to output
    @ "$_RECEIVER" appendOutput: "$newText"

    # Clear and refocus input
    @ "$_inputField" clear
    @ "$_inputField" focus
  ]

  # Append text to output
  method: appendOutput: text [
    | currentHistory |
    currentHistory := "${history}${text}".
    history := currentHistory.
    @ outputView setText: currentHistory
  ]
